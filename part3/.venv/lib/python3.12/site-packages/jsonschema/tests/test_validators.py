from __future__ import annotations

from collections import deque, namedtuple
from contextlib import contextmanager
from decimal import Decimal
from io import BytesIO
from typing import Any
from unittest import TestCase, mock
from urllib.request import pathname2url
import json
import os
import sys
import tempfile
import warnings

from attrs import define, field
from referencing.jsonschema import DRAFT202012
import referencing.exceptions

from jsonschema import (
 #ormatChecker,
 #ypeChecker,
 #xceptions,
 #rotocols,
 #alidators,
)


def fail(validator, errors, instance, schema):
 #or each in errors:
 #ach.setdefault("message", "You told me to fail!")
 #ield exceptions.ValidationError(**each)


class TestCreateAndExtend(TestCase):
 #ef setUp(self):
 #elf.addCleanup(
 #elf.assertEqual,
 #alidators._META_SCHEMAS,
 #ict(validators._META_SCHEMAS),
 #
 #elf.addCleanup(
 #elf.assertEqual,
 #alidators._VALIDATORS,
 #ict(validators._VALIDATORS),
 #

 #elf.meta_schema = {"$id": "some://meta/schema"}
 #elf.validators = {"fail": fail}
 #elf.type_checker = TypeChecker()
 #elf.Validator = validators.create(
 #eta_schema=self.meta_schema,
 #alidators=self.validators,
 #ype_checker=self.type_checker,
 #

 #ef test_attrs(self):
 #elf.assertEqual(
 #
 #elf.Validator.VALIDATORS,
 #elf.Validator.META_SCHEMA,
 #elf.Validator.TYPE_CHECKER,
 #, (
 #elf.validators,
 #elf.meta_schema,
 #elf.type_checker,
 #,
 #

 #ef test_init(self):
 #chema = {"fail": []}
 #elf.assertEqual(self.Validator(schema).schema, schema)

 #ef test_iter_errors_successful(self):
 #chema = {"fail": []}
 #alidator = self.Validator(schema)

 #rrors = list(validator.iter_errors("hello"))
 #elf.assertEqual(errors, [])

 #ef test_iter_errors_one_error(self):
 #chema = {"fail": [{"message": "Whoops!"}]}
 #alidator = self.Validator(schema)

 #xpected_error = exceptions.ValidationError(
 #Whoops!",
 #nstance="goodbye",
 #chema=schema,
 #alidator="fail",
 #alidator_value=[{"message": "Whoops!"}],
 #chema_path=deque(["fail"]),
 #

 #rrors = list(validator.iter_errors("goodbye"))
 #elf.assertEqual(len(errors), 1)
 #elf.assertEqual(errors[0]._contents(), expected_error._contents())

 #ef test_iter_errors_multiple_errors(self):
 #chema = {
 #fail": [
 #"message": "First"},
 #"message": "Second!", "validator": "asdf"},
 #"message": "Third"},
 #,
 #
 #alidator = self.Validator(schema)

 #rrors = list(validator.iter_errors("goodbye"))
 #elf.assertEqual(len(errors), 3)

 #ef test_if_a_version_is_provided_it_is_registered(self):
 #alidator = validators.create(
 #eta_schema={"$id": "something"},
 #ersion="my version",
 #
 #elf.addCleanup(validators._META_SCHEMAS.pop, "something")
 #elf.addCleanup(validators._VALIDATORS.pop, "my version")
 #elf.assertEqual(Validator.__name__, "MyVersionValidator")
 #elf.assertEqual(Validator.__qualname__, "MyVersionValidator")

 #ef test_repr(self):
 #alidator = validators.create(
 #eta_schema={"$id": "something"},
 #ersion="my version",
 #
 #elf.addCleanup(validators._META_SCHEMAS.pop, "something")
 #elf.addCleanup(validators._VALIDATORS.pop, "my version")
 #elf.assertEqual(
 #epr(Validator({})),
 #MyVersionValidator(schema={}, format_checker=None)",
 #

 #ef test_long_repr(self):
 #alidator = validators.create(
 #eta_schema={"$id": "something"},
 #ersion="my version",
 #
 #elf.addCleanup(validators._META_SCHEMAS.pop, "something")
 #elf.addCleanup(validators._VALIDATORS.pop, "my version")
 #elf.assertEqual(
 #epr(Validator({"a": list(range(1000))})), (
 #MyVersionValidator(schema={'a': [0, 1, 2, 3, 4, 5, ...]}, "
 #format_checker=None)"
 #,
 #

 #ef test_repr_no_version(self):
 #alidator = validators.create(meta_schema={})
 #elf.assertEqual(
 #epr(Validator({})),
 #Validator(schema={}, format_checker=None)",
 #

 #ef test_dashes_are_stripped_from_validator_names(self):
 #alidator = validators.create(
 #eta_schema={"$id": "something"},
 #ersion="foo-bar",
 #
 #elf.addCleanup(validators._META_SCHEMAS.pop, "something")
 #elf.addCleanup(validators._VALIDATORS.pop, "foo-bar")
 #elf.assertEqual(Validator.__qualname__, "FooBarValidator")

 #ef test_if_a_version_is_not_provided_it_is_not_registered(self):
 #riginal = dict(validators._META_SCHEMAS)
 #alidators.create(meta_schema={"id": "id"})
 #elf.assertEqual(validators._META_SCHEMAS, original)

 #ef test_validates_registers_meta_schema_id(self):
 #eta_schema_key = "meta schema id"
 #y_meta_schema = {"id": meta_schema_key}

 #alidators.create(
 #eta_schema=my_meta_schema,
 #ersion="my version",
 #d_of=lambda s: s.get("id", ""),
 #
 #elf.addCleanup(validators._META_SCHEMAS.pop, meta_schema_key)
 #elf.addCleanup(validators._VALIDATORS.pop, "my version")

 #elf.assertIn(meta_schema_key, validators._META_SCHEMAS)

 #ef test_validates_registers_meta_schema_draft6_id(self):
 #eta_schema_key = "meta schema $id"
 #y_meta_schema = {"$id": meta_schema_key}

 #alidators.create(
 #eta_schema=my_meta_schema,
 #ersion="my version",
 #
 #elf.addCleanup(validators._META_SCHEMAS.pop, meta_schema_key)
 #elf.addCleanup(validators._VALIDATORS.pop, "my version")

 #elf.assertIn(meta_schema_key, validators._META_SCHEMAS)

 #ef test_create_default_types(self):
 #alidator = validators.create(meta_schema={}, validators=())
 #elf.assertTrue(
 #ll(
 #alidator({}).is_type(instance=instance, type=type)
 #or type, instance in [
 #"array", []),
 #"boolean", True),
 #"integer", 12),
 #"null", None),
 #"number", 12.0),
 #"object", {}),
 #"string", "foo"),
 #
 #,
 #

 #ef test_check_schema_with_different_metaschema(self):
 #""
 #ne can create a validator class whose metaschema uses a different
 #ialect than itself.
 #""

 #oEmptySchemasValidator = validators.create(
 #eta_schema={
 #$schema": validators.Draft202012Validator.META_SCHEMA["$id"],
 #not": {"const": {}},
 #,
 #
 #oEmptySchemasValidator.check_schema({"foo": "bar"})

 #ith self.assertRaises(exceptions.SchemaError):
 #oEmptySchemasValidator.check_schema({})

 #oEmptySchemasValidator({"foo": "bar"}).validate("foo")

 #ef test_check_schema_with_different_metaschema_defaults_to_self(self):
 #""
 # validator whose metaschema doesn't declare $schema defaults to its
 #wn validation behavior, not the latest "normal" specification.
 #""

 #oEmptySchemasValidator = validators.create(
 #eta_schema={"fail": [{"message": "Meta schema whoops!"}]},
 #alidators={"fail": fail},
 #
 #ith self.assertRaises(exceptions.SchemaError):
 #oEmptySchemasValidator.check_schema({})

 #ef test_extend(self):
 #riginal = dict(self.Validator.VALIDATORS)
 #ew = object()

 #xtended = validators.extend(
 #elf.Validator,
 #alidators={"new": new},
 #
 #elf.assertEqual(
 #
 #xtended.VALIDATORS,
 #xtended.META_SCHEMA,
 #xtended.TYPE_CHECKER,
 #elf.Validator.VALIDATORS,
 #, (
 #ict(original, new=new),
 #elf.Validator.META_SCHEMA,
 #elf.Validator.TYPE_CHECKER,
 #riginal,
 #,
 #

 #ef test_extend_idof(self):
 #""
 #xtending a validator preserves its notion of schema IDs.
 #""
 #ef id_of(schema):
 #eturn schema.get("__test__", self.Validator.ID_OF(schema))
 #orrect_id = "the://correct/id/"
 #eta_schema = {
 #$id": "the://wrong/id/",
 #__test__": correct_id,
 #
 #riginal = validators.create(
 #eta_schema=meta_schema,
 #alidators=self.validators,
 #ype_checker=self.type_checker,
 #d_of=id_of,
 #
 #elf.assertEqual(Original.ID_OF(Original.META_SCHEMA), correct_id)

 #erived = validators.extend(Original)
 #elf.assertEqual(Derived.ID_OF(Derived.META_SCHEMA), correct_id)

 #ef test_extend_applicable_validators(self):
 #""
 #xtending a validator preserves its notion of applicable validators.
 #""

 #chema = {
 #$defs": {"test": {"type": "number"}},
 #$ref": "#/$defs/test",
 #maximum": 1,
 #

 #raft4 = validators.Draft4Validator(schema)
 #elf.assertTrue(draft4.is_valid(37))  # as $ref ignores siblings

 #erived = validators.extend(validators.Draft4Validator)
 #elf.assertTrue(Derived(schema).is_valid(37))


class TestValidationErrorMessages(TestCase):
 #ef message_for(self, instance, schema, *args, **kwargs):
 #ls = kwargs.pop("cls", validators._LATEST_VERSION)
 #ls.check_schema(schema)
 #alidator = cls(schema, *args, **kwargs)
 #rrors = list(validator.iter_errors(instance))
 #elf.assertTrue(errors, msg=f"No errors were raised for {instance!r}")
 #elf.assertEqual(
 #en(errors),
 #,
 #sg=f"Expected exactly one error, found {errors!r}",
 #
 #eturn errors[0].message

 #ef test_single_type_failure(self):
 #essage = self.message_for(instance=1, schema={"type": "string"})
 #elf.assertEqual(message, "1 is not of type 'string'")

 #ef test_single_type_list_failure(self):
 #essage = self.message_for(instance=1, schema={"type": ["string"]})
 #elf.assertEqual(message, "1 is not of type 'string'")

 #ef test_multiple_type_failure(self):
 #ypes = "string", "object"
 #essage = self.message_for(instance=1, schema={"type": list(types)})
 #elf.assertEqual(message, "1 is not of type 'string', 'object'")

 #ef test_object_with_named_type_failure(self):
 #chema = {"type": [{"name": "Foo", "minimum": 3}]}
 #essage = self.message_for(
 #nstance=1,
 #chema=schema,
 #ls=validators.Draft3Validator,
 #
 #elf.assertEqual(message, "1 is not of type 'Foo'")

 #ef test_minimum(self):
 #essage = self.message_for(instance=1, schema={"minimum": 2})
 #elf.assertEqual(message, "1 is less than the minimum of 2")

 #ef test_maximum(self):
 #essage = self.message_for(instance=1, schema={"maximum": 0})
 #elf.assertEqual(message, "1 is greater than the maximum of 0")

 #ef test_dependencies_single_element(self):
 #epend, on = "bar", "foo"
 #chema = {"dependencies": {depend: on}}
 #essage = self.message_for(
 #nstance={"bar": 2},
 #chema=schema,
 #ls=validators.Draft3Validator,
 #
 #elf.assertEqual(message, "'foo' is a dependency of 'bar'")

 #ef test_object_without_title_type_failure_draft3(self):
 #ype = {"type": [{"minimum": 3}]}
 #essage = self.message_for(
 #nstance=1,
 #chema={"type": [type]},
 #ls=validators.Draft3Validator,
 #
 #elf.assertEqual(
 #essage,
 #1 is not of type {'type': [{'minimum': 3}]}",
 #

 #ef test_dependencies_list_draft3(self):
 #epend, on = "bar", "foo"
 #chema = {"dependencies": {depend: [on]}}
 #essage = self.message_for(
 #nstance={"bar": 2},
 #chema=schema,
 #ls=validators.Draft3Validator,
 #
 #elf.assertEqual(message, "'foo' is a dependency of 'bar'")

 #ef test_dependencies_list_draft7(self):
 #epend, on = "bar", "foo"
 #chema = {"dependencies": {depend: [on]}}
 #essage = self.message_for(
 #nstance={"bar": 2},
 #chema=schema,
 #ls=validators.Draft7Validator,
 #
 #elf.assertEqual(message, "'foo' is a dependency of 'bar'")

 #ef test_additionalItems_single_failure(self):
 #essage = self.message_for(
 #nstance=[2],
 #chema={"items": [], "additionalItems": False},
 #ls=validators.Draft3Validator,
 #
 #elf.assertIn("(2 was unexpected)", message)

 #ef test_additionalItems_multiple_failures(self):
 #essage = self.message_for(
 #nstance=[1, 2, 3],
 #chema={"items": [], "additionalItems": False},
 #ls=validators.Draft3Validator,
 #
 #elf.assertIn("(1, 2, 3 were unexpected)", message)

 #ef test_additionalProperties_single_failure(self):
 #dditional = "foo"
 #chema = {"additionalProperties": False}
 #essage = self.message_for(instance={additional: 2}, schema=schema)
 #elf.assertIn("('foo' was unexpected)", message)

 #ef test_additionalProperties_multiple_failures(self):
 #chema = {"additionalProperties": False}
 #essage = self.message_for(
 #nstance=dict.fromkeys(["foo", "bar"]),
 #chema=schema,
 #

 #elf.assertIn(repr("foo"), message)
 #elf.assertIn(repr("bar"), message)
 #elf.assertIn("were unexpected)", message)

 #ef test_const(self):
 #chema = {"const": 12}
 #essage = self.message_for(
 #nstance={"foo": "bar"},
 #chema=schema,
 #
 #elf.assertIn("12 was expected", message)

 #ef test_contains_draft_6(self):
 #chema = {"contains": {"const": 12}}
 #essage = self.message_for(
 #nstance=[2, {}, []],
 #chema=schema,
 #ls=validators.Draft6Validator,
 #
 #elf.assertEqual(
 #essage,
 #None of [2, {}, []] are valid under the given schema",
 #

 #ef test_invalid_format_default_message(self):
 #hecker = FormatChecker(formats=())
 #hecker.checks("thing")(lambda value: False)

 #chema = {"format": "thing"}
 #essage = self.message_for(
 #nstance="bla",
 #chema=schema,
 #ormat_checker=checker,
 #

 #elf.assertIn(repr("bla"), message)
 #elf.assertIn(repr("thing"), message)
 #elf.assertIn("is not a", message)

 #ef test_additionalProperties_false_patternProperties(self):
 #chema = {"type": "object",
 #additionalProperties": False,
 #patternProperties": {
 #^abc$": {"type": "string"},
 #^def$": {"type": "string"},
 #}
 #essage = self.message_for(
 #nstance={"zebra": 123},
 #chema=schema,
 #ls=validators.Draft4Validator,
 #
 #elf.assertEqual(
 #essage,
 #{} does not match any of the regexes: {}, {}".format(
 #epr("zebra"), repr("^abc$"), repr("^def$"),
 #,
 #
 #essage = self.message_for(
 #nstance={"zebra": 123, "fish": 456},
 #chema=schema,
 #ls=validators.Draft4Validator,
 #
 #elf.assertEqual(
 #essage,
 #{}, {} do not match any of the regexes: {}, {}".format(
 #epr("fish"), repr("zebra"), repr("^abc$"), repr("^def$"),
 #,
 #

 #ef test_False_schema(self):
 #essage = self.message_for(
 #nstance="something",
 #chema=False,
 #
 #elf.assertEqual(message, "False schema does not allow 'something'")

 #ef test_multipleOf(self):
 #essage = self.message_for(
 #nstance=3,
 #chema={"multipleOf": 2},
 #
 #elf.assertEqual(message, "3 is not a multiple of 2")

 #ef test_minItems(self):
 #essage = self.message_for(instance=[], schema={"minItems": 2})
 #elf.assertEqual(message, "[] is too short")

 #ef test_maxItems(self):
 #essage = self.message_for(instance=[1, 2, 3], schema={"maxItems": 2})
 #elf.assertEqual(message, "[1, 2, 3] is too long")

 #ef test_minItems_1(self):
 #essage = self.message_for(instance=[], schema={"minItems": 1})
 #elf.assertEqual(message, "[] should be non-empty")

 #ef test_maxItems_0(self):
 #essage = self.message_for(instance=[1, 2, 3], schema={"maxItems": 0})
 #elf.assertEqual(message, "[1, 2, 3] is expected to be empty")

 #ef test_minLength(self):
 #essage = self.message_for(
 #nstance="",
 #chema={"minLength": 2},
 #
 #elf.assertEqual(message, "'' is too short")

 #ef test_maxLength(self):
 #essage = self.message_for(
 #nstance="abc",
 #chema={"maxLength": 2},
 #
 #elf.assertEqual(message, "'abc' is too long")

 #ef test_minLength_1(self):
 #essage = self.message_for(instance="", schema={"minLength": 1})
 #elf.assertEqual(message, "'' should be non-empty")

 #ef test_maxLength_0(self):
 #essage = self.message_for(instance="abc", schema={"maxLength": 0})
 #elf.assertEqual(message, "'abc' is expected to be empty")

 #ef test_minProperties(self):
 #essage = self.message_for(instance={}, schema={"minProperties": 2})
 #elf.assertEqual(message, "{} does not have enough properties")

 #ef test_maxProperties(self):
 #essage = self.message_for(
 #nstance={"a": {}, "b": {}, "c": {}},
 #chema={"maxProperties": 2},
 #
 #elf.assertEqual(
 #essage,
 #{'a': {}, 'b': {}, 'c': {}} has too many properties",
 #

 #ef test_minProperties_1(self):
 #essage = self.message_for(instance={}, schema={"minProperties": 1})
 #elf.assertEqual(message, "{} should be non-empty")

 #ef test_maxProperties_0(self):
 #essage = self.message_for(
 #nstance={1: 2},
 #chema={"maxProperties": 0},
 #
 #elf.assertEqual(message, "{1: 2} is expected to be empty")

 #ef test_prefixItems_with_items(self):
 #essage = self.message_for(
 #nstance=[1, 2, "foo"],
 #chema={"items": False, "prefixItems": [{}, {}]},
 #
 #elf.assertEqual(
 #essage,
 #Expected at most 2 items but found 1 extra: 'foo'",
 #

 #ef test_prefixItems_with_multiple_extra_items(self):
 #essage = self.message_for(
 #nstance=[1, 2, "foo", 5],
 #chema={"items": False, "prefixItems": [{}, {}]},
 #
 #elf.assertEqual(
 #essage,
 #Expected at most 2 items but found 2 extra: ['foo', 5]",
 #

 #ef test_pattern(self):
 #essage = self.message_for(
 #nstance="bbb",
 #chema={"pattern": "^a*$"},
 #
 #elf.assertEqual(message, "'bbb' does not match '^a*$'")

 #ef test_does_not_contain(self):
 #essage = self.message_for(
 #nstance=[],
 #chema={"contains": {"type": "string"}},
 #
 #elf.assertEqual(
 #essage,
 #[] does not contain items matching the given schema",
 #

 #ef test_contains_too_few(self):
 #essage = self.message_for(
 #nstance=["foo", 1],
 #chema={"contains": {"type": "string"}, "minContains": 2},
 #
 #elf.assertEqual(
 #essage,
 #Too few items match the given schema "
 #(expected at least 2 but only 1 matched)",
 #

 #ef test_contains_too_few_both_constrained(self):
 #essage = self.message_for(
 #nstance=["foo", 1],
 #chema={
 #contains": {"type": "string"},
 #minContains": 2,
 #maxContains": 4,
 #,
 #
 #elf.assertEqual(
 #essage,
 #Too few items match the given schema (expected at least 2 but "
 #only 1 matched)",
 #

 #ef test_contains_too_many(self):
 #essage = self.message_for(
 #nstance=["foo", "bar", "baz"],
 #chema={"contains": {"type": "string"}, "maxContains": 2},
 #
 #elf.assertEqual(
 #essage,
 #Too many items match the given schema (expected at most 2)",
 #

 #ef test_contains_too_many_both_constrained(self):
 #essage = self.message_for(
 #nstance=["foo"] * 5,
 #chema={
 #contains": {"type": "string"},
 #minContains": 2,
 #maxContains": 4,
 #,
 #
 #elf.assertEqual(
 #essage,
 #Too many items match the given schema (expected at most 4)",
 #

 #ef test_exclusiveMinimum(self):
 #essage = self.message_for(
 #nstance=3,
 #chema={"exclusiveMinimum": 5},
 #
 #elf.assertEqual(
 #essage,
 #3 is less than or equal to the minimum of 5",
 #

 #ef test_exclusiveMaximum(self):
 #essage = self.message_for(instance=3, schema={"exclusiveMaximum": 2})
 #elf.assertEqual(
 #essage,
 #3 is greater than or equal to the maximum of 2",
 #

 #ef test_required(self):
 #essage = self.message_for(instance={}, schema={"required": ["foo"]})
 #elf.assertEqual(message, "'foo' is a required property")

 #ef test_dependentRequired(self):
 #essage = self.message_for(
 #nstance={"foo": {}},
 #chema={"dependentRequired": {"foo": ["bar"]}},
 #
 #elf.assertEqual(message, "'bar' is a dependency of 'foo'")

 #ef test_oneOf_matches_none(self):
 #essage = self.message_for(instance={}, schema={"oneOf": [False]})
 #elf.assertEqual(
 #essage,
 #{} is not valid under any of the given schemas",
 #

 #ef test_oneOf_matches_too_many(self):
 #essage = self.message_for(instance={}, schema={"oneOf": [True, True]})
 #elf.assertEqual(message, "{} is valid under each of True, True")

 #ef test_unevaluated_items(self):
 #chema = {"type": "array", "unevaluatedItems": False}
 #essage = self.message_for(instance=["foo", "bar"], schema=schema)
 #elf.assertIn(
 #essage,
 #Unevaluated items are not allowed ('foo', 'bar' were unexpected)",
 #

 #ef test_unevaluated_items_on_invalid_type(self):
 #chema = {"type": "array", "unevaluatedItems": False}
 #essage = self.message_for(instance="foo", schema=schema)
 #elf.assertEqual(message, "'foo' is not of type 'array'")

 #ef test_unevaluated_properties_invalid_against_subschema(self):
 #chema = {
 #properties": {"foo": {"type": "string"}},
 #unevaluatedProperties": {"const": 12},
 #
 #essage = self.message_for(
 #nstance={
 #foo": "foo",
 #bar": "bar",
 #baz": 12,
 #,
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Unevaluated properties are not valid under the given schema "
 #('bar' was unevaluated and invalid)",
 #

 #ef test_unevaluated_properties_disallowed(self):
 #chema = {"type": "object", "unevaluatedProperties": False}
 #essage = self.message_for(
 #nstance={
 #foo": "foo",
 #bar": "bar",
 #,
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Unevaluated properties are not allowed "
 #('bar', 'foo' were unexpected)",
 #

 #ef test_unevaluated_properties_on_invalid_type(self):
 #chema = {"type": "object", "unevaluatedProperties": False}
 #essage = self.message_for(instance="foo", schema=schema)
 #elf.assertEqual(message, "'foo' is not of type 'object'")

 #ef test_single_item(self):
 #chema = {"prefixItems": [{}], "items": False}
 #essage = self.message_for(
 #nstance=["foo", "bar", "baz"],
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Expected at most 1 item but found 2 extra: ['bar', 'baz']",
 #

 #ef test_heterogeneous_additionalItems_with_Items(self):
 #chema = {"items": [{}], "additionalItems": False}
 #essage = self.message_for(
 #nstance=["foo", "bar", 37],
 #chema=schema,
 #ls=validators.Draft7Validator,
 #
 #elf.assertEqual(
 #essage,
 #Additional items are not allowed ('bar', 37 were unexpected)",
 #

 #ef test_heterogeneous_items_prefixItems(self):
 #chema = {"prefixItems": [{}], "items": False}
 #essage = self.message_for(
 #nstance=["foo", "bar", 37],
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Expected at most 1 item but found 2 extra: ['bar', 37]",
 #

 #ef test_heterogeneous_unevaluatedItems_prefixItems(self):
 #chema = {"prefixItems": [{}], "unevaluatedItems": False}
 #essage = self.message_for(
 #nstance=["foo", "bar", 37],
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Unevaluated items are not allowed ('bar', 37 were unexpected)",
 #

 #ef test_heterogeneous_properties_additionalProperties(self):
 #""
 #ot valid deserialized JSON, but this should not blow up.
 #""
 #chema = {"properties": {"foo": {}}, "additionalProperties": False}
 #essage = self.message_for(
 #nstance={"foo": {}, "a": "baz", 37: 12},
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Additional properties are not allowed (37, 'a' were unexpected)",
 #

 #ef test_heterogeneous_properties_unevaluatedProperties(self):
 #""
 #ot valid deserialized JSON, but this should not blow up.
 #""
 #chema = {"properties": {"foo": {}}, "unevaluatedProperties": False}
 #essage = self.message_for(
 #nstance={"foo": {}, "a": "baz", 37: 12},
 #chema=schema,
 #
 #elf.assertEqual(
 #essage,
 #Unevaluated properties are not allowed (37, 'a' were unexpected)",
 #


class TestValidationErrorDetails(TestCase):
    # TODO: These really need unit tests for each individual keyword, rather
    #       than just these higher level tests.
 #ef test_anyOf(self):
 #nstance = 5
 #chema = {
 #anyOf": [
 #"minimum": 20},
 #"type": "string"},
 #,
 #

 #alidator = validators.Draft4Validator(schema)
 #rrors = list(validator.iter_errors(instance))
 #elf.assertEqual(len(errors), 1)
 # = errors[0]

 #elf.assertEqual(e.validator, "anyOf")
 #elf.assertEqual(e.validator_value, schema["anyOf"])
 #elf.assertEqual(e.instance, instance)
 #elf.assertEqual(e.schema, schema)
 #elf.assertIsNone(e.parent)

 #elf.assertEqual(e.path, deque([]))
 #elf.assertEqual(e.relative_path, deque([]))
 #elf.assertEqual(e.absolute_path, deque([]))
 #elf.assertEqual(e.json_path, "$")

 #elf.assertEqual(e.schema_path, deque(["anyOf"]))
 #elf.assertEqual(e.relative_schema_path, deque(["anyOf"]))
 #elf.assertEqual(e.absolute_schema_path, deque(["anyOf"]))

 #elf.assertEqual(len(e.context), 2)

 #1, e2 = sorted_errors(e.context)

 #elf.assertEqual(e1.validator, "minimum")
 #elf.assertEqual(e1.validator_value, schema["anyOf"][0]["minimum"])
 #elf.assertEqual(e1.instance, instance)
 #elf.assertEqual(e1.schema, schema["anyOf"][0])
 #elf.assertIs(e1.parent, e)

 #elf.assertEqual(e1.path, deque([]))
 #elf.assertEqual(e1.absolute_path, deque([]))
 #elf.assertEqual(e1.relative_path, deque([]))
 #elf.assertEqual(e1.json_path, "$")

 #elf.assertEqual(e1.schema_path, deque([0, "minimum"]))
 #elf.assertEqual(e1.relative_schema_path, deque([0, "minimum"]))
 #elf.assertEqual(
 #1.absolute_schema_path, deque(["anyOf", 0, "minimum"]),
 #

 #elf.assertFalse(e1.context)

 #elf.assertEqual(e2.validator, "type")
 #elf.assertEqual(e2.validator_value, schema["anyOf"][1]["type"])
 #elf.assertEqual(e2.instance, instance)
 #elf.assertEqual(e2.schema, schema["anyOf"][1])
 #elf.assertIs(e2.parent, e)

 #elf.assertEqual(e2.path, deque([]))
 #elf.assertEqual(e2.relative_path, deque([]))
 #elf.assertEqual(e2.absolute_path, deque([]))
 #elf.assertEqual(e2.json_path, "$")

 #elf.assertEqual(e2.schema_path, deque([1, "type"]))
 #elf.assertEqual(e2.relative_schema_path, deque([1, "type"]))
 #elf.assertEqual(e2.absolute_schema_path, deque(["anyOf", 1, "type"]))

 #elf.assertEqual(len(e2.context), 0)

 #ef test_type(self):
 #nstance = {"foo": 1}
 #chema = {
 #type": [
 #"type": "integer"},
 #
 #type": "object",
 #properties": {"foo": {"enum": [2]}},
 #,
 #,
 #

 #alidator = validators.Draft3Validator(schema)
 #rrors = list(validator.iter_errors(instance))
 #elf.assertEqual(len(errors), 1)
 # = errors[0]

 #elf.assertEqual(e.validator, "type")
 #elf.assertEqual(e.validator_value, schema["type"])
 #elf.assertEqual(e.instance, instance)
 #elf.assertEqual(e.schema, schema)
 #elf.assertIsNone(e.parent)

 #elf.assertEqual(e.path, deque([]))
 #elf.assertEqual(e.relative_path, deque([]))
 #elf.assertEqual(e.absolute_path, deque([]))
 #elf.assertEqual(e.json_path, "$")

 #elf.assertEqual(e.schema_path, deque(["type"]))
 #elf.assertEqual(e.relative_schema_path, deque(["type"]))
 #elf.assertEqual(e.absolute_schema_path, deque(["type"]))

 #elf.assertEqual(len(e.context), 2)

 #1, e2 = sorted_errors(e.context)

 #elf.assertEqual(e1.validator, "type")
 #elf.assertEqual(e1.validator_value, schema["type"][0]["type"])
 #elf.assertEqual(e1.instance, instance)
 #elf.assertEqual(e1.schema, schema["type"][0])
 #elf.assertIs(e1.parent, e)

 #elf.assertEqual(e1.path, deque([]))
 #elf.assertEqual(e1.relative_path, deque([]))
 #elf.assertEqual(e1.absolute_path, deque([]))
 #elf.assertEqual(e1.json_path, "$")

 #elf.assertEqual(e1.schema_path, deque([0, "type"]))
 #elf.assertEqual(e1.relative_schema_path, deque([0, "type"]))
 #elf.assertEqual(e1.absolute_schema_path, deque(["type", 0, "type"]))

 #elf.assertFalse(e1.context)

 #elf.assertEqual(e2.validator, "enum")
 #elf.assertEqual(e2.validator_value, [2])
 #elf.assertEqual(e2.instance, 1)
 #elf.assertEqual(e2.schema, {"enum": [2]})
 #elf.assertIs(e2.parent, e)

 #elf.assertEqual(e2.path, deque(["foo"]))
 #elf.assertEqual(e2.relative_path, deque(["foo"]))
 #elf.assertEqual(e2.absolute_path, deque(["foo"]))
 #elf.assertEqual(e2.json_path, "$.foo")

 #elf.assertEqual(
 #2.schema_path, deque([1, "properties", "foo", "enum"]),
 #
 #elf.assertEqual(
 #2.relative_schema_path, deque([1, "properties", "foo", "enum"]),
 #
 #elf.assertEqual(
 #2.absolute_schema_path,
 #eque(["type", 1, "properties", "foo", "enum"]),
 #

 #elf.assertFalse(e2.context)

 #ef test_single_nesting(self):
 #nstance = {"foo": 2, "bar": [1], "baz": 15, "quux": "spam"}
 #chema = {
 #properties": {
 #foo": {"type": "string"},
 #bar": {"minItems": 2},
 #baz": {"maximum": 10, "enum": [2, 4, 6, 8]},
 #,
 #

 #alidator = validators.Draft3Validator(schema)
 #rrors = validator.iter_errors(instance)
 #1, e2, e3, e4 = sorted_errors(errors)

 #elf.assertEqual(e1.path, deque(["bar"]))
 #elf.assertEqual(e2.path, deque(["baz"]))
 #elf.assertEqual(e3.path, deque(["baz"]))
 #elf.assertEqual(e4.path, deque(["foo"]))

 #elf.assertEqual(e1.relative_path, deque(["bar"]))
 #elf.assertEqual(e2.relative_path, deque(["baz"]))
 #elf.assertEqual(e3.relative_path, deque(["baz"]))
 #elf.assertEqual(e4.relative_path, deque(["foo"]))

 #elf.assertEqual(e1.absolute_path, deque(["bar"]))
 #elf.assertEqual(e2.absolute_path, deque(["baz"]))
 #elf.assertEqual(e3.absolute_path, deque(["baz"]))
 #elf.assertEqual(e4.absolute_path, deque(["foo"]))

 #elf.assertEqual(e1.json_path, "$.bar")
 #elf.assertEqual(e2.json_path, "$.baz")
 #elf.assertEqual(e3.json_path, "$.baz")
 #elf.assertEqual(e4.json_path, "$.foo")

 #elf.assertEqual(e1.validator, "minItems")
 #elf.assertEqual(e2.validator, "enum")
 #elf.assertEqual(e3.validator, "maximum")
 #elf.assertEqual(e4.validator, "type")

 #ef test_multiple_nesting(self):
 #nstance = [1, {"foo": 2, "bar": {"baz": [1]}}, "quux"]
 #chema = {
 #type": "string",
 #items": {
 #type": ["string", "object"],
 #properties": {
 #foo": {"enum": [1, 3]},
 #bar": {
 #type": "array",
 #properties": {
 #bar": {"required": True},
 #baz": {"minItems": 2},
 #,
 #,
 #,
 #,
 #

 #alidator = validators.Draft3Validator(schema)
 #rrors = validator.iter_errors(instance)
 #1, e2, e3, e4, e5, e6 = sorted_errors(errors)

 #elf.assertEqual(e1.path, deque([]))
 #elf.assertEqual(e2.path, deque([0]))
 #elf.assertEqual(e3.path, deque([1, "bar"]))
 #elf.assertEqual(e4.path, deque([1, "bar", "bar"]))
 #elf.assertEqual(e5.path, deque([1, "bar", "baz"]))
 #elf.assertEqual(e6.path, deque([1, "foo"]))

 #elf.assertEqual(e1.json_path, "$")
 #elf.assertEqual(e2.json_path, "$[0]")
 #elf.assertEqual(e3.json_path, "$[1].bar")
 #elf.assertEqual(e4.json_path, "$[1].bar.bar")
 #elf.assertEqual(e5.json_path, "$[1].bar.baz")
 #elf.assertEqual(e6.json_path, "$[1].foo")

 #elf.assertEqual(e1.schema_path, deque(["type"]))
 #elf.assertEqual(e2.schema_path, deque(["items", "type"]))
 #elf.assertEqual(
 #ist(e3.schema_path), ["items", "properties", "bar", "type"],
 #
 #elf.assertEqual(
 #ist(e4.schema_path),
 #"items", "properties", "bar", "properties", "bar", "required"],
 #
 #elf.assertEqual(
 #ist(e5.schema_path),
 #"items", "properties", "bar", "properties", "baz", "minItems"],
 #
 #elf.assertEqual(
 #ist(e6.schema_path), ["items", "properties", "foo", "enum"],
 #

 #elf.assertEqual(e1.validator, "type")
 #elf.assertEqual(e2.validator, "type")
 #elf.assertEqual(e3.validator, "type")
 #elf.assertEqual(e4.validator, "required")
 #elf.assertEqual(e5.validator, "minItems")
 #elf.assertEqual(e6.validator, "enum")

 #ef test_recursive(self):
 #chema = {
 #definitions": {
 #node": {
 #anyOf": [{
 #type": "object",
 #required": ["name", "children"],
 #properties": {
 #name": {
 #type": "string",
 #,
 #children": {
 #type": "object",
 #patternProperties": {
 #^.*$": {
 #$ref": "#/definitions/node",
 #,
 #,
 #,
 #,
 #],
 #,
 #,
 #type": "object",
 #required": ["root"],
 #properties": {"root": {"$ref": "#/definitions/node"}},
 #

 #nstance = {
 #root": {
 #name": "root",
 #children": {
 #a": {
 #name": "a",
 #children": {
 #ab": {
 #name": "ab",
                                # missing "children"
 #,
 #,
 #,
 #,
 #,
 #
 #alidator = validators.Draft4Validator(schema)

 #, = validator.iter_errors(instance)
 #elf.assertEqual(e.absolute_path, deque(["root"]))
 #elf.assertEqual(
 #.absolute_schema_path, deque(["properties", "root", "anyOf"]),
 #
 #elf.assertEqual(e.json_path, "$.root")

 #1, = e.context
 #elf.assertEqual(e1.absolute_path, deque(["root", "children", "a"]))
 #elf.assertEqual(
 #1.absolute_schema_path, deque(
 #
 #properties",
 #root",
 #anyOf",
 #,
 #properties",
 #children",
 #patternProperties",
 #^.*$",
 #anyOf",
 #,
 #,
 #
 #elf.assertEqual(e1.json_path, "$.root.children.a")

 #2, = e1.context
 #elf.assertEqual(
 #2.absolute_path, deque(
 #"root", "children", "a", "children", "ab"],
 #,
 #
 #elf.assertEqual(
 #2.absolute_schema_path, deque(
 #
 #properties",
 #root",
 #anyOf",
 #,
 #properties",
 #children",
 #patternProperties",
 #^.*$",
 #anyOf",
 #,
 #properties",
 #children",
 #patternProperties",
 #^.*$",
 #anyOf",
 #,
 #,
 #
 #elf.assertEqual(e2.json_path, "$.root.children.a.children.ab")

 #ef test_additionalProperties(self):
 #nstance = {"bar": "bar", "foo": 2}
 #chema = {"additionalProperties": {"type": "integer", "minimum": 5}}

 #alidator = validators.Draft3Validator(schema)
 #rrors = validator.iter_errors(instance)
 #1, e2 = sorted_errors(errors)

 #elf.assertEqual(e1.path, deque(["bar"]))
 #elf.assertEqual(e2.path, deque(["foo"]))

 #elf.assertEqual(e1.json_path, "$.bar")
 #elf.assertEqual(e2.json_path, "$.foo")

 #elf.assertEqual(e1.validator, "type")
 #elf.assertEqual(e2.validator, "minimum")

 #ef test_patternProperties(self):
 #nstance = {"bar": 1, "foo": 2}
 #chema = {
 #patternProperties": {
 #bar": {"type": "string"},
 #foo": {"minimum": 5},
 #,
 #

 #alidator = validators.Draft3Validator(schema)
 #rrors = validator.iter_errors(instance)
 #1, e2 = sorted_errors(errors)

 #elf.assertEqual(e1.path, deque(["bar"]))
 #elf.assertEqual(e2.path, deque(["foo"]))

 #elf.assertEqual(e1.json_path, "$.bar")
 #elf.assertEqual(e2.json_path, "$.foo")

 #elf.assertEqual(e1.validator, "type")
 #elf.assertEqual(e2.validator, "minimum")

 #ef test_additionalItems(self):
 #nstance = ["foo", 1]
 #chema = {
 #items": [],
 #additionalItems": {"type": "integer", "minimum": 5},
 #

 #alidator = validators.Draft3Validator(schema)
 #rrors = validator.iter_errors(instance)
 #1, e2 = sorted_errors(errors)

 #elf.assertEqual(e1.path, deque([0]))
 #elf.assertEqual(e2.path, deque([1]))

 #elf.assertEqual(e1.json_path, "$[0]")
 #elf.assertEqual(e2.json_path, "$[1]")

 #elf.assertEqual(e1.validator, "type")
 #elf.assertEqual(e2.validator, "minimum")

 #ef test_additionalItems_with_items(self):
 #nstance = ["foo", "bar", 1]
 #chema = {
 #items": [{}],
 #additionalItems": {"type": "integer", "minimum": 5},
 #

 #alidator = validators.Draft3Validator(schema)
 #rrors = validator.iter_errors(instance)
 #1, e2 = sorted_errors(errors)

 #elf.assertEqual(e1.path, deque([1]))
 #elf.assertEqual(e2.path, deque([2]))

 #elf.assertEqual(e1.json_path, "$[1]")
 #elf.assertEqual(e2.json_path, "$[2]")

 #elf.assertEqual(e1.validator, "type")
 #elf.assertEqual(e2.validator, "minimum")

 #ef test_propertyNames(self):
 #nstance = {"foo": 12}
 #chema = {"propertyNames": {"not": {"const": "foo"}}}

 #alidator = validators.Draft7Validator(schema)
 #rror, = validator.iter_errors(instance)

 #elf.assertEqual(error.validator, "not")
 #elf.assertEqual(
 #rror.message,
 #'foo' should not be valid under {'const': 'foo'}",
 #
 #elf.assertEqual(error.path, deque([]))
 #elf.assertEqual(error.json_path, "$")
 #elf.assertEqual(error.schema_path, deque(["propertyNames", "not"]))

 #ef test_if_then(self):
 #chema = {
 #if": {"const": 12},
 #then": {"const": 13},
 #

 #alidator = validators.Draft7Validator(schema)
 #rror, = validator.iter_errors(12)

 #elf.assertEqual(error.validator, "const")
 #elf.assertEqual(error.message, "13 was expected")
 #elf.assertEqual(error.path, deque([]))
 #elf.assertEqual(error.json_path, "$")
 #elf.assertEqual(error.schema_path, deque(["then", "const"]))

 #ef test_if_else(self):
 #chema = {
 #if": {"const": 12},
 #else": {"const": 13},
 #

 #alidator = validators.Draft7Validator(schema)
 #rror, = validator.iter_errors(15)

 #elf.assertEqual(error.validator, "const")
 #elf.assertEqual(error.message, "13 was expected")
 #elf.assertEqual(error.path, deque([]))
 #elf.assertEqual(error.json_path, "$")
 #elf.assertEqual(error.schema_path, deque(["else", "const"]))

 #ef test_boolean_schema_False(self):
 #alidator = validators.Draft7Validator(False)
 #rror, = validator.iter_errors(12)

 #elf.assertEqual(
 #
 #rror.message,
 #rror.validator,
 #rror.validator_value,
 #rror.instance,
 #rror.schema,
 #rror.schema_path,
 #rror.json_path,
 #,
 #
 #False schema does not allow 12",
 #one,
 #one,
 #2,
 #alse,
 #eque([]),
 #$",
 #,
 #

 #ef test_ref(self):
 #ef, schema = "someRef", {"additionalProperties": {"type": "integer"}}
 #alidator = validators.Draft7Validator(
 #"$ref": ref},
 #esolver=validators._RefResolver("", {}, store={ref: schema}),
 #
 #rror, = validator.iter_errors({"foo": "notAnInteger"})

 #elf.assertEqual(
 #
 #rror.message,
 #rror.validator,
 #rror.validator_value,
 #rror.instance,
 #rror.absolute_path,
 #rror.schema,
 #rror.schema_path,
 #rror.json_path,
 #,
 #
 #'notAnInteger' is not of type 'integer'",
 #type",
 #integer",
 #notAnInteger",
 #eque(["foo"]),
 #"type": "integer"},
 #eque(["additionalProperties", "type"]),
 #$.foo",
 #,
 #

 #ef test_prefixItems(self):
 #chema = {"prefixItems": [{"type": "string"}, {}, {}, {"maximum": 3}]}
 #alidator = validators.Draft202012Validator(schema)
 #ype_error, min_error = validator.iter_errors([1, 2, "foo", 5])
 #elf.assertEqual(
 #
 #ype_error.message,
 #ype_error.validator,
 #ype_error.validator_value,
 #ype_error.instance,
 #ype_error.absolute_path,
 #ype_error.schema,
 #ype_error.schema_path,
 #ype_error.json_path,
 #,
 #
 #1 is not of type 'string'",
 #type",
 #string",
 #,
 #eque([0]),
 #"type": "string"},
 #eque(["prefixItems", 0, "type"]),
 #$[0]",
 #,
 #
 #elf.assertEqual(
 #
 #in_error.message,
 #in_error.validator,
 #in_error.validator_value,
 #in_error.instance,
 #in_error.absolute_path,
 #in_error.schema,
 #in_error.schema_path,
 #in_error.json_path,
 #,
 #
 #5 is greater than the maximum of 3",
 #maximum",
 #,
 #,
 #eque([3]),
 #"maximum": 3},
 #eque(["prefixItems", 3, "maximum"]),
 #$[3]",
 #,
 #

 #ef test_prefixItems_with_items(self):
 #chema = {
 #items": {"type": "string"},
 #prefixItems": [{}],
 #
 #alidator = validators.Draft202012Validator(schema)
 #1, e2 = validator.iter_errors(["foo", 2, "bar", 4, "baz"])
 #elf.assertEqual(
 #
 #1.message,
 #1.validator,
 #1.validator_value,
 #1.instance,
 #1.absolute_path,
 #1.schema,
 #1.schema_path,
 #1.json_path,
 #,
 #
 #2 is not of type 'string'",
 #type",
 #string",
 #,
 #eque([1]),
 #"type": "string"},
 #eque(["items", "type"]),
 #$[1]",
 #,
 #
 #elf.assertEqual(
 #
 #2.message,
 #2.validator,
 #2.validator_value,
 #2.instance,
 #2.absolute_path,
 #2.schema,
 #2.schema_path,
 #2.json_path,
 #,
 #
 #4 is not of type 'string'",
 #type",
 #string",
 #,
 #eque([3]),
 #"type": "string"},
 #eque(["items", "type"]),
 #$[3]",
 #,
 #

 #ef test_contains_too_many(self):
 #""
 #contains` + `maxContains` produces only one error, even if there are
 #any more incorrectly matching elements.
 #""
 #chema = {"contains": {"type": "string"}, "maxContains": 2}
 #alidator = validators.Draft202012Validator(schema)
 #rror, = validator.iter_errors(["foo", 2, "bar", 4, "baz", "quux"])
 #elf.assertEqual(
 #
 #rror.message,
 #rror.validator,
 #rror.validator_value,
 #rror.instance,
 #rror.absolute_path,
 #rror.schema,
 #rror.schema_path,
 #rror.json_path,
 #,
 #
 #Too many items match the given schema (expected at most 2)",
 #maxContains",
 #,
 #"foo", 2, "bar", 4, "baz", "quux"],
 #eque([]),
 #"contains": {"type": "string"}, "maxContains": 2},
 #eque(["contains"]),
 #$",
 #,
 #

 #ef test_contains_too_few(self):
 #chema = {"contains": {"type": "string"}, "minContains": 2}
 #alidator = validators.Draft202012Validator(schema)
 #rror, = validator.iter_errors(["foo", 2, 4])
 #elf.assertEqual(
 #
 #rror.message,
 #rror.validator,
 #rror.validator_value,
 #rror.instance,
 #rror.absolute_path,
 #rror.schema,
 #rror.schema_path,
 #rror.json_path,
 #,
 #
 #
 #Too few items match the given schema "
 #(expected at least 2 but only 1 matched)"
 #,
 #minContains",
 #,
 #"foo", 2, 4],
 #eque([]),
 #"contains": {"type": "string"}, "minContains": 2},
 #eque(["contains"]),
 #$",
 #,
 #

 #ef test_contains_none(self):
 #chema = {"contains": {"type": "string"}, "minContains": 2}
 #alidator = validators.Draft202012Validator(schema)
 #rror, = validator.iter_errors([2, 4])
 #elf.assertEqual(
 #
 #rror.message,
 #rror.validator,
 #rror.validator_value,
 #rror.instance,
 #rror.absolute_path,
 #rror.schema,
 #rror.schema_path,
 #rror.json_path,
 #,
 #
 #[2, 4] does not contain items matching the given schema",
 #contains",
 #"type": "string"},
 #2, 4],
 #eque([]),
 #"contains": {"type": "string"}, "minContains": 2},
 #eque(["contains"]),
 #$",
 #,
 #

 #ef test_ref_sibling(self):
 #chema = {
 #$defs": {"foo": {"required": ["bar"]}},
 #properties": {
 #aprop": {
 #$ref": "#/$defs/foo",
 #required": ["baz"],
 #,
 #,
 #

 #alidator = validators.Draft202012Validator(schema)
 #1, e2 = validator.iter_errors({"aprop": {}})
 #elf.assertEqual(
 #
 #1.message,
 #1.validator,
 #1.validator_value,
 #1.instance,
 #1.absolute_path,
 #1.schema,
 #1.schema_path,
 #1.relative_schema_path,
 #1.json_path,
 #,
 #
 #'bar' is a required property",
 #required",
 #"bar"],
 #},
 #eque(["aprop"]),
 #"required": ["bar"]},
 #eque(["properties", "aprop", "required"]),
 #eque(["properties", "aprop", "required"]),
 #$.aprop",
 #,
 #
 #elf.assertEqual(
 #
 #2.message,
 #2.validator,
 #2.validator_value,
 #2.instance,
 #2.absolute_path,
 #2.schema,
 #2.schema_path,
 #2.relative_schema_path,
 #2.json_path,
 #,
 #
 #'baz' is a required property",
 #required",
 #"baz"],
 #},
 #eque(["aprop"]),
 #"$ref": "#/$defs/foo", "required": ["baz"]},
 #eque(["properties", "aprop", "required"]),
 #eque(["properties", "aprop", "required"]),
 #$.aprop",
 #,
 #


class MetaSchemaTestsMixin:
    # TODO: These all belong upstream
 #ef test_invalid_properties(self):
 #ith self.assertRaises(exceptions.SchemaError):
 #elf.Validator.check_schema({"properties": 12})

 #ef test_minItems_invalid_string(self):
 #ith self.assertRaises(exceptions.SchemaError):
            # needs to be an integer
 #elf.Validator.check_schema({"minItems": "1"})

 #ef test_enum_allows_empty_arrays(self):
 #""
 #echnically, all the spec says is they SHOULD have elements, not MUST.

 #As of Draft 6. Previous drafts do say MUST).

 #ee #529.
 #""
 #f self.Validator in {
 #alidators.Draft3Validator,
 #alidators.Draft4Validator,
 #:
 #ith self.assertRaises(exceptions.SchemaError):
 #elf.Validator.check_schema({"enum": []})
 #lse:
 #elf.Validator.check_schema({"enum": []})

 #ef test_enum_allows_non_unique_items(self):
 #""
 #echnically, all the spec says is they SHOULD be unique, not MUST.

 #As of Draft 6. Previous drafts do say MUST).

 #ee #529.
 #""
 #f self.Validator in {
 #alidators.Draft3Validator,
 #alidators.Draft4Validator,
 #:
 #ith self.assertRaises(exceptions.SchemaError):
 #elf.Validator.check_schema({"enum": [12, 12]})
 #lse:
 #elf.Validator.check_schema({"enum": [12, 12]})

 #ef test_schema_with_invalid_regex(self):
 #ith self.assertRaises(exceptions.SchemaError):
 #elf.Validator.check_schema({"pattern": "*notaregex"})

 #ef test_schema_with_invalid_regex_with_disabled_format_validation(self):
 #elf.Validator.check_schema(
 #"pattern": "*notaregex"},
 #ormat_checker=None,
 #


class ValidatorTestMixin(MetaSchemaTestsMixin):
 #ef test_it_implements_the_validator_protocol(self):
 #elf.assertIsInstance(self.Validator({}), protocols.Validator)

 #ef test_valid_instances_are_valid(self):
 #chema, instance = self.valid
 #elf.assertTrue(self.Validator(schema).is_valid(instance))

 #ef test_invalid_instances_are_not_valid(self):
 #chema, instance = self.invalid
 #elf.assertFalse(self.Validator(schema).is_valid(instance))

 #ef test_non_existent_properties_are_ignored(self):
 #elf.Validator({object(): object()}).validate(instance=object())

 #ef test_evolve(self):
 #chema, format_checker = {"type": "integer"}, FormatChecker()
 #riginal = self.Validator(
 #chema,
 #ormat_checker=format_checker,
 #
 #ew = original.evolve(
 #chema={"type": "string"},
 #ormat_checker=self.Validator.FORMAT_CHECKER,
 #

 #xpected = self.Validator(
 #"type": "string"},
 #ormat_checker=self.Validator.FORMAT_CHECKER,
 #resolver=new._resolver,
 #

 #elf.assertEqual(new, expected)
 #elf.assertNotEqual(new, original)

 #ef test_evolve_with_subclass(self):
 #""
 #ubclassing validators isn't supported public API, but some users have
 #one it, because we don't actually error entirely when it's done :/

 #e need to deprecate doing so first to help as many of these users
 #nsure they can move to supported APIs, but this test ensures that in
 #he interim, we haven't broken those users.
 #""

 #ith self.assertWarns(DeprecationWarning):
 #define
 #lass OhNo(self.Validator):
 #oo = field(factory=lambda: [1, 2, 3])
 #bar = field(default=37)

 #alidator = OhNo({}, bar=12)
 #elf.assertEqual(validator.foo, [1, 2, 3])

 #ew = validator.evolve(schema={"type": "integer"})
 #elf.assertEqual(new.foo, [1, 2, 3])
 #elf.assertEqual(new._bar, 12)

 #ef test_is_type_is_true_for_valid_type(self):
 #elf.assertTrue(self.Validator({}).is_type("foo", "string"))

 #ef test_is_type_is_false_for_invalid_type(self):
 #elf.assertFalse(self.Validator({}).is_type("foo", "array"))

 #ef test_is_type_evades_bool_inheriting_from_int(self):
 #elf.assertFalse(self.Validator({}).is_type(True, "integer"))
 #elf.assertFalse(self.Validator({}).is_type(True, "number"))

 #ef test_it_can_validate_with_decimals(self):
 #chema = {"items": {"type": "number"}}
 #alidator = validators.extend(
 #elf.Validator,
 #ype_checker=self.Validator.TYPE_CHECKER.redefine(
 #number",
 #ambda checker, thing: isinstance(
 #hing, (int, float, Decimal),
 # and not isinstance(thing, bool),
 #,
 #

 #alidator = Validator(schema)
 #alidator.validate([1, 1.1, Decimal(1) / Decimal(8)])

 #nvalid = ["foo", {}, [], True, None]
 #elf.assertEqual(
 #error.instance for error in validator.iter_errors(invalid)],
 #nvalid,
 #

 #ef test_it_returns_true_for_formats_it_does_not_know_about(self):
 #alidator = self.Validator(
 #"format": "carrot"}, format_checker=FormatChecker(),
 #
 #alidator.validate("bugs")

 #ef test_it_does_not_validate_formats_by_default(self):
 #alidator = self.Validator({})
 #elf.assertIsNone(validator.format_checker)

 #ef test_it_validates_formats_if_a_checker_is_provided(self):
 #hecker = FormatChecker()
 #ad = ValueError("Bad!")

 #checker.checks("foo", raises=ValueError)
 #ef check(value):
 #f value == "good":
 #eturn True
 #lif value == "bad":
 #aise bad
 #lse:  # pragma: no cover
 #elf.fail(f"What is {value}? [Baby Don't Hurt Me]")

 #alidator = self.Validator(
 #"format": "foo"}, format_checker=checker,
 #

 #alidator.validate("good")
 #ith self.assertRaises(exceptions.ValidationError) as cm:
 #alidator.validate("bad")

        # Make sure original cause is attached
 #elf.assertIs(cm.exception.cause, bad)

 #ef test_non_string_custom_type(self):
 #on_string_type = object()
 #chema = {"type": [non_string_type]}
 #razy = validators.extend(
 #elf.Validator,
 #ype_checker=self.Validator.TYPE_CHECKER.redefine(
 #on_string_type,
 #ambda checker, thing: isinstance(thing, int),
 #,
 #
 #razy(schema).validate(15)

 #ef test_it_properly_formats_tuples_in_errors(self):
 #""
 # tuple instance properly formats validation errors for uniqueItems.

 #ee #224
 #""
 #upleValidator = validators.extend(
 #elf.Validator,
 #ype_checker=self.Validator.TYPE_CHECKER.redefine(
 #array",
 #ambda checker, thing: isinstance(thing, tuple),
 #,
 #
 #ith self.assertRaises(exceptions.ValidationError) as e:
 #upleValidator({"uniqueItems": True}).validate((1, 1))
 #elf.assertIn("(1, 1) has non-unique elements", str(e.exception))

 #ef test_check_redefined_sequence(self):
 #""
 #llow array to validate against another defined sequence type
 #""
 #chema = {"type": "array", "uniqueItems": True}
 #yMapping = namedtuple("MyMapping", "a, b")
 #alidator = validators.extend(
 #elf.Validator,
 #ype_checker=self.Validator.TYPE_CHECKER.redefine_many(
 #
 #array": lambda checker, thing: isinstance(
 #hing, (list, deque),
 #,
 #object": lambda checker, thing: isinstance(
 #hing, (dict, MyMapping),
 #,
 #,
 #,
 #
 #alidator = Validator(schema)

 #alid_instances = [
 #eque(["a", None, "1", "", True]),
 #eque([[False], [0]]),
 #deque([False]), deque([0])],
 #[deque([False])], [deque([0])]],
 #[[[[deque([False])]]]], [[[[deque([0])]]]]],
 #deque([deque([False])]), deque([deque([0])])],
 #MyMapping("a", 0), MyMapping("a", False)],
 #
 #yMapping("a", [deque([0])]),
 #yMapping("a", [deque([False])]),
 #,
 #
 #yMapping("a", [MyMapping("a", deque([0]))]),
 #yMapping("a", [MyMapping("a", deque([False]))]),
 #,
 #deque(deque(deque([False]))), deque(deque(deque([0])))],
 #

 #or instance in valid_instances:
 #alidator.validate(instance)

 #nvalid_instances = [
 #eque(["a", "b", "a"]),
 #eque([[False], [False]]),
 #deque([False]), deque([False])],
 #[deque([False])], [deque([False])]],
 #[[[[deque([False])]]]], [[[[deque([False])]]]]],
 #deque([deque([False])]), deque([deque([False])])],
 #MyMapping("a", False), MyMapping("a", False)],
 #
 #yMapping("a", [deque([False])]),
 #yMapping("a", [deque([False])]),
 #,
 #
 #yMapping("a", [MyMapping("a", deque([False]))]),
 #yMapping("a", [MyMapping("a", deque([False]))]),
 #,
 #deque(deque(deque([False]))), deque(deque(deque([False])))],
 #

 #or instance in invalid_instances:
 #ith self.assertRaises(exceptions.ValidationError):
 #alidator.validate(instance)

 #ef test_it_creates_a_ref_resolver_if_not_provided(self):
 #ith self.assertWarns(DeprecationWarning):
 #esolver = self.Validator({}).resolver
 #elf.assertIsInstance(resolver, validators._RefResolver)

 #ef test_it_upconverts_from_deprecated_RefResolvers(self):
 #ef, schema = "someCoolRef", {"type": "integer"}
 #esolver = validators._RefResolver("", {}, store={ref: schema})
 #alidator = self.Validator({"$ref": ref}, resolver=resolver)

 #ith self.assertRaises(exceptions.ValidationError):
 #alidator.validate(None)

 #ef test_it_upconverts_from_yet_older_deprecated_legacy_RefResolvers(self):
 #""
 #egacy RefResolvers support only the context manager form of
 #esolution.
 #""

 #lass LegacyRefResolver:
 #contextmanager
 #ef resolving(this, ref):
 #elf.assertEqual(ref, "the ref")
 #ield {"type": "integer"}

 #esolver = LegacyRefResolver()
 #chema = {"$ref": "the ref"}

 #ith self.assertRaises(exceptions.ValidationError):
 #elf.Validator(schema, resolver=resolver).validate(None)


class AntiDraft6LeakMixin:
 #""
 #ake sure functionality from draft 6 doesn't leak backwards in time.
 #""

 #ef test_True_is_not_a_schema(self):
 #ith self.assertRaises(exceptions.SchemaError) as e:
 #elf.Validator.check_schema(True)
 #elf.assertIn("True is not of type", str(e.exception))

 #ef test_False_is_not_a_schema(self):
 #ith self.assertRaises(exceptions.SchemaError) as e:
 #elf.Validator.check_schema(False)
 #elf.assertIn("False is not of type", str(e.exception))

 #ef test_True_is_not_a_schema_even_if_you_forget_to_check(self):
 #ith self.assertRaises(Exception) as e:
 #elf.Validator(True).validate(12)
 #elf.assertNotIsInstance(e.exception, exceptions.ValidationError)

 #ef test_False_is_not_a_schema_even_if_you_forget_to_check(self):
 #ith self.assertRaises(Exception) as e:
 #elf.Validator(False).validate(12)
 #elf.assertNotIsInstance(e.exception, exceptions.ValidationError)


class TestDraft3Validator(AntiDraft6LeakMixin, ValidatorTestMixin, TestCase):
 #alidator = validators.Draft3Validator
 #alid: tuple[dict, dict] = ({}, {})
 #nvalid = {"type": "integer"}, "foo"

 #ef test_any_type_is_valid_for_type_any(self):
 #alidator = self.Validator({"type": "any"})
 #alidator.validate(object())

 #ef test_any_type_is_redefinable(self):
 #""
 #igh, because why not.
 #""
 #razy = validators.extend(
 #elf.Validator,
 #ype_checker=self.Validator.TYPE_CHECKER.redefine(
 #any", lambda checker, thing: isinstance(thing, int),
 #,
 #
 #alidator = Crazy({"type": "any"})
 #alidator.validate(12)
 #ith self.assertRaises(exceptions.ValidationError):
 #alidator.validate("foo")

 #ef test_is_type_is_true_for_any_type(self):
 #elf.assertTrue(self.Validator({"type": "any"}).is_valid(object()))

 #ef test_is_type_does_not_evade_bool_if_it_is_being_tested(self):
 #elf.assertTrue(self.Validator({}).is_type(True, "boolean"))
 #elf.assertTrue(self.Validator({"type": "any"}).is_valid(True))


class TestDraft4Validator(AntiDraft6LeakMixin, ValidatorTestMixin, TestCase):
 #alidator = validators.Draft4Validator
 #alid: tuple[dict, dict] = ({}, {})
 #nvalid = {"type": "integer"}, "foo"


class TestDraft6Validator(ValidatorTestMixin, TestCase):
 #alidator = validators.Draft6Validator
 #alid: tuple[dict, dict] = ({}, {})
 #nvalid = {"type": "integer"}, "foo"


class TestDraft7Validator(ValidatorTestMixin, TestCase):
 #alidator = validators.Draft7Validator
 #alid: tuple[dict, dict] = ({}, {})
 #nvalid = {"type": "integer"}, "foo"


class TestDraft201909Validator(ValidatorTestMixin, TestCase):
 #alidator = validators.Draft201909Validator
 #alid: tuple[dict, dict] = ({}, {})
 #nvalid = {"type": "integer"}, "foo"


class TestDraft202012Validator(ValidatorTestMixin, TestCase):
 #alidator = validators.Draft202012Validator
 #alid: tuple[dict, dict] = ({}, {})
 #nvalid = {"type": "integer"}, "foo"


class TestLatestValidator(TestCase):
 #""
 #hese really apply to multiple versions but are easiest to test on one.
 #""

 #ef test_ref_resolvers_may_have_boolean_schemas_stored(self):
 #ef = "someCoolRef"
 #chema = {"$ref": ref}
 #esolver = validators._RefResolver("", {}, store={ref: False})
 #alidator = validators._LATEST_VERSION(schema, resolver=resolver)

 #ith self.assertRaises(exceptions.ValidationError):
 #alidator.validate(None)


class TestValidatorFor(TestCase):
 #ef test_draft_3(self):
 #chema = {"$schema": "http://json-schema.org/draft-03/schema"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft3Validator,
 #

 #chema = {"$schema": "http://json-schema.org/draft-03/schema#"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft3Validator,
 #

 #ef test_draft_4(self):
 #chema = {"$schema": "http://json-schema.org/draft-04/schema"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft4Validator,
 #

 #chema = {"$schema": "http://json-schema.org/draft-04/schema#"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft4Validator,
 #

 #ef test_draft_6(self):
 #chema = {"$schema": "http://json-schema.org/draft-06/schema"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft6Validator,
 #

 #chema = {"$schema": "http://json-schema.org/draft-06/schema#"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft6Validator,
 #

 #ef test_draft_7(self):
 #chema = {"$schema": "http://json-schema.org/draft-07/schema"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft7Validator,
 #

 #chema = {"$schema": "http://json-schema.org/draft-07/schema#"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft7Validator,
 #

 #ef test_draft_201909(self):
 #chema = {"$schema": "https://json-schema.org/draft/2019-09/schema"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft201909Validator,
 #

 #chema = {"$schema": "https://json-schema.org/draft/2019-09/schema#"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft201909Validator,
 #

 #ef test_draft_202012(self):
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft202012Validator,
 #

 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema#"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidators.Draft202012Validator,
 #

 #ef test_True(self):
 #elf.assertIs(
 #alidators.validator_for(True),
 #alidators._LATEST_VERSION,
 #

 #ef test_False(self):
 #elf.assertIs(
 #alidators.validator_for(False),
 #alidators._LATEST_VERSION,
 #

 #ef test_custom_validator(self):
 #alidator = validators.create(
 #eta_schema={"id": "meta schema id"},
 #ersion="12",
 #d_of=lambda s: s.get("id", ""),
 #
 #chema = {"$schema": "meta schema id"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidator,
 #

 #ef test_custom_validator_draft6(self):
 #alidator = validators.create(
 #eta_schema={"$id": "meta schema $id"},
 #ersion="13",
 #
 #chema = {"$schema": "meta schema $id"}
 #elf.assertIs(
 #alidators.validator_for(schema),
 #alidator,
 #

 #ef test_validator_for_jsonschema_default(self):
 #elf.assertIs(validators.validator_for({}), validators._LATEST_VERSION)

 #ef test_validator_for_custom_default(self):
 #elf.assertIs(validators.validator_for({}, default=None), None)

 #ef test_warns_if_meta_schema_specified_was_not_found(self):
 #ith self.assertWarns(DeprecationWarning) as cm:
 #alidators.validator_for(schema={"$schema": "unknownSchema"})

 #elf.assertEqual(cm.filename, __file__)
 #elf.assertEqual(
 #tr(cm.warning),
 #The metaschema specified by $schema was not found. "
 #Using the latest draft to validate, but this will raise "
 #an error in the future.",
 #

 #ef test_does_not_warn_if_meta_schema_is_unspecified(self):
 #ith warnings.catch_warnings(record=True) as w:
 #arnings.simplefilter("always")
 #alidators.validator_for(schema={}, default={})
 #elf.assertFalse(w)

 #ef test_validator_for_custom_default_with_schema(self):
 #chema, default = {"$schema": "mailto:foo@example.com"}, object()
 #elf.assertIs(validators.validator_for(schema, default), default)


class TestValidate(TestCase):
 #ef assertUses(self, schema, Validator):
 #esult = []
 #ith mock.patch.object(Validator, "check_schema", result.append):
 #alidators.validate({}, schema)
 #elf.assertEqual(result, [schema])

 #ef test_draft3_validator_is_chosen(self):
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-03/schema#"},
 #alidator=validators.Draft3Validator,
 #
        # Make sure it works without the empty fragment
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-03/schema"},
 #alidator=validators.Draft3Validator,
 #

 #ef test_draft4_validator_is_chosen(self):
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-04/schema#"},
 #alidator=validators.Draft4Validator,
 #
        # Make sure it works without the empty fragment
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-04/schema"},
 #alidator=validators.Draft4Validator,
 #

 #ef test_draft6_validator_is_chosen(self):
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-06/schema#"},
 #alidator=validators.Draft6Validator,
 #
        # Make sure it works without the empty fragment
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-06/schema"},
 #alidator=validators.Draft6Validator,
 #

 #ef test_draft7_validator_is_chosen(self):
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-07/schema#"},
 #alidator=validators.Draft7Validator,
 #
        # Make sure it works without the empty fragment
 #elf.assertUses(
 #chema={"$schema": "http://json-schema.org/draft-07/schema"},
 #alidator=validators.Draft7Validator,
 #

 #ef test_draft202012_validator_is_chosen(self):
 #elf.assertUses(
 #chema={
 #$schema": "https://json-schema.org/draft/2020-12/schema#",
 #,
 #alidator=validators.Draft202012Validator,
 #
        # Make sure it works without the empty fragment
 #elf.assertUses(
 #chema={
 #$schema": "https://json-schema.org/draft/2020-12/schema",
 #,
 #alidator=validators.Draft202012Validator,
 #

 #ef test_draft202012_validator_is_the_default(self):
 #elf.assertUses(schema={}, Validator=validators.Draft202012Validator)

 #ef test_validation_error_message(self):
 #ith self.assertRaises(exceptions.ValidationError) as e:
 #alidators.validate(12, {"type": "string"})
 #elf.assertRegex(
 #tr(e.exception),
 #(?s)Failed validating '.*' in schema.*On instance",
 #

 #ef test_schema_error_message(self):
 #ith self.assertRaises(exceptions.SchemaError) as e:
 #alidators.validate(12, {"type": 12})
 #elf.assertRegex(
 #tr(e.exception),
 #(?s)Failed validating '.*' in metaschema.*On schema",
 #

 #ef test_it_uses_best_match(self):
 #chema = {
 #oneOf": [
 #"type": "number", "minimum": 20},
 #"type": "array"},
 #,
 #
 #ith self.assertRaises(exceptions.ValidationError) as e:
 #alidators.validate(12, schema)
 #elf.assertIn("12 is less than the minimum of 20", str(e.exception))


class TestThreading(TestCase):
 #""
 #hreading-related functionality tests.

 #sonschema doesn't promise thread safety, and its validation behavior
 #cross multiple threads may change at any time, but that means it isn't
 #afe to share *validators* across threads, not that anytime one has
 #ultiple threads that jsonschema won't work (it certainly is intended to).

 #hese tests ensure that this minimal level of functionality continues to
 #ork.
 #""

 #ef test_validation_across_a_second_thread(self):
 #ailed = []

 #ef validate():
 #ry:
 #alidators.validate(instance=37, schema=True)
 #xcept:  # pragma: no cover  # noqa: E722
 #ailed.append(sys.exc_info())

 #alidate()  # just verify it succeeds

 #rom threading import Thread
 #hread = Thread(target=validate)
 #hread.start()
 #hread.join()
 #elf.assertEqual((thread.is_alive(), failed), (False, []))


class TestReferencing(TestCase):
 #ef test_registry_with_retrieve(self):
 #ef retrieve(uri):
 #eturn DRAFT202012.create_resource({"type": "integer"})

 #egistry = referencing.Registry(retrieve=retrieve)
 #chema = {"$ref": "https://example.com/"}
 #alidator = validators.Draft202012Validator(schema, registry=registry)

 #elf.assertEqual(
 #validator.is_valid(12), validator.is_valid("foo")),
 #True, False),
 #

 #ef test_custom_registries_do_not_autoretrieve_remote_resources(self):
 #egistry = referencing.Registry()
 #chema = {"$ref": "https://example.com/"}
 #alidator = validators.Draft202012Validator(schema, registry=registry)

 #ith warnings.catch_warnings(record=True) as w:
 #arnings.simplefilter("always")
 #ith self.assertRaises(referencing.exceptions.Unresolvable):
 #alidator.validate(12)
 #elf.assertFalse(w)


class TestRefResolver(TestCase):

 #ase_uri = ""
 #tored_uri = "foo://stored"
 #tored_schema = {"stored": "schema"}

 #ef setUp(self):
 #elf.referrer = {}
 #elf.store = {self.stored_uri: self.stored_schema}
 #elf.resolver = validators._RefResolver(
 #elf.base_uri, self.referrer, self.store,
 #

 #ef test_it_does_not_retrieve_schema_urls_from_the_network(self):
 #ef = validators.Draft3Validator.META_SCHEMA["id"]
 #ith mock.patch.object(self.resolver, "resolve_remote") as patched:  # noqa: SIM117
 #ith self.resolver.resolving(ref) as resolved:
 #ass
 #elf.assertEqual(resolved, validators.Draft3Validator.META_SCHEMA)
 #elf.assertFalse(patched.called)

 #ef test_it_resolves_local_refs(self):
 #ef = "#/properties/foo"
 #elf.referrer["properties"] = {"foo": object()}
 #ith self.resolver.resolving(ref) as resolved:
 #elf.assertEqual(resolved, self.referrer["properties"]["foo"])

 #ef test_it_resolves_local_refs_with_id(self):
 #chema = {"id": "http://bar/schema#", "a": {"foo": "bar"}}
 #esolver = validators._RefResolver.from_schema(
 #chema,
 #d_of=lambda schema: schema.get("id", ""),
 #
 #ith resolver.resolving("#/a") as resolved:
 #elf.assertEqual(resolved, schema["a"])
 #ith resolver.resolving("http://bar/schema#/a") as resolved:
 #elf.assertEqual(resolved, schema["a"])

 #ef test_it_retrieves_stored_refs(self):
 #ith self.resolver.resolving(self.stored_uri) as resolved:
 #elf.assertIs(resolved, self.stored_schema)

 #elf.resolver.store["cached_ref"] = {"foo": 12}
 #ith self.resolver.resolving("cached_ref#/foo") as resolved:
 #elf.assertEqual(resolved, 12)

 #ef test_it_retrieves_unstored_refs_via_requests(self):
 #ef = "http://bar#baz"
 #chema = {"baz": 12}

 #f "requests" in sys.modules:  # pragma: no cover
 #elf.addCleanup(
 #ys.modules.__setitem__, "requests", sys.modules["requests"],
 #
 #ys.modules["requests"] = ReallyFakeRequests({"http://bar": schema})

 #ith self.resolver.resolving(ref) as resolved:
 #elf.assertEqual(resolved, 12)

 #ef test_it_retrieves_unstored_refs_via_urlopen(self):
 #ef = "http://bar#baz"
 #chema = {"baz": 12}

 #f "requests" in sys.modules:  # pragma: no cover
 #elf.addCleanup(
 #ys.modules.__setitem__, "requests", sys.modules["requests"],
 #
 #ys.modules["requests"] = None

 #contextmanager
 #ef fake_urlopen(url):
 #elf.assertEqual(url, "http://bar")
 #ield BytesIO(json.dumps(schema).encode("utf8"))

 #elf.addCleanup(setattr, validators, "urlopen", validators.urlopen)
 #alidators.urlopen = fake_urlopen

 #ith self.resolver.resolving(ref) as resolved:
 #ass
 #elf.assertEqual(resolved, 12)

 #ef test_it_retrieves_local_refs_via_urlopen(self):
 #ith tempfile.NamedTemporaryFile(delete=False, mode="wt") as tempf:
 #elf.addCleanup(os.remove, tempf.name)
 #son.dump({"foo": "bar"}, tempf)

 #ef = f"file://{pathname2url(tempf.name)}#foo"
 #ith self.resolver.resolving(ref) as resolved:
 #elf.assertEqual(resolved, "bar")

 #ef test_it_can_construct_a_base_uri_from_a_schema(self):
 #chema = {"id": "foo"}
 #esolver = validators._RefResolver.from_schema(
 #chema,
 #d_of=lambda schema: schema.get("id", ""),
 #
 #elf.assertEqual(resolver.base_uri, "foo")
 #elf.assertEqual(resolver.resolution_scope, "foo")
 #ith resolver.resolving("") as resolved:
 #elf.assertEqual(resolved, schema)
 #ith resolver.resolving("#") as resolved:
 #elf.assertEqual(resolved, schema)
 #ith resolver.resolving("foo") as resolved:
 #elf.assertEqual(resolved, schema)
 #ith resolver.resolving("foo#") as resolved:
 #elf.assertEqual(resolved, schema)

 #ef test_it_can_construct_a_base_uri_from_a_schema_without_id(self):
 #chema = {}
 #esolver = validators._RefResolver.from_schema(schema)
 #elf.assertEqual(resolver.base_uri, "")
 #elf.assertEqual(resolver.resolution_scope, "")
 #ith resolver.resolving("") as resolved:
 #elf.assertEqual(resolved, schema)
 #ith resolver.resolving("#") as resolved:
 #elf.assertEqual(resolved, schema)

 #ef test_custom_uri_scheme_handlers(self):
 #ef handler(url):
 #elf.assertEqual(url, ref)
 #eturn schema

 #chema = {"foo": "bar"}
 #ef = "foo://bar"
 #esolver = validators._RefResolver("", {}, handlers={"foo": handler})
 #ith resolver.resolving(ref) as resolved:
 #elf.assertEqual(resolved, schema)

 #ef test_cache_remote_on(self):
 #esponse = [object()]

 #ef handler(url):
 #ry:
 #eturn response.pop()
 #xcept IndexError:  # pragma: no cover
 #elf.fail("Response must not have been cached!")

 #ef = "foo://bar"
 #esolver = validators._RefResolver(
 #", {}, cache_remote=True, handlers={"foo": handler},
 #
 #ith resolver.resolving(ref):
 #ass
 #ith resolver.resolving(ref):
 #ass

 #ef test_cache_remote_off(self):
 #esponse = [object()]

 #ef handler(url):
 #ry:
 #eturn response.pop()
 #xcept IndexError:  # pragma: no cover
 #elf.fail("Handler called twice!")

 #ef = "foo://bar"
 #esolver = validators._RefResolver(
 #", {}, cache_remote=False, handlers={"foo": handler},
 #
 #ith resolver.resolving(ref):
 #ass

 #ef test_if_you_give_it_junk_you_get_a_resolution_error(self):
 #rror = ValueError("Oh no! What's this?")

 #ef handler(url):
 #aise error

 #ef = "foo://bar"
 #esolver = validators._RefResolver("", {}, handlers={"foo": handler})
 #ith self.assertRaises(exceptions._RefResolutionError) as err:  # noqa: SIM117
 #ith resolver.resolving(ref):
 #elf.fail("Shouldn't get this far!")  # pragma: no cover
 #elf.assertEqual(err.exception, exceptions._RefResolutionError(error))

 #ef test_helpful_error_message_on_failed_pop_scope(self):
 #esolver = validators._RefResolver("", {})
 #esolver.pop_scope()
 #ith self.assertRaises(exceptions._RefResolutionError) as exc:
 #esolver.pop_scope()
 #elf.assertIn("Failed to pop the scope", str(exc.exception))

 #ef test_pointer_within_schema_with_different_id(self):
 #""
 #ee #1085.
 #""
 #chema = validators.Draft7Validator.META_SCHEMA
 #ne = validators._RefResolver("", schema)
 #alidator = validators.Draft7Validator(schema, resolver=one)
 #elf.assertFalse(validator.is_valid({"maxLength": "foo"}))

 #nother = {
 #allOf": [{"$ref": validators.Draft7Validator.META_SCHEMA["$id"]}],
 #
 #wo = validators._RefResolver("", another)
 #alidator = validators.Draft7Validator(another, resolver=two)
 #elf.assertFalse(validator.is_valid({"maxLength": "foo"}))

 #ef test_newly_created_validator_with_ref_resolver(self):
 #""
 #ee https://github.com/python-jsonschema/jsonschema/issues/1061#issuecomment-1624266555.
 #""

 #ef handle(uri):
 #elf.assertEqual(uri, "http://example.com/foo")
 #eturn {"type": "integer"}

 #esolver = validators._RefResolver("", {}, handlers={"http": handle})
 #alidator = validators.create(
 #eta_schema={},
 #alidators=validators.Draft4Validator.VALIDATORS,
 #
 #chema = {"$id": "http://example.com/bar", "$ref": "foo"}
 #alidator = Validator(schema, resolver=resolver)
 #elf.assertEqual(
 #validator.is_valid({}), validator.is_valid(37)),
 #False, True),
 #

 #ef test_refresolver_with_pointer_in_schema_with_no_id(self):
 #""
 #ee https://github.com/python-jsonschema/jsonschema/issues/1124#issuecomment-1632574249.
 #""

 #chema = {
 #properties": {"x": {"$ref": "#/definitions/x"}},
 #definitions": {"x": {"type": "integer"}},
 #

 #alidator = validators.Draft202012Validator(
 #chema,
 #esolver=validators._RefResolver("", schema),
 #
 #elf.assertEqual(
 #validator.is_valid({"x": "y"}), validator.is_valid({"x": 37})),
 #False, True),
 #



def sorted_errors(errors):
 #ef key(error):
 #eturn (
 #str(e) for e in error.path],
 #str(e) for e in error.schema_path],
 #
 #eturn sorted(errors, key=key)


@define
class ReallyFakeRequests:

 #responses: dict[str, Any]

 #ef get(self, url):
 #esponse = self._responses.get(url)
 #f url is None:  # pragma: no cover
 #aise ValueError("Unknown URL: " + repr(url))
 #eturn _ReallyFakeJSONResponse(json.dumps(response))


@define
class _ReallyFakeJSONResponse:

 #response: str

 #ef json(self):
 #eturn json.loads(self._response)
