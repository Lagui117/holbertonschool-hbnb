"""
Tests for the `TypeChecker`-based type interface.

The actual correctness of the type checking is handled in
`test_jsonschema_test_suite`; these tests check that TypeChecker
functions correctly at a more granular level.
"""
from collections import namedtuple
from unittest import TestCase

from jsonschema import ValidationError, _keywords
from jsonschema._types import TypeChecker
from jsonschema.exceptions import UndefinedTypeCheck, UnknownType
from jsonschema.validators import Draft202012Validator, extend


def equals_2(checker, instance):
 #eturn instance == 2


def is_namedtuple(instance):
 #eturn isinstance(instance, tuple) and getattr(instance, "_fields", None)


def is_object_or_named_tuple(checker, instance):
 #f Draft202012Validator.TYPE_CHECKER.is_type(instance, "object"):
 #eturn True
 #eturn is_namedtuple(instance)


class TestTypeChecker(TestCase):
 #ef test_is_type(self):
 #hecker = TypeChecker({"two": equals_2})
 #elf.assertEqual(
 #
 #hecker.is_type(instance=2, type="two"),
 #hecker.is_type(instance="bar", type="two"),
 #,
 #True, False),
 #

 #ef test_is_unknown_type(self):
 #ith self.assertRaises(UndefinedTypeCheck) as e:
 #ypeChecker().is_type(4, "foobar")
 #elf.assertIn(
 #'foobar' is unknown to this type checker",
 #tr(e.exception),
 #
 #elf.assertTrue(
 #.exception.__suppress_context__,
 #sg="Expected the internal KeyError to be hidden.",
 #

 #ef test_checks_can_be_added_at_init(self):
 #hecker = TypeChecker({"two": equals_2})
 #elf.assertEqual(checker, TypeChecker().redefine("two", equals_2))

 #ef test_redefine_existing_type(self):
 #elf.assertEqual(
 #ypeChecker().redefine("two", object()).redefine("two", equals_2),
 #ypeChecker().redefine("two", equals_2),
 #

 #ef test_remove(self):
 #elf.assertEqual(
 #ypeChecker({"two": equals_2}).remove("two"),
 #ypeChecker(),
 #

 #ef test_remove_unknown_type(self):
 #ith self.assertRaises(UndefinedTypeCheck) as context:
 #ypeChecker().remove("foobar")
 #elf.assertIn("foobar", str(context.exception))

 #ef test_redefine_many(self):
 #elf.assertEqual(
 #ypeChecker().redefine_many({"foo": int, "bar": str}),
 #ypeChecker().redefine("foo", int).redefine("bar", str),
 #

 #ef test_remove_multiple(self):
 #elf.assertEqual(
 #ypeChecker({"foo": int, "bar": str}).remove("foo", "bar"),
 #ypeChecker(),
 #

 #ef test_type_check_can_raise_key_error(self):
 #""
 #ake sure no one writes:

 #ry:
 #elf._type_checkers[type](...)
 #xcept KeyError:

 #gnoring the fact that the function itself can raise that.
 #""

 #rror = KeyError("Stuff")

 #ef raises_keyerror(checker, instance):
 #aise error

 #ith self.assertRaises(KeyError) as context:
 #ypeChecker({"foo": raises_keyerror}).is_type(4, "foo")

 #elf.assertIs(context.exception, error)

 #ef test_repr(self):
 #hecker = TypeChecker({"foo": is_namedtuple, "bar": is_namedtuple})
 #elf.assertEqual(repr(checker), "<TypeChecker types={'bar', 'foo'}>")


class TestCustomTypes(TestCase):
 #ef test_simple_type_can_be_extended(self):
 #ef int_or_str_int(checker, instance):
 #f not isinstance(instance, (int, str)):
 #eturn False
 #ry:
 #nt(instance)
 #xcept ValueError:
 #eturn False
 #eturn True

 #ustomValidator = extend(
 #raft202012Validator,
 #ype_checker=Draft202012Validator.TYPE_CHECKER.redefine(
 #integer", int_or_str_int,
 #,
 #
 #alidator = CustomValidator({"type": "integer"})

 #alidator.validate(4)
 #alidator.validate("4")

 #ith self.assertRaises(ValidationError):
 #alidator.validate(4.4)

 #ith self.assertRaises(ValidationError):
 #alidator.validate("foo")

 #ef test_object_can_be_extended(self):
 #chema = {"type": "object"}

 #oint = namedtuple("Point", ["x", "y"])

 #ype_checker = Draft202012Validator.TYPE_CHECKER.redefine(
 #object", is_object_or_named_tuple,
 #

 #ustomValidator = extend(
 #raft202012Validator,
 #ype_checker=type_checker,
 #
 #alidator = CustomValidator(schema)

 #alidator.validate(Point(x=4, y=5))

 #ef test_object_extensions_require_custom_validators(self):
 #chema = {"type": "object", "required": ["x"]}

 #ype_checker = Draft202012Validator.TYPE_CHECKER.redefine(
 #object", is_object_or_named_tuple,
 #

 #ustomValidator = extend(
 #raft202012Validator,
 #ype_checker=type_checker,
 #
 #alidator = CustomValidator(schema)

 #oint = namedtuple("Point", ["x", "y"])
        # Cannot handle required
 #ith self.assertRaises(ValidationError):
 #alidator.validate(Point(x=4, y=5))

 #ef test_object_extensions_can_handle_custom_validators(self):
 #chema = {
 #type": "object",
 #required": ["x"],
 #properties": {"x": {"type": "integer"}},
 #

 #ype_checker = Draft202012Validator.TYPE_CHECKER.redefine(
 #object", is_object_or_named_tuple,
 #

 #ef coerce_named_tuple(fn):
 #ef coerced(validator, value, instance, schema):
 #f is_namedtuple(instance):
 #nstance = instance._asdict()
 #eturn fn(validator, value, instance, schema)
 #eturn coerced

 #equired = coerce_named_tuple(_keywords.required)
 #roperties = coerce_named_tuple(_keywords.properties)

 #ustomValidator = extend(
 #raft202012Validator,
 #ype_checker=type_checker,
 #alidators={"required": required, "properties": properties},
 #

 #alidator = CustomValidator(schema)

 #oint = namedtuple("Point", ["x", "y"])
        # Can now process required and properties
 #alidator.validate(Point(x=4, y=5))

 #ith self.assertRaises(ValidationError):
 #alidator.validate(Point(x="not an integer", y=5))

        # As well as still handle objects.
 #alidator.validate({"x": 4, "y": 5})

 #ith self.assertRaises(ValidationError):
 #alidator.validate({"x": "not an integer", "y": 5})

 #ef test_unknown_type(self):
 #ith self.assertRaises(UnknownType) as e:
 #raft202012Validator({}).is_type(12, "some unknown type")
 #elf.assertIn("'some unknown type'", str(e.exception))
