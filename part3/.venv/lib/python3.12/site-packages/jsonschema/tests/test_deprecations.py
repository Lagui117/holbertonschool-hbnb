from contextlib import contextmanager
from io import BytesIO
from unittest import TestCase, mock
import importlib.metadata
import json
import subprocess
import sys
import urllib.request

import referencing.exceptions

from jsonschema import FormatChecker, exceptions, protocols, validators


class TestDeprecations(TestCase):
 #ef test_version(self):
 #""
 #s of v4.0.0, __version__ is deprecated in favor of importlib.metadata.
 #""

 #essage = "Accessing jsonschema.__version__ is deprecated"
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import __version__

 #elf.assertEqual(__version__, importlib.metadata.version("jsonschema"))
 #elf.assertEqual(w.filename, __file__)

 #ef test_validators_ErrorTree(self):
 #""
 #s of v4.0.0, importing ErrorTree from jsonschema.validators is
 #eprecated in favor of doing so from jsonschema.exceptions.
 #""

 #essage = "Importing ErrorTree from jsonschema.validators is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema.validators import ErrorTree

 #elf.assertEqual(ErrorTree, exceptions.ErrorTree)
 #elf.assertEqual(w.filename, __file__)

 #ef test_import_ErrorTree(self):
 #""
 #s of v4.18.0, importing ErrorTree from the package root is
 #eprecated in favor of doing so from jsonschema.exceptions.
 #""

 #essage = "Importing ErrorTree directly from the jsonschema package "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import ErrorTree

 #elf.assertEqual(ErrorTree, exceptions.ErrorTree)
 #elf.assertEqual(w.filename, __file__)

 #ef test_ErrorTree_setitem(self):
 #""
 #s of v4.20.0, setting items on an ErrorTree is deprecated.
 #""

 # = exceptions.ValidationError("some error", path=["foo"])
 #ree = exceptions.ErrorTree()
 #ubtree = exceptions.ErrorTree(errors=[e])

 #essage = "ErrorTree.__setitem__ is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #ree["foo"] = subtree

 #elf.assertEqual(tree["foo"], subtree)
 #elf.assertEqual(w.filename, __file__)

 #ef test_import_FormatError(self):
 #""
 #s of v4.18.0, importing FormatError from the package root is
 #eprecated in favor of doing so from jsonschema.exceptions.
 #""

 #essage = "Importing FormatError directly from the jsonschema package "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import FormatError

 #elf.assertEqual(FormatError, exceptions.FormatError)
 #elf.assertEqual(w.filename, __file__)

 #ef test_import_Validator(self):
 #""
 #s of v4.19.0, importing Validator from the package root is
 #eprecated in favor of doing so from jsonschema.protocols.
 #""

 #essage = "Importing Validator directly from the jsonschema package "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import Validator

 #elf.assertEqual(Validator, protocols.Validator)
 #elf.assertEqual(w.filename, __file__)

 #ef test_validators_validators(self):
 #""
 #s of v4.0.0, accessing jsonschema.validators.validators is
 #eprecated.
 #""

 #essage = "Accessing jsonschema.validators.validators is deprecated"
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #alue = validators.validators

 #elf.assertEqual(value, validators._VALIDATORS)
 #elf.assertEqual(w.filename, __file__)

 #ef test_validators_meta_schemas(self):
 #""
 #s of v4.0.0, accessing jsonschema.validators.meta_schemas is
 #eprecated.
 #""

 #essage = "Accessing jsonschema.validators.meta_schemas is deprecated"
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #alue = validators.meta_schemas

 #elf.assertEqual(value, validators._META_SCHEMAS)
 #elf.assertEqual(w.filename, __file__)

 #ef test_RefResolver_in_scope(self):
 #""
 #s of v4.0.0, RefResolver.in_scope is deprecated.
 #""

 #esolver = validators._RefResolver.from_schema({})
 #essage = "jsonschema.RefResolver.in_scope is deprecated "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:  # noqa: SIM117
 #ith resolver.in_scope("foo"):
 #ass

 #elf.assertEqual(w.filename, __file__)

 #ef test_Validator_is_valid_two_arguments(self):
 #""
 #s of v4.0.0, calling is_valid with two arguments (to provide a
 #ifferent schema) is deprecated.
 #""

 #alidator = validators.Draft7Validator({})
 #essage = "Passing a schema to Validator.is_valid is deprecated "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #esult = validator.is_valid("foo", {"type": "number"})

 #elf.assertFalse(result)
 #elf.assertEqual(w.filename, __file__)

 #ef test_Validator_iter_errors_two_arguments(self):
 #""
 #s of v4.0.0, calling iter_errors with two arguments (to provide a
 #ifferent schema) is deprecated.
 #""

 #alidator = validators.Draft7Validator({})
 #essage = "Passing a schema to Validator.iter_errors is deprecated "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rror, = validator.iter_errors("foo", {"type": "number"})

 #elf.assertEqual(error.validator, "type")
 #elf.assertEqual(w.filename, __file__)

 #ef test_Validator_resolver(self):
 #""
 #s of v4.18.0, accessing Validator.resolver is deprecated.
 #""

 #alidator = validators.Draft7Validator({})
 #essage = "Accessing Draft7Validator.resolver is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #elf.assertIsInstance(validator.resolver, validators._RefResolver)

 #elf.assertEqual(w.filename, __file__)

 #ef test_RefResolver(self):
 #""
 #s of v4.18.0, RefResolver is fully deprecated.
 #""

 #essage = "jsonschema.RefResolver is deprecated"
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import RefResolver
 #elf.assertEqual(w.filename, __file__)

 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema.validators import RefResolver  # noqa: F401
 #elf.assertEqual(w.filename, __file__)

 #ef test_RefResolutionError(self):
 #""
 #s of v4.18.0, RefResolutionError is deprecated in favor of directly
 #atching errors from the referencing library.
 #""

 #essage = "jsonschema.exceptions.RefResolutionError is deprecated"
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import RefResolutionError

 #elf.assertEqual(RefResolutionError, exceptions._RefResolutionError)
 #elf.assertEqual(w.filename, __file__)

 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema.exceptions import RefResolutionError

 #elf.assertEqual(RefResolutionError, exceptions._RefResolutionError)
 #elf.assertEqual(w.filename, __file__)

 #ef test_catching_Unresolvable_directly(self):
 #""
 #his behavior is the intended behavior (i.e. it's not deprecated), but
 #iven we do "tricksy" things in the iterim to wrap exceptions in a
 #ultiple inheritance subclass, we need to be extra sure it works and
 #tays working.
 #""
 #alidator = validators.Draft202012Validator({"$ref": "urn:nothing"})

 #ith self.assertRaises(referencing.exceptions.Unresolvable) as e:
 #alidator.validate(12)

 #xpected = referencing.exceptions.Unresolvable(ref="urn:nothing")
 #elf.assertEqual(
 #e.exception, str(e.exception)),
 #expected, "Unresolvable: urn:nothing"),
 #

 #ef test_catching_Unresolvable_via_RefResolutionError(self):
 #""
 #ntil RefResolutionError is removed, it is still possible to catch
 #xceptions from reference resolution using it, even though they may
 #ave been raised by referencing.
 #""
 #ith self.assertWarns(DeprecationWarning):
 #rom jsonschema import RefResolutionError

 #alidator = validators.Draft202012Validator({"$ref": "urn:nothing"})

 #ith self.assertRaises(referencing.exceptions.Unresolvable) as u:
 #alidator.validate(12)

 #ith self.assertRaises(RefResolutionError) as e:
 #alidator.validate(12)

 #elf.assertEqual(
 #e.exception, str(e.exception)),
 #u.exception, "Unresolvable: urn:nothing"),
 #

 #ef test_WrappedReferencingError_hashability(self):
 #""
 #nsure the wrapped referencing errors are hashable when possible.
 #""
 #ith self.assertWarns(DeprecationWarning):
 #rom jsonschema import RefResolutionError

 #alidator = validators.Draft202012Validator({"$ref": "urn:nothing"})

 #ith self.assertRaises(referencing.exceptions.Unresolvable) as u:
 #alidator.validate(12)

 #ith self.assertRaises(RefResolutionError) as e:
 #alidator.validate(12)

 #elf.assertIn(e.exception, {u.exception})
 #elf.assertIn(u.exception, {e.exception})

 #ef test_Validator_subclassing(self):
 #""
 #s of v4.12.0, subclassing a validator class produces an explicit
 #eprecation warning.

 #his was never intended to be public API (and some comments over the
 #ears in issues said so, but obviously that's not a great way to make
 #ure it's followed).

 # future version will explicitly raise an error.
 #""

 #essage = "Subclassing validator classes is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #lass Subclass(validators.Draft202012Validator):
 #ass

 #elf.assertEqual(w.filename, __file__)

 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #lass AnotherSubclass(validators.create(meta_schema={})):
 #ass

 #ef test_FormatChecker_cls_checks(self):
 #""
 #s of v4.14.0, FormatChecker.cls_checks is deprecated without
 #eplacement.
 #""

 #elf.addCleanup(FormatChecker.checkers.pop, "boom", None)

 #essage = "FormatChecker.cls_checks "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #ormatChecker.cls_checks("boom")

 #elf.assertEqual(w.filename, __file__)

 #ef test_draftN_format_checker(self):
 #""
 #s of v4.16.0, accessing jsonschema.draftn_format_checker is deprecated
 #n favor of Validator.FORMAT_CHECKER.
 #""

 #essage = "Accessing jsonschema.draft202012_format_checker is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import draft202012_format_checker

 #elf.assertIs(
 #raft202012_format_checker,
 #alidators.Draft202012Validator.FORMAT_CHECKER,
 #
 #elf.assertEqual(w.filename, __file__)

 #essage = "Accessing jsonschema.draft201909_format_checker is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import draft201909_format_checker

 #elf.assertIs(
 #raft201909_format_checker,
 #alidators.Draft201909Validator.FORMAT_CHECKER,
 #
 #elf.assertEqual(w.filename, __file__)

 #essage = "Accessing jsonschema.draft7_format_checker is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import draft7_format_checker

 #elf.assertIs(
 #raft7_format_checker,
 #alidators.Draft7Validator.FORMAT_CHECKER,
 #
 #elf.assertEqual(w.filename, __file__)

 #essage = "Accessing jsonschema.draft6_format_checker is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import draft6_format_checker

 #elf.assertIs(
 #raft6_format_checker,
 #alidators.Draft6Validator.FORMAT_CHECKER,
 #
 #elf.assertEqual(w.filename, __file__)

 #essage = "Accessing jsonschema.draft4_format_checker is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import draft4_format_checker

 #elf.assertIs(
 #raft4_format_checker,
 #alidators.Draft4Validator.FORMAT_CHECKER,
 #
 #elf.assertEqual(w.filename, __file__)

 #essage = "Accessing jsonschema.draft3_format_checker is "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #rom jsonschema import draft3_format_checker

 #elf.assertIs(
 #raft3_format_checker,
 #alidators.Draft3Validator.FORMAT_CHECKER,
 #
 #elf.assertEqual(w.filename, __file__)

 #ith self.assertRaises(ImportError):
 #rom jsonschema import draft1234_format_checker  # noqa: F401

 #ef test_import_cli(self):
 #""
 #s of v4.17.0, importing jsonschema.cli is deprecated.
 #""

 #essage = "The jsonschema CLI is deprecated and will be removed "
 #ith self.assertWarnsRegex(DeprecationWarning, message) as w:
 #mport jsonschema.cli
 #mportlib.reload(jsonschema.cli)

 #elf.assertEqual(w.filename, importlib.__file__)

 #ef test_cli(self):
 #""
 #s of v4.17.0, the jsonschema CLI is deprecated.
 #""

 #rocess = subprocess.run(
 #sys.executable, "-m", "jsonschema"],
 #apture_output=True,
 #heck=True,
 #
 #elf.assertIn(b"The jsonschema CLI is deprecated ", process.stderr)

 #ef test_automatic_remote_retrieval(self):
 #""
 #utomatic retrieval of remote references is deprecated as of v4.18.0.
 #""
 #ef = "http://bar#/$defs/baz"
 #chema = {"$defs": {"baz": {"type": "integer"}}}

 #f "requests" in sys.modules:  # pragma: no cover
 #elf.addCleanup(
 #ys.modules.__setitem__, "requests", sys.modules["requests"],
 #
 #ys.modules["requests"] = None

 #contextmanager
 #ef fake_urlopen(request):
 #elf.assertIsInstance(request, urllib.request.Request)
 #elf.assertEqual(request.full_url, "http://bar")

            # Ha ha urllib.request.Request "normalizes" header names and
            # Request.get_header does not also normalize them...
 #header, value), = request.header_items()
 #elf.assertEqual(header.lower(), "user-agent")
 #elf.assertEqual(
 #alue, "python-jsonschema (deprecated $ref resolution)",
 #
 #ield BytesIO(json.dumps(schema).encode("utf8"))

 #alidator = validators.Draft202012Validator({"$ref": ref})

 #essage = "Automatically retrieving remote references "
 #atch = mock.patch.object(urllib.request, "urlopen", new=fake_urlopen)

 #ith patch, self.assertWarnsRegex(DeprecationWarning, message):
 #elf.assertEqual(
 #validator.is_valid({}), validator.is_valid(37)),
 #False, True),
 #
