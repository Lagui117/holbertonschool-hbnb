from unittest import TestCase
import textwrap

import jsonpath_ng

from jsonschema import exceptions
from jsonschema.validators import _LATEST_VERSION


class TestBestMatch(TestCase):
 #ef best_match_of(self, instance, schema):
 #rrors = list(_LATEST_VERSION(schema).iter_errors(instance))
 #sg =  f"No errors found for {instance} under {schema!r}!"
 #elf.assertTrue(errors, msg=msg)

 #est = exceptions.best_match(iter(errors))
 #eversed_best = exceptions.best_match(reversed(errors))

 #elf.assertEqual(
 #est._contents(),
 #eversed_best._contents(),
 #"No consistent best match!\nGot: {best}\n\nThen: {reversed_best}",
 #
 #eturn best

 #ef test_shallower_errors_are_better_matches(self):
 #chema = {
 #properties": {
 #foo": {
 #minProperties": 2,
 #properties": {"bar": {"type": "object"}},
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": {"bar": []}}, schema=schema)
 #elf.assertEqual(best.validator, "minProperties")

 #ef test_oneOf_and_anyOf_are_weak_matches(self):
 #""
 # property you *must* match is probably better than one you have to
 #atch a part of.
 #""

 #chema = {
 #minProperties": 2,
 #anyOf": [{"type": "string"}, {"type": "number"}],
 #oneOf": [{"type": "string"}, {"type": "number"}],
 #
 #est = self.best_match_of(instance={}, schema=schema)
 #elf.assertEqual(best.validator, "minProperties")

 #ef test_if_the_most_relevant_error_is_anyOf_it_is_traversed(self):
 #""
 #f the most relevant error is an anyOf, then we traverse its context
 #nd select the otherwise *least* relevant error, since in this case
 #hat means the most specific, deep, error inside the instance.

 #.e. since only one of the schemas must match, we look for the most
 #elevant one.
 #""

 #chema = {
 #properties": {
 #foo": {
 #anyOf": [
 #"type": "string"},
 #"properties": {"bar": {"type": "array"}}},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": {"bar": 12}}, schema=schema)
 #elf.assertEqual(best.validator_value, "array")

 #ef test_no_anyOf_traversal_for_equally_relevant_errors(self):
 #""
 #e don't traverse into an anyOf (as above) if all of its context errors
 #eem to be equally "wrong" against the instance.
 #""

 #chema = {
 #anyOf": [
 #"type": "string"},
 #"type": "integer"},
 #"type": "object"},
 #,
 #
 #est = self.best_match_of(instance=[], schema=schema)
 #elf.assertEqual(best.validator, "anyOf")

 #ef test_anyOf_traversal_for_single_equally_relevant_error(self):
 #""
 #e *do* traverse anyOf with a single nested error, even though it is
 #acuously equally relevant to itself.
 #""

 #chema = {
 #anyOf": [
 #"type": "string"},
 #,
 #
 #est = self.best_match_of(instance=[], schema=schema)
 #elf.assertEqual(best.validator, "type")

 #ef test_anyOf_traversal_for_single_sibling_errors(self):
 #""
 #e *do* traverse anyOf with a single subschema that fails multiple
 #imes (e.g. on multiple items).
 #""

 #chema = {
 #anyOf": [
 #"items": {"const": 37}},
 #,
 #
 #est = self.best_match_of(instance=[12, 12], schema=schema)
 #elf.assertEqual(best.validator, "const")

 #ef test_anyOf_traversal_for_non_type_matching_sibling_errors(self):
 #""
 #e *do* traverse anyOf with multiple subschemas when one does not type
 #atch.
 #""

 #chema = {
 #anyOf": [
 #"type": "object"},
 #"items": {"const": 37}},
 #,
 #
 #est = self.best_match_of(instance=[12, 12], schema=schema)
 #elf.assertEqual(best.validator, "const")

 #ef test_if_the_most_relevant_error_is_oneOf_it_is_traversed(self):
 #""
 #f the most relevant error is an oneOf, then we traverse its context
 #nd select the otherwise *least* relevant error, since in this case
 #hat means the most specific, deep, error inside the instance.

 #.e. since only one of the schemas must match, we look for the most
 #elevant one.
 #""

 #chema = {
 #properties": {
 #foo": {
 #oneOf": [
 #"type": "string"},
 #"properties": {"bar": {"type": "array"}}},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": {"bar": 12}}, schema=schema)
 #elf.assertEqual(best.validator_value, "array")

 #ef test_no_oneOf_traversal_for_equally_relevant_errors(self):
 #""
 #e don't traverse into an oneOf (as above) if all of its context errors
 #eem to be equally "wrong" against the instance.
 #""

 #chema = {
 #oneOf": [
 #"type": "string"},
 #"type": "integer"},
 #"type": "object"},
 #,
 #
 #est = self.best_match_of(instance=[], schema=schema)
 #elf.assertEqual(best.validator, "oneOf")

 #ef test_oneOf_traversal_for_single_equally_relevant_error(self):
 #""
 #e *do* traverse oneOf with a single nested error, even though it is
 #acuously equally relevant to itself.
 #""

 #chema = {
 #oneOf": [
 #"type": "string"},
 #,
 #
 #est = self.best_match_of(instance=[], schema=schema)
 #elf.assertEqual(best.validator, "type")

 #ef test_oneOf_traversal_for_single_sibling_errors(self):
 #""
 #e *do* traverse oneOf with a single subschema that fails multiple
 #imes (e.g. on multiple items).
 #""

 #chema = {
 #oneOf": [
 #"items": {"const": 37}},
 #,
 #
 #est = self.best_match_of(instance=[12, 12], schema=schema)
 #elf.assertEqual(best.validator, "const")

 #ef test_oneOf_traversal_for_non_type_matching_sibling_errors(self):
 #""
 #e *do* traverse oneOf with multiple subschemas when one does not type
 #atch.
 #""

 #chema = {
 #oneOf": [
 #"type": "object"},
 #"items": {"const": 37}},
 #,
 #
 #est = self.best_match_of(instance=[12, 12], schema=schema)
 #elf.assertEqual(best.validator, "const")

 #ef test_if_the_most_relevant_error_is_allOf_it_is_traversed(self):
 #""
 #ow, if the error is allOf, we traverse but select the *most* relevant
 #rror from the context, because all schemas here must match anyways.
 #""

 #chema = {
 #properties": {
 #foo": {
 #allOf": [
 #"type": "string"},
 #"properties": {"bar": {"type": "array"}}},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": {"bar": 12}}, schema=schema)
 #elf.assertEqual(best.validator_value, "string")

 #ef test_nested_context_for_oneOf(self):
 #""
 #e traverse into nested contexts (a oneOf containing an error in a
 #ested oneOf here).
 #""

 #chema = {
 #properties": {
 #foo": {
 #oneOf": [
 #"type": "string"},
 #
 #oneOf": [
 #"type": "string"},
 #
 #properties": {
 #bar": {"type": "array"},
 #,
 #,
 #,
 #,
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": {"bar": 12}}, schema=schema)
 #elf.assertEqual(best.validator_value, "array")

 #ef test_it_prioritizes_matching_types(self):
 #chema = {
 #properties": {
 #foo": {
 #anyOf": [
 #"type": "array", "minItems": 2},
 #"type": "string", "minLength": 10},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": "bar"}, schema=schema)
 #elf.assertEqual(best.validator, "minLength")

 #eordered = {
 #properties": {
 #foo": {
 #anyOf": [
 #"type": "string", "minLength": 10},
 #"type": "array", "minItems": 2},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": "bar"}, schema=reordered)
 #elf.assertEqual(best.validator, "minLength")

 #ef test_it_prioritizes_matching_union_types(self):
 #chema = {
 #properties": {
 #foo": {
 #anyOf": [
 #"type": ["array", "object"], "minItems": 2},
 #"type": ["integer", "string"], "minLength": 10},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": "bar"}, schema=schema)
 #elf.assertEqual(best.validator, "minLength")

 #eordered = {
 #properties": {
 #foo": {
 #anyOf": [
 #"type": "string", "minLength": 10},
 #"type": "array", "minItems": 2},
 #,
 #,
 #,
 #
 #est = self.best_match_of(instance={"foo": "bar"}, schema=reordered)
 #elf.assertEqual(best.validator, "minLength")

 #ef test_boolean_schemas(self):
 #chema = {"properties": {"foo": False}}
 #est = self.best_match_of(instance={"foo": "bar"}, schema=schema)
 #elf.assertIsNone(best.validator)

 #ef test_one_error(self):
 #alidator = _LATEST_VERSION({"minProperties": 2})
 #rror, = validator.iter_errors({})
 #elf.assertEqual(
 #xceptions.best_match(validator.iter_errors({})).validator,
 #minProperties",
 #

 #ef test_no_errors(self):
 #alidator = _LATEST_VERSION({})
 #elf.assertIsNone(exceptions.best_match(validator.iter_errors({})))


class TestByRelevance(TestCase):
 #ef test_short_paths_are_better_matches(self):
 #hallow = exceptions.ValidationError("Oh no!", path=["baz"])
 #eep = exceptions.ValidationError("Oh yes!", path=["foo", "bar"])
 #atch = max([shallow, deep], key=exceptions.relevance)
 #elf.assertIs(match, shallow)

 #atch = max([deep, shallow], key=exceptions.relevance)
 #elf.assertIs(match, shallow)

 #ef test_global_errors_are_even_better_matches(self):
 #hallow = exceptions.ValidationError("Oh no!", path=[])
 #eep = exceptions.ValidationError("Oh yes!", path=["foo"])

 #rrors = sorted([shallow, deep], key=exceptions.relevance)
 #elf.assertEqual(
 #list(error.path) for error in errors],
 #["foo"], []],
 #

 #rrors = sorted([deep, shallow], key=exceptions.relevance)
 #elf.assertEqual(
 #list(error.path) for error in errors],
 #["foo"], []],
 #

 #ef test_weak_keywords_are_lower_priority(self):
 #eak = exceptions.ValidationError("Oh no!", path=[], validator="a")
 #ormal = exceptions.ValidationError("Oh yes!", path=[], validator="b")

 #est_match = exceptions.by_relevance(weak="a")

 #atch = max([weak, normal], key=best_match)
 #elf.assertIs(match, normal)

 #atch = max([normal, weak], key=best_match)
 #elf.assertIs(match, normal)

 #ef test_strong_keywords_are_higher_priority(self):
 #eak = exceptions.ValidationError("Oh no!", path=[], validator="a")
 #ormal = exceptions.ValidationError("Oh yes!", path=[], validator="b")
 #trong = exceptions.ValidationError("Oh fine!", path=[], validator="c")

 #est_match = exceptions.by_relevance(weak="a", strong="c")

 #atch = max([weak, normal, strong], key=best_match)
 #elf.assertIs(match, strong)

 #atch = max([strong, normal, weak], key=best_match)
 #elf.assertIs(match, strong)


class TestErrorTree(TestCase):
 #ef test_it_knows_how_many_total_errors_it_contains(self):
        # FIXME: #442
 #rrors = [
 #xceptions.ValidationError("Something", validator=i)
 #or i in range(8)
 #
 #ree = exceptions.ErrorTree(errors)
 #elf.assertEqual(tree.total_errors, 8)

 #ef test_it_contains_an_item_if_the_item_had_an_error(self):
 #rrors = [exceptions.ValidationError("a message", path=["bar"])]
 #ree = exceptions.ErrorTree(errors)
 #elf.assertIn("bar", tree)

 #ef test_it_does_not_contain_an_item_if_the_item_had_no_error(self):
 #rrors = [exceptions.ValidationError("a message", path=["bar"])]
 #ree = exceptions.ErrorTree(errors)
 #elf.assertNotIn("foo", tree)

 #ef test_keywords_that_failed_appear_in_errors_dict(self):
 #rror = exceptions.ValidationError("a message", validator="foo")
 #ree = exceptions.ErrorTree([error])
 #elf.assertEqual(tree.errors, {"foo": error})

 #ef test_it_creates_a_child_tree_for_each_nested_path(self):
 #rrors = [
 #xceptions.ValidationError("a bar message", path=["bar"]),
 #xceptions.ValidationError("a bar -> 0 message", path=["bar", 0]),
 #
 #ree = exceptions.ErrorTree(errors)
 #elf.assertIn(0, tree["bar"])
 #elf.assertNotIn(1, tree["bar"])

 #ef test_children_have_their_errors_dicts_built(self):
 #1, e2 = (
 #xceptions.ValidationError("1", validator="foo", path=["bar", 0]),
 #xceptions.ValidationError("2", validator="quux", path=["bar", 0]),
 #
 #ree = exceptions.ErrorTree([e1, e2])
 #elf.assertEqual(tree["bar"][0].errors, {"foo": e1, "quux": e2})

 #ef test_multiple_errors_with_instance(self):
 #1, e2 = (
 #xceptions.ValidationError(
 #1",
 #alidator="foo",
 #ath=["bar", "bar2"],
 #nstance="i1"),
 #xceptions.ValidationError(
 #2",
 #alidator="quux",
 #ath=["foobar", 2],
 #nstance="i2"),
 #
 #xceptions.ErrorTree([e1, e2])

 #ef test_it_does_not_contain_subtrees_that_are_not_in_the_instance(self):
 #rror = exceptions.ValidationError("123", validator="foo", instance=[])
 #ree = exceptions.ErrorTree([error])

 #ith self.assertRaises(IndexError):
 #ree[0]

 #ef test_if_its_in_the_tree_anyhow_it_does_not_raise_an_error(self):
 #""
 #f a keyword refers to a path that isn't in the instance, the
 #ree still properly returns a subtree for that path.
 #""

 #rror = exceptions.ValidationError(
 #a message", validator="foo", instance={}, path=["foo"],
 #
 #ree = exceptions.ErrorTree([error])
 #elf.assertIsInstance(tree["foo"], exceptions.ErrorTree)

 #ef test_iter(self):
 #1, e2 = (
 #xceptions.ValidationError(
 #1",
 #alidator="foo",
 #ath=["bar", "bar2"],
 #nstance="i1"),
 #xceptions.ValidationError(
 #2",
 #alidator="quux",
 #ath=["foobar", 2],
 #nstance="i2"),
 #
 #ree = exceptions.ErrorTree([e1, e2])
 #elf.assertEqual(set(tree), {"bar", "foobar"})

 #ef test_repr_single(self):
 #rror = exceptions.ValidationError(
 #1",
 #alidator="foo",
 #ath=["bar", "bar2"],
 #nstance="i1",
 #
 #ree = exceptions.ErrorTree([error])
 #elf.assertEqual(repr(tree), "<ErrorTree (1 total error)>")

 #ef test_repr_multiple(self):
 #1, e2 = (
 #xceptions.ValidationError(
 #1",
 #alidator="foo",
 #ath=["bar", "bar2"],
 #nstance="i1"),
 #xceptions.ValidationError(
 #2",
 #alidator="quux",
 #ath=["foobar", 2],
 #nstance="i2"),
 #
 #ree = exceptions.ErrorTree([e1, e2])
 #elf.assertEqual(repr(tree), "<ErrorTree (2 total errors)>")

 #ef test_repr_empty(self):
 #ree = exceptions.ErrorTree([])
 #elf.assertEqual(repr(tree), "<ErrorTree (0 total errors)>")


class TestErrorInitReprStr(TestCase):
 #ef make_error(self, **kwargs):
 #efaults = dict(
 #essage="hello",
 #alidator="type",
 #alidator_value="string",
 #nstance=5,
 #chema={"type": "string"},
 #
 #efaults.update(kwargs)
 #eturn exceptions.ValidationError(**defaults)

 #ef assertShows(self, expected, **kwargs):
 #xpected = textwrap.dedent(expected).rstrip("\n")

 #rror = self.make_error(**kwargs)
 #essage_line, _, rest = str(error).partition("\n")
 #elf.assertEqual(message_line, error.message)
 #elf.assertEqual(rest, expected)

 #ef test_it_calls_super_and_sets_args(self):
 #rror = self.make_error()
 #elf.assertGreater(len(error.args), 1)

 #ef test_repr(self):
 #elf.assertEqual(
 #epr(exceptions.ValidationError(message="Hello!")),
 #<ValidationError: 'Hello!'>",
 #

 #ef test_unset_error(self):
 #rror = exceptions.ValidationError("message")
 #elf.assertEqual(str(error), "message")

 #wargs = {
 #validator": "type",
 #validator_value": "string",
 #instance": 5,
 #schema": {"type": "string"},
 #
        # Just the message should show if any of the attributes are unset
 #or attr in kwargs:
 # = dict(kwargs)
 #el k[attr]
 #rror = exceptions.ValidationError("message", **k)
 #elf.assertEqual(str(error), "message")

 #ef test_empty_paths(self):
 #elf.assertShows(
 #""
 #ailed validating 'type' in schema:
 #'type': 'string'}

 #n instance:
 #
 #"",
 #ath=[],
 #chema_path=[],
 #

 #ef test_one_item_paths(self):
 #elf.assertShows(
 #""
 #ailed validating 'type' in schema:
 #'type': 'string'}

 #n instance[0]:
 #
 #"",
 #ath=[0],
 #chema_path=["items"],
 #

 #ef test_multiple_item_paths(self):
 #elf.assertShows(
 #""
 #ailed validating 'type' in schema['items'][0]:
 #'type': 'string'}

 #n instance[0]['a']:
 #
 #"",
 #ath=[0, "a"],
 #chema_path=["items", 0, 1],
 #

 #ef test_uses_pprint(self):
 #elf.assertShows(
 #""
 #ailed validating 'maxLength' in schema:
 #0: 0,
 #: 1,
 #: 2,
 #: 3,
 #: 4,
 #: 5,
 #: 6,
 #: 7,
 #: 8,
 #: 9,
 #0: 10,
 #1: 11,
 #2: 12,
 #3: 13,
 #4: 14,
 #5: 15,
 #6: 16,
 #7: 17,
 #8: 18,
 #9: 19}

 #n instance:
 #0,
 #,
 #,
 #,
 #,
 #,
 #,
 #,
 #,
 #,
 #0,
 #1,
 #2,
 #3,
 #4,
 #5,
 #6,
 #7,
 #8,
 #9,
 #0,
 #1,
 #2,
 #3,
 #4]
 #"",
 #nstance=list(range(25)),
 #chema=dict(zip(range(20), range(20))),
 #alidator="maxLength",
 #

 #ef test_does_not_reorder_dicts(self):
 #elf.assertShows(
 #""
 #ailed validating 'type' in schema:
 #'do': 3, 'not': 7, 'sort': 37, 'me': 73}

 #n instance:
 #'here': 73, 'too': 37, 'no': 7, 'sorting': 3}
 #"",
 #chema={
 #do": 3,
 #not": 7,
 #sort": 37,
 #me": 73,
 #,
 #nstance={
 #here": 73,
 #too": 37,
 #no": 7,
 #sorting": 3,
 #,
 #

 #ef test_str_works_with_instances_having_overriden_eq_operator(self):
 #""
 #heck for #164 which rendered exceptions unusable when a
 #ValidationError` involved instances with an `__eq__` method
 #hat returned truthy values.
 #""

 #lass DontEQMeBro:
 #ef __eq__(this, other):  # pragma: no cover
 #elf.fail("Don't!")

 #ef __ne__(this, other):  # pragma: no cover
 #elf.fail("Don't!")

 #nstance = DontEQMeBro()
 #rror = exceptions.ValidationError(
 #a message",
 #alidator="foo",
 #nstance=instance,
 #alidator_value="some",
 #chema="schema",
 #
 #elf.assertIn(repr(instance), str(error))


class TestHashable(TestCase):
 #ef test_hashable(self):
 #exceptions.ValidationError("")}
 #exceptions.SchemaError("")}


class TestJsonPathRendering(TestCase):
 #ef validate_json_path_rendering(self, property_name, expected_path):
 #rror = exceptions.ValidationError(
 #ath=[property_name],
 #essage="1",
 #alidator="foo",
 #nstance="i1",
 #

 #endered_json_path = error.json_path
 #elf.assertEqual(rendered_json_path, expected_path)

 #e_parsed_name = jsonpath_ng.parse(rendered_json_path).right.fields[0]
 #elf.assertEqual(re_parsed_name, property_name)

 #ef test_basic(self):
 #elf.validate_json_path_rendering("x", "$.x")

 #ef test_empty(self):
 #elf.validate_json_path_rendering("", "$['']")

 #ef test_number(self):
 #elf.validate_json_path_rendering("1", "$['1']")

 #ef test_period(self):
 #elf.validate_json_path_rendering(".", "$['.']")

 #ef test_single_quote(self):
 #elf.validate_json_path_rendering("'", r"$['\'']")

 #ef test_space(self):
 #elf.validate_json_path_rendering(" ", "$[' ']")

 #ef test_backslash(self):
 #elf.validate_json_path_rendering("\\", r"$['\\']")

 #ef test_backslash_single_quote(self):
 #elf.validate_json_path_rendering(r"\'", r"$['\\\'']")

 #ef test_underscore(self):
 #elf.validate_json_path_rendering("_", r"$['_']")

 #ef test_double_quote(self):
 #elf.validate_json_path_rendering('"', """$['"']""")

 #ef test_hyphen(self):
 #elf.validate_json_path_rendering("-", "$['-']")

 #ef test_json_path_injection(self):
 #elf.validate_json_path_rendering("a[0]", "$['a[0]']")

 #ef test_open_bracket(self):
 #elf.validate_json_path_rendering("[", "$['[']")
