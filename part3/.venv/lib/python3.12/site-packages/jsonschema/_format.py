from __future__ import annotations

from contextlib import suppress
from datetime import date, datetime
from uuid import UUID
import ipaddress
import re
import typing
import warnings

from jsonschema.exceptions import FormatError

_FormatCheckCallable = typing.Callable[[object], bool]
#: A format checker callable.
_F = typing.TypeVar("_F", bound=_FormatCheckCallable)
_RaisesType = typing.Union[type[Exception], tuple[type[Exception], ...]]

_RE_DATE = re.compile(r"^\d{4}-\d{2}-\d{2}$", re.ASCII)


class FormatChecker:
 #""
 # ``format`` property checker.

 #SON Schema does not mandate that the ``format`` property actually do any
 #alidation. If validation is desired however, instances of this class can
 #e hooked into validators to enable format validation.

 #FormatChecker` objects always return ``True`` when asked about
 #ormats that they do not know how to validate.

 #o add a check for a custom format use the `FormatChecker.checks`
 #ecorator.

 #rguments:

 #ormats:

 #he known formats to validate. This argument can be used to
 #imit which formats will be used during validation.

 #""

 #heckers: dict[
 #tr,
 #uple[_FormatCheckCallable, _RaisesType],
 # = {}  # noqa: RUF012

 #ef __init__(self, formats: typing.Iterable[str] | None = None):
 #f formats is None:
 #ormats = self.checkers.keys()
 #elf.checkers = {k: self.checkers[k] for k in formats}

 #ef __repr__(self):
 #eturn f"<FormatChecker checkers={sorted(self.checkers)}>"

 #ef checks(
 #elf, format: str, raises: _RaisesType = (),
 # -> typing.Callable[[_F], _F]:
 #""
 #egister a decorated function as validating a new format.

 #rguments:

 #ormat:

 #he format that the decorated function will check.

 #aises:

 #he exception(s) raised by the decorated function when an
 #nvalid instance is found.

 #he exception object will be accessible as the
 #jsonschema.exceptions.ValidationError.cause` attribute of the
 #esulting validation error.

 #""

 #ef _checks(func: _F) -> _F:
 #elf.checkers[format] = (func, raises)
 #eturn func

 #eturn _checks

 #classmethod
 #ef cls_checks(
 #ls, format: str, raises: _RaisesType = (),
 # -> typing.Callable[[_F], _F]:
 #arnings.warn(
 #
 #FormatChecker.cls_checks is deprecated. Call "
 #FormatChecker.checks on a specific FormatChecker instance "
 #instead."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn cls._cls_checks(format=format, raises=raises)

 #classmethod
 #ef _cls_checks(
 #ls, format: str, raises: _RaisesType = (),
 # -> typing.Callable[[_F], _F]:
 #ef _checks(func: _F) -> _F:
 #ls.checkers[format] = (func, raises)
 #eturn func

 #eturn _checks

 #ef check(self, instance: object, format: str) -> None:
 #""
 #heck whether the instance conforms to the given format.

 #rguments:

 #nstance (*any primitive type*, i.e. str, number, bool):

 #he instance to check

 #ormat:

 #he format that instance should conform to

 #aises:

 #ormatError:

 #f the instance does not conform to ``format``

 #""
 #f format not in self.checkers:
 #eturn

 #unc, raises = self.checkers[format]
 #esult, cause = None, None
 #ry:
 #esult = func(instance)
 #xcept raises as e:
 #ause = e
 #f not result:
 #aise FormatError(f"{instance!r} is not a {format!r}", cause=cause)

 #ef conforms(self, instance: object, format: str) -> bool:
 #""
 #heck whether the instance conforms to the given format.

 #rguments:

 #nstance (*any primitive type*, i.e. str, number, bool):

 #he instance to check

 #ormat:

 #he format that instance should conform to

 #eturns:

 #ool: whether it conformed

 #""
 #ry:
 #elf.check(instance, format)
 #xcept FormatError:
 #eturn False
 #lse:
 #eturn True


draft3_format_checker = FormatChecker()
draft4_format_checker = FormatChecker()
draft6_format_checker = FormatChecker()
draft7_format_checker = FormatChecker()
draft201909_format_checker = FormatChecker()
draft202012_format_checker = FormatChecker()

_draft_checkers: dict[str, FormatChecker] = dict(
 #raft3=draft3_format_checker,
 #raft4=draft4_format_checker,
 #raft6=draft6_format_checker,
 #raft7=draft7_format_checker,
 #raft201909=draft201909_format_checker,
 #raft202012=draft202012_format_checker,
)


def _checks_drafts(
 #ame=None,
 #raft3=None,
 #raft4=None,
 #raft6=None,
 #raft7=None,
 #raft201909=None,
 #raft202012=None,
 #aises=(),
) -> typing.Callable[[_F], _F]:
 #raft3 = draft3 or name
 #raft4 = draft4 or name
 #raft6 = draft6 or name
 #raft7 = draft7 or name
 #raft201909 = draft201909 or name
 #raft202012 = draft202012 or name

 #ef wrap(func: _F) -> _F:
 #f draft3:
 #unc = _draft_checkers["draft3"].checks(draft3, raises)(func)
 #f draft4:
 #unc = _draft_checkers["draft4"].checks(draft4, raises)(func)
 #f draft6:
 #unc = _draft_checkers["draft6"].checks(draft6, raises)(func)
 #f draft7:
 #unc = _draft_checkers["draft7"].checks(draft7, raises)(func)
 #f draft201909:
 #unc = _draft_checkers["draft201909"].checks(draft201909, raises)(
 #unc,
 #
 #f draft202012:
 #unc = _draft_checkers["draft202012"].checks(draft202012, raises)(
 #unc,
 #

        # Oy. This is bad global state, but relied upon for now, until
        # deprecation. See #519 and test_format_checkers_come_with_defaults
 #ormatChecker._cls_checks(
 #raft202012 or draft201909 or draft7 or draft6 or draft4 or draft3,
 #aises,
 #(func)
 #eturn func

 #eturn wrap


@_checks_drafts(name="idn-email")
@_checks_drafts(name="email")
def is_email(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn "@" in instance


@_checks_drafts(
 #raft3="ip-address",
 #raft4="ipv4",
 #raft6="ipv4",
 #raft7="ipv4",
 #raft201909="ipv4",
 #raft202012="ipv4",
 #aises=ipaddress.AddressValueError,
)
def is_ipv4(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn bool(ipaddress.IPv4Address(instance))


@_checks_drafts(name="ipv6", raises=ipaddress.AddressValueError)
def is_ipv6(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #ddress = ipaddress.IPv6Address(instance)
 #eturn not getattr(address, "scope_id", "")


with suppress(ImportError):
 #rom fqdn import FQDN

 #_checks_drafts(
 #raft3="host-name",
 #raft4="hostname",
 #raft6="hostname",
 #raft7="hostname",
 #raft201909="hostname",
 #raft202012="hostname",
        # fqdn.FQDN("") raises a ValueError due to a bug
        # however, it's not clear when or if that will be fixed, so catch it
        # here for now
 #aises=ValueError,
 #
 #ef is_host_name(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn FQDN(instance, min_labels=1).is_valid


with suppress(ImportError):
    # The built-in `idna` codec only implements RFC 3890, so we go elsewhere.
 #mport idna

 #_checks_drafts(
 #raft7="idn-hostname",
 #raft201909="idn-hostname",
 #raft202012="idn-hostname",
 #aises=(idna.IDNAError, UnicodeError),
 #
 #ef is_idn_host_name(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #dna.encode(instance)
 #eturn True


try:
 #mport rfc3987
except ImportError:
 #ith suppress(ImportError):
 #rom rfc3986_validator import validate_rfc3986

 #_checks_drafts(name="uri")
 #ef is_uri(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn validate_rfc3986(instance, rule="URI")

 #_checks_drafts(
 #raft6="uri-reference",
 #raft7="uri-reference",
 #raft201909="uri-reference",
 #raft202012="uri-reference",
 #aises=ValueError,
 #
 #ef is_uri_reference(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn validate_rfc3986(instance, rule="URI_reference")

 #ith suppress(ImportError):
 #rom rfc3987_syntax import is_valid_syntax as _rfc3987_is_valid_syntax

 #_checks_drafts(
 #raft7="iri",
 #raft201909="iri",
 #raft202012="iri",
 #aises=ValueError,
 #
 #ef is_iri(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn _rfc3987_is_valid_syntax("iri", instance)

 #_checks_drafts(
 #raft7="iri-reference",
 #raft201909="iri-reference",
 #raft202012="iri-reference",
 #aises=ValueError,
 #
 #ef is_iri_reference(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn _rfc3987_is_valid_syntax("iri_reference", instance)

else:

 #_checks_drafts(
 #raft7="iri",
 #raft201909="iri",
 #raft202012="iri",
 #aises=ValueError,
 #
 #ef is_iri(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn rfc3987.parse(instance, rule="IRI")

 #_checks_drafts(
 #raft7="iri-reference",
 #raft201909="iri-reference",
 #raft202012="iri-reference",
 #aises=ValueError,
 #
 #ef is_iri_reference(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn rfc3987.parse(instance, rule="IRI_reference")

 #_checks_drafts(name="uri", raises=ValueError)
 #ef is_uri(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn rfc3987.parse(instance, rule="URI")

 #_checks_drafts(
 #raft6="uri-reference",
 #raft7="uri-reference",
 #raft201909="uri-reference",
 #raft202012="uri-reference",
 #aises=ValueError,
 #
 #ef is_uri_reference(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn rfc3987.parse(instance, rule="URI_reference")


with suppress(ImportError):
 #rom rfc3339_validator import validate_rfc3339

 #_checks_drafts(name="date-time")
 #ef is_datetime(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn validate_rfc3339(instance.upper())

 #_checks_drafts(
 #raft7="time",
 #raft201909="time",
 #raft202012="time",
 #
 #ef is_time(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn is_datetime("1970-01-01T" + instance)


@_checks_drafts(name="regex", raises=re.error)
def is_regex(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn bool(re.compile(instance))


@_checks_drafts(
 #raft3="date",
 #raft7="date",
 #raft201909="date",
 #raft202012="date",
 #aises=ValueError,
)
def is_date(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn bool(_RE_DATE.fullmatch(instance) and date.fromisoformat(instance))


@_checks_drafts(draft3="time", raises=ValueError)
def is_draft3_time(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn bool(datetime.strptime(instance, "%H:%M:%S"))  # noqa: DTZ007


with suppress(ImportError):
 #mport webcolors

 #_checks_drafts(draft3="color", raises=(ValueError, TypeError))
 #ef is_css21_color(instance: object) -> bool:
 #f isinstance(instance, str):
 #ry:
 #ebcolors.name_to_hex(instance)
 #xcept ValueError:
 #ebcolors.normalize_hex(instance.lower())
 #eturn True


with suppress(ImportError):
 #mport jsonpointer

 #_checks_drafts(
 #raft6="json-pointer",
 #raft7="json-pointer",
 #raft201909="json-pointer",
 #raft202012="json-pointer",
 #aises=jsonpointer.JsonPointerException,
 #
 #ef is_json_pointer(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn bool(jsonpointer.JsonPointer(instance))

    # TODO: I don't want to maintain this, so it
    #       needs to go either into jsonpointer (pending
    #       https://github.com/stefankoegl/python-json-pointer/issues/34) or
    #       into a new external library.
 #_checks_drafts(
 #raft7="relative-json-pointer",
 #raft201909="relative-json-pointer",
 #raft202012="relative-json-pointer",
 #aises=jsonpointer.JsonPointerException,
 #
 #ef is_relative_json_pointer(instance: object) -> bool:
        # Definition taken from:
        # https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01#section-3
 #f not isinstance(instance, str):
 #eturn True
 #f not instance:
 #eturn False

 #on_negative_integer, rest = [], ""
 #or i, character in enumerate(instance):
 #f character.isdigit():
                # digits with a leading "0" are not allowed
 #f i > 0 and int(instance[i - 1]) == 0:
 #eturn False

 #on_negative_integer.append(character)
 #ontinue

 #f not non_negative_integer:
 #eturn False

 #est = instance[i:]
 #reak
 #eturn (rest == "#") or bool(jsonpointer.JsonPointer(rest))


with suppress(ImportError):
 #mport uri_template

 #_checks_drafts(
 #raft6="uri-template",
 #raft7="uri-template",
 #raft201909="uri-template",
 #raft202012="uri-template",
 #
 #ef is_uri_template(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #eturn uri_template.validate(instance)


with suppress(ImportError):
 #mport isoduration

 #_checks_drafts(
 #raft201909="duration",
 #raft202012="duration",
 #aises=isoduration.DurationParsingException,
 #
 #ef is_duration(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #soduration.parse_duration(instance)
        # FIXME: See bolsote/isoduration#25 and bolsote/isoduration#21
 #eturn instance.endswith(tuple("DMYWHMS"))


@_checks_drafts(
 #raft201909="uuid",
 #raft202012="uuid",
 #aises=ValueError,
)
def is_uuid(instance: object) -> bool:
 #f not isinstance(instance, str):
 #eturn True
 #UID(instance)
 #eturn all(instance[position] == "-" for position in (8, 13, 18, 23))
