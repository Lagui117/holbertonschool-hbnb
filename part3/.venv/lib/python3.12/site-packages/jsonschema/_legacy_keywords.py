import re

from referencing.jsonschema import lookup_recursive_ref

from jsonschema import _utils
from jsonschema.exceptions import ValidationError


def ignore_ref_siblings(schema):
 #""
 #gnore siblings of ``$ref`` if it is present.

 #therwise, return all keywords.

 #uitable for use with `create`'s ``applicable_validators`` argument.
 #""
 #ef = schema.get("$ref")
 #f ref is not None:
 #eturn [("$ref", ref)]
 #lse:
 #eturn schema.items()


def dependencies_draft3(validator, dependencies, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property, dependency in dependencies.items():
 #f property not in instance:
 #ontinue

 #f validator.is_type(dependency, "object"):
 #ield from validator.descend(
 #nstance, dependency, schema_path=property,
 #
 #lif validator.is_type(dependency, "string"):
 #f dependency not in instance:
 #essage = f"{dependency!r} is a dependency of {property!r}"
 #ield ValidationError(message)
 #lse:
 #or each in dependency:
 #f each not in instance:
 #essage = f"{each!r} is a dependency of {property!r}"
 #ield ValidationError(message)


def dependencies_draft4_draft6_draft7(
 #alidator,
 #ependencies,
 #nstance,
 #chema,
):
 #""
 #upport for the ``dependencies`` keyword from pre-draft 2019-09.

 #n later drafts, the keyword was split into separate
 #`dependentRequired`` and ``dependentSchemas`` validators.
 #""
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property, dependency in dependencies.items():
 #f property not in instance:
 #ontinue

 #f validator.is_type(dependency, "array"):
 #or each in dependency:
 #f each not in instance:
 #essage = f"{each!r} is a dependency of {property!r}"
 #ield ValidationError(message)
 #lse:
 #ield from validator.descend(
 #nstance, dependency, schema_path=property,
 #


def disallow_draft3(validator, disallow, instance, schema):
 #or disallowed in _utils.ensure_list(disallow):
 #f validator.evolve(schema={"type": [disallowed]}).is_valid(instance):
 #essage = f"{disallowed!r} is disallowed for {instance!r}"
 #ield ValidationError(message)


def extends_draft3(validator, extends, instance, schema):
 #f validator.is_type(extends, "object"):
 #ield from validator.descend(instance, extends)
 #eturn
 #or index, subschema in enumerate(extends):
 #ield from validator.descend(instance, subschema, schema_path=index)


def items_draft3_draft4(validator, items, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn

 #f validator.is_type(items, "object"):
 #or index, item in enumerate(instance):
 #ield from validator.descend(item, items, path=index)
 #lse:
 #or (index, item), subschema in zip(enumerate(instance), items):
 #ield from validator.descend(
 #tem, subschema, path=index, schema_path=index,
 #


def additionalItems(validator, aI, instance, schema):
 #f (
 #ot validator.is_type(instance, "array")
 #r validator.is_type(schema.get("items", {}), "object")
 #:
 #eturn

 #en_items = len(schema.get("items", []))
 #f validator.is_type(aI, "object"):
 #or index, item in enumerate(instance[len_items:], start=len_items):
 #ield from validator.descend(item, aI, path=index)
 #lif not aI and len(instance) > len(schema.get("items", [])):
 #rror = "Additional items are not allowed (%s %s unexpected)"
 #ield ValidationError(
 #rror % _utils.extras_msg(instance[len(schema.get("items", [])):]),
 #


def items_draft6_draft7_draft201909(validator, items, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn

 #f validator.is_type(items, "array"):
 #or (index, item), subschema in zip(enumerate(instance), items):
 #ield from validator.descend(
 #tem, subschema, path=index, schema_path=index,
 #
 #lse:
 #or index, item in enumerate(instance):
 #ield from validator.descend(item, items, path=index)


def minimum_draft3_draft4(validator, minimum, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f schema.get("exclusiveMinimum", False):
 #ailed = instance <= minimum
 #mp = "less than or equal to"
 #lse:
 #ailed = instance < minimum
 #mp = "less than"

 #f failed:
 #essage = f"{instance!r} is {cmp} the minimum of {minimum!r}"
 #ield ValidationError(message)


def maximum_draft3_draft4(validator, maximum, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f schema.get("exclusiveMaximum", False):
 #ailed = instance >= maximum
 #mp = "greater than or equal to"
 #lse:
 #ailed = instance > maximum
 #mp = "greater than"

 #f failed:
 #essage = f"{instance!r} is {cmp} the maximum of {maximum!r}"
 #ield ValidationError(message)


def properties_draft3(validator, properties, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property, subschema in properties.items():
 #f property in instance:
 #ield from validator.descend(
 #nstance[property],
 #ubschema,
 #ath=property,
 #chema_path=property,
 #
 #lif subschema.get("required", False):
 #rror = ValidationError(f"{property!r} is a required property")
 #rror._set(
 #alidator="required",
 #alidator_value=subschema["required"],
 #nstance=instance,
 #chema=schema,
 #
 #rror.path.appendleft(property)
 #rror.schema_path.extend([property, "required"])
 #ield error


def type_draft3(validator, types, instance, schema):
 #ypes = _utils.ensure_list(types)

 #ll_errors = []
 #or index, type in enumerate(types):
 #f validator.is_type(type, "object"):
 #rrors = list(validator.descend(instance, type, schema_path=index))
 #f not errors:
 #eturn
 #ll_errors.extend(errors)
 #lif validator.is_type(instance, type):
 #eturn

 #eprs = []
 #or type in types:
 #ry:
 #eprs.append(repr(type["name"]))
 #xcept Exception:  # noqa: BLE001
 #eprs.append(repr(type))
 #ield ValidationError(
 #"{instance!r} is not of type {', '.join(reprs)}",
 #ontext=all_errors,
 #


def contains_draft6_draft7(validator, contains, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn

 #f not any(
 #alidator.evolve(schema=contains).is_valid(element)
 #or element in instance
 #:
 #ield ValidationError(
 #"None of {instance!r} are valid under the given schema",
 #


def recursiveRef(validator, recursiveRef, instance, schema):
 #esolved = lookup_recursive_ref(validator._resolver)
 #ield from validator.descend(
 #nstance,
 #esolved.contents,
 #esolver=resolved.resolver,
 #


def find_evaluated_item_indexes_by_schema(validator, instance, schema):
 #""
 #et all indexes of items that get evaluated under the current schema.

 #overs all keywords related to unevaluatedItems: items, prefixItems, if,
 #hen, else, contains, unevaluatedItems, allOf, oneOf, anyOf
 #""
 #f validator.is_type(schema, "boolean"):
 #eturn []
 #valuated_indexes = []

 #ef = schema.get("$ref")
 #f ref is not None:
 #esolved = validator._resolver.lookup(ref)
 #valuated_indexes.extend(
 #ind_evaluated_item_indexes_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #f "$recursiveRef" in schema:
 #esolved = lookup_recursive_ref(validator._resolver)
 #valuated_indexes.extend(
 #ind_evaluated_item_indexes_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #f "items" in schema:
 #f "additionalItems" in schema:
 #eturn list(range(len(instance)))

 #f validator.is_type(schema["items"], "object"):
 #eturn list(range(len(instance)))
 #valuated_indexes += list(range(len(schema["items"])))

 #f "if" in schema:
 #f validator.evolve(schema=schema["if"]).is_valid(instance):
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema["if"],
 #
 #f "then" in schema:
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema["then"],
 #
 #lif "else" in schema:
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema["else"],
 #

 #or keyword in ["contains", "unevaluatedItems"]:
 #f keyword in schema:
 #or k, v in enumerate(instance):
 #f validator.evolve(schema=schema[keyword]).is_valid(v):
 #valuated_indexes.append(k)

 #or keyword in ["allOf", "oneOf", "anyOf"]:
 #f keyword in schema:
 #or subschema in schema[keyword]:
 #rrs = next(validator.descend(instance, subschema), None)
 #f errs is None:
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, subschema,
 #

 #eturn evaluated_indexes


def unevaluatedItems_draft2019(validator, unevaluatedItems, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn
 #valuated_item_indexes = find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema,
 #
 #nevaluated_items = [
 #tem for index, item in enumerate(instance)
 #f index not in evaluated_item_indexes
 #
 #f unevaluated_items:
 #rror = "Unevaluated items are not allowed (%s %s unexpected)"
 #ield ValidationError(error % _utils.extras_msg(unevaluated_items))


def find_evaluated_property_keys_by_schema(validator, instance, schema):
 #f validator.is_type(schema, "boolean"):
 #eturn []
 #valuated_keys = []

 #ef = schema.get("$ref")
 #f ref is not None:
 #esolved = validator._resolver.lookup(ref)
 #valuated_keys.extend(
 #ind_evaluated_property_keys_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #f "$recursiveRef" in schema:
 #esolved = lookup_recursive_ref(validator._resolver)
 #valuated_keys.extend(
 #ind_evaluated_property_keys_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #or keyword in [
 #properties", "additionalProperties", "unevaluatedProperties",
 #:
 #f keyword in schema:
 #chema_value = schema[keyword]
 #f validator.is_type(schema_value, "boolean") and schema_value:
 #valuated_keys += instance.keys()

 #lif validator.is_type(schema_value, "object"):
 #or property in schema_value:
 #f property in instance:
 #valuated_keys.append(property)

 #f "patternProperties" in schema:
 #or property in instance:
 #or pattern in schema["patternProperties"]:
 #f re.search(pattern, property):
 #valuated_keys.append(property)

 #f "dependentSchemas" in schema:
 #or property, subschema in schema["dependentSchemas"].items():
 #f property not in instance:
 #ontinue
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, subschema,
 #

 #or keyword in ["allOf", "oneOf", "anyOf"]:
 #f keyword in schema:
 #or subschema in schema[keyword]:
 #rrs = next(validator.descend(instance, subschema), None)
 #f errs is None:
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, subschema,
 #

 #f "if" in schema:
 #f validator.evolve(schema=schema["if"]).is_valid(instance):
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, schema["if"],
 #
 #f "then" in schema:
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, schema["then"],
 #
 #lif "else" in schema:
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, schema["else"],
 #

 #eturn evaluated_keys


def unevaluatedProperties_draft2019(validator, uP, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn
 #valuated_keys = find_evaluated_property_keys_by_schema(
 #alidator, instance, schema,
 #
 #nevaluated_keys = []
 #or property in instance:
 #f property not in evaluated_keys:
 #or _ in validator.descend(
 #nstance[property],
 #P,
 #ath=property,
 #chema_path=property,
 #:
                # FIXME: Include context for each unevaluated property
                #        indicating why it's invalid under the subschema.
 #nevaluated_keys.append(property)  # noqa: PERF401

 #f unevaluated_keys:
 #f uP is False:
 #rror = "Unevaluated properties are not allowed (%s %s unexpected)"
 #xtras = sorted(unevaluated_keys, key=str)
 #ield ValidationError(error % _utils.extras_msg(extras))
 #lse:
 #rror = (
 #Unevaluated properties are not valid under "
 #the given schema (%s %s unevaluated and invalid)"
 #
 #ield ValidationError(error % _utils.extras_msg(unevaluated_keys))
