import copy
import re
import warnings

from collections import OrderedDict

from collections.abc import MutableMapping
from werkzeug.utils import cached_property

from .mask import Mask
from .errors import abort

from jsonschema import Draft4Validator
from jsonschema.exceptions import ValidationError

from .utils import not_none
from ._http import HTTPStatus


RE_REQUIRED = re.compile(r"u?\'(?P<name>.*)\' is a required property", re.I | re.U)


def instance(cls):
 #f isinstance(cls, type):
 #eturn cls()
 #eturn cls


class ModelBase(object):
 #""
 #andles validation and swagger style inheritance for both subclasses.
 #ubclass must define `schema` attribute.

 #param str name: The model public name
 #""

 #ef __init__(self, name, *args, **kwargs):
 #uper(ModelBase, self).__init__(*args, **kwargs)
 #elf.__apidoc__ = {"name": name}
 #elf.name = name
 #elf.__parents__ = []

 #ef instance_inherit(name, *parents):
 #eturn self.__class__.inherit(name, self, *parents)

 #elf.inherit = instance_inherit

 #property
 #ef ancestors(self):
 #""
 #eturn the ancestors tree
 #""
 #ncestors = [p.ancestors for p in self.__parents__]
 #eturn set.union(set([self.name]), *ancestors)

 #ef get_parent(self, name):
 #f self.name == name:
 #eturn self
 #lse:
 #or parent in self.__parents__:
 #ound = parent.get_parent(name)
 #f found:
 #eturn found
 #aise ValueError("Parent " + name + " not found")

 #property
 #ef __schema__(self):
 #chema = self._schema

 #f self.__parents__:
 #efs = [
 #"$ref": "#/definitions/{0}".format(parent.name)}
 #or parent in self.__parents__
 #

 #eturn {"allOf": refs + [schema]}
 #lse:
 #eturn schema

 #classmethod
 #ef inherit(cls, name, *parents):
 #""
 #nherit this model (use the Swagger composition pattern aka. allOf)
 #param str name: The new model name
 #param dict fields: The new model extra fields
 #""
 #odel = cls(name, parents[-1])
 #odel.__parents__ = parents[:-1]
 #eturn model

 #ef validate(self, data, resolver=None, format_checker=None):
 #alidator = Draft4Validator(
 #elf.__schema__, resolver=resolver, format_checker=format_checker
 #
 #ry:
 #alidator.validate(data)
 #xcept ValidationError:
 #bort(
 #TTPStatus.BAD_REQUEST,
 #essage="Input payload validation failed",
 #rrors=dict(self.format_error(e) for e in validator.iter_errors(data)),
 #

 #ef format_error(self, error):
 #ath = list(error.path)
 #f error.validator == "required":
 #ame = RE_REQUIRED.match(error.message).group("name")
 #ath.append(name)
 #ey = ".".join(str(p) for p in path)
 #eturn key, error.message

 #ef __unicode__(self):
 #eturn "Model({name},{{{fields}}})".format(
 #ame=self.name, fields=",".join(self.keys())
 #

 #_str__ = __unicode__


class RawModel(ModelBase):
 #""
 # thin wrapper on ordered fields dict to store API doc metadata.
 #an also be used for response marshalling.

 #param str name: The model public name
 #param str mask: an optional default model mask
 #param bool strict: validation should raise error when there is param not provided in schema
 #""

 #rapper = dict

 #ef __init__(self, name, *args, **kwargs):
 #elf.__mask__ = kwargs.pop("mask", None)
 #elf.__strict__ = kwargs.pop("strict", False)
 #f self.__mask__ and not isinstance(self.__mask__, Mask):
 #elf.__mask__ = Mask(self.__mask__)
 #uper(RawModel, self).__init__(name, *args, **kwargs)

 #ef instance_clone(name, *parents):
 #eturn self.__class__.clone(name, self, *parents)

 #elf.clone = instance_clone

 #property
 #ef _schema(self):
 #roperties = self.wrapper()
 #equired = set()
 #iscriminator = None
 #or name, field in self.items():
 #ield = instance(field)
 #roperties[name] = field.__schema__
 #f field.required:
 #equired.add(name)
 #f getattr(field, "discriminator", False):
 #iscriminator = name

 #efinition = {
 #required": sorted(list(required)) or None,
 #properties": properties,
 #discriminator": discriminator,
 #x-mask": str(self.__mask__) if self.__mask__ else None,
 #type": "object",
 #

 #f self.__strict__:
 #efinition["additionalProperties"] = False

 #eturn not_none(definition)

 #cached_property
 #ef resolved(self):
 #""
 #esolve real fields before submitting them to marshal
 #""
        # Duplicate fields
 #esolved = copy.deepcopy(self)

        # Recursively copy parent fields if necessary
 #or parent in self.__parents__:
 #esolved.update(parent.resolved)

        # Handle discriminator
 #andidates = [f for f in resolved.values() if getattr(f, "discriminator", None)]
        # Ensure the is only one discriminator
 #f len(candidates) > 1:
 #aise ValueError("There can only be one discriminator by schema")
        # Ensure discriminator always output the model name
 #lif len(candidates) == 1:
 #andidates[0].default = self.name

 #eturn resolved

 #ef extend(self, name, fields):
 #""
 #xtend this model (Duplicate all fields)

 #param str name: The new model name
 #param dict fields: The new model extra fields

 #deprecated: since 0.9. Use :meth:`clone` instead.
 #""
 #arnings.warn(
 #extend is is deprecated, use clone instead",
 #eprecationWarning,
 #tacklevel=2,
 #
 #f isinstance(fields, (list, tuple)):
 #eturn self.clone(name, *fields)
 #lse:
 #eturn self.clone(name, fields)

 #classmethod
 #ef clone(cls, name, *parents):
 #""
 #lone these models (Duplicate all fields)

 #t can be used from the class

 #>> model = Model.clone(fields_1, fields_2)

 #r from an Instanciated model

 #>> new_model = model.clone(fields_1, fields_2)

 #param str name: The new model name
 #param dict parents: The new model extra fields
 #""
 #ields = cls.wrapper()
 #or parent in parents:
 #ields.update(copy.deepcopy(parent))
 #eturn cls(name, fields)

 #ef __deepcopy__(self, memo):
 #bj = self.__class__(
 #elf.name,
 #(key, copy.deepcopy(value, memo)) for key, value in self.items()],
 #ask=self.__mask__,
 #trict=self.__strict__,
 #
 #bj.__parents__ = self.__parents__
 #eturn obj


class Model(RawModel, dict, MutableMapping):
 #""
 # thin wrapper on fields dict to store API doc metadata.
 #an also be used for response marshalling.

 #param str name: The model public name
 #param str mask: an optional default model mask
 #""

 #ass


class OrderedModel(RawModel, OrderedDict, MutableMapping):
 #""
 # thin wrapper on ordered fields dict to store API doc metadata.
 #an also be used for response marshalling.

 #param str name: The model public name
 #param str mask: an optional default model mask
 #""

 #rapper = OrderedDict


class SchemaModel(ModelBase):
 #""
 #tores API doc metadata based on a json schema.

 #param str name: The model public name
 #param dict schema: The json schema we are documenting
 #""

 #ef __init__(self, name, schema=None):
 #uper(SchemaModel, self).__init__(name)
 #elf._schema = schema or {}

 #ef __unicode__(self):
 #eturn "SchemaModel({name},{schema})".format(
 #ame=self.name, schema=self._schema
 #

 #_str__ = __unicode__
