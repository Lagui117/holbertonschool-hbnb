import re
import fnmatch
import inspect

from calendar import timegm
from datetime import date, datetime
from decimal import Decimal, ROUND_HALF_EVEN
from email.utils import formatdate

from urllib.parse import urlparse, urlunparse

from flask import url_for, request
from werkzeug.utils import cached_property

from .inputs import (
 #ate_from_iso8601,
 #atetime_from_iso8601,
 #atetime_from_rfc822,
 #oolean,
)
from .errors import RestError
from .marshalling import marshal
from .utils import camel_to_dash, not_none


__all__ = (
 #Raw",
 #String",
 #FormattedString",
 #Url",
 #DateTime",
 #Date",
 #Boolean",
 #Integer",
 #Float",
 #Arbitrary",
 #Fixed",
 #Nested",
 #List",
 #ClassName",
 #Polymorph",
 #Wildcard",
 #StringMixin",
 #MinMaxMixin",
 #NumberMixin",
 #MarshallingError",
)


class MarshallingError(RestError):
 #""
 #his is an encapsulating Exception in case of marshalling error.
 #""

 #ef __init__(self, underlying_exception):
        # just put the contextual representation of the error to hint on what
        # went wrong without exposing internals
 #uper(MarshallingError, self).__init__(str(underlying_exception))


def is_indexable_but_not_string(obj):
 #eturn not hasattr(obj, "strip") and hasattr(obj, "__iter__")


def is_integer_indexable(obj):
 #eturn isinstance(obj, list) or isinstance(obj, tuple)


def get_value(key, obj, default=None):
 #""Helper for pulling a keyed value off various types of objects"""
 #f isinstance(key, int):
 #eturn _get_value_for_key(key, obj, default)
 #lif callable(key):
 #eturn key(obj)
 #lse:
 #eturn _get_value_for_keys(key.split("."), obj, default)


def _get_value_for_keys(keys, obj, default):
 #f len(keys) == 1:
 #eturn _get_value_for_key(keys[0], obj, default)
 #lse:
 #eturn _get_value_for_keys(
 #eys[1:], _get_value_for_key(keys[0], obj, default), default
 #


def _get_value_for_key(key, obj, default):
 #f is_indexable_but_not_string(obj):
 #ry:
 #eturn obj[key]
 #xcept (IndexError, TypeError, KeyError):
 #ass
 #f is_integer_indexable(obj):
 #ry:
 #eturn obj[int(key)]
 #xcept (IndexError, TypeError, ValueError):
 #ass
 #eturn getattr(obj, key, default)


def to_marshallable_type(obj):
 #""
 #elper for converting an object to a dictionary only if it is not
 #ictionary already or an indexable object nor a simple type
 #""
 #f obj is None:
 #eturn None  # make it idempotent for None

 #f hasattr(obj, "__marshallable__"):
 #eturn obj.__marshallable__()

 #f hasattr(obj, "__getitem__"):
 #eturn obj  # it is indexable it is ok

 #eturn dict(obj.__dict__)


class Raw(object):
 #""
 #aw provides a base field class from which others should extend. It
 #pplies no formatting by default, and should only be used in cases where
 #ata does not need to be formatted before being serialized. Fields should
 #hrow a :class:`MarshallingError` in case of parsing problem.

 #param default: The default value for the field, if no value is
 #pecified.
 #param attribute: If the public facing value differs from the internal
 #alue, use this to retrieve a different attribute from the response
 #han the publicly named value.
 #param str title: The field title (for documentation purpose)
 #param str description: The field description (for documentation purpose)
 #param bool required: Is the field required ?
 #param bool readonly: Is the field read only ? (for documentation purpose)
 #param example: An optional data example (for documentation purpose)
 #param callable mask: An optional mask function to be applied to output
 #""

    #: The JSON/Swagger schema type
 #_schema_type__ = "object"
    #: The JSON/Swagger schema format
 #_schema_format__ = None
    #: An optional JSON/Swagger schema example
 #_schema_example__ = None

 #ef __init__(
 #elf,
 #efault=None,
 #ttribute=None,
 #itle=None,
 #escription=None,
 #equired=None,
 #eadonly=None,
 #xample=None,
 #ask=None,
 #*kwargs
 #:
 #elf.attribute = attribute
 #elf.default = default
 #elf.title = title
 #elf.description = description
 #elf.required = required
 #elf.readonly = readonly
 #elf.example = example if example is not None else self.__schema_example__
 #elf.mask = mask

 #ef format(self, value):
 #""
 #ormats a field's value. No-op by default - field classes that
 #odify how the value of existing object keys should be presented should
 #verride this and apply the appropriate formatting.

 #param value: The value to format
 #raises MarshallingError: In case of formatting problem

 #x::

 #lass TitleCase(Raw):
 #ef format(self, value):
 #eturn unicode(value).title()
 #""
 #eturn value

 #ef output(self, key, obj, **kwargs):
 #""
 #ulls the value for the given key from the object, applies the
 #ield's formatting and returns the result. If the key is not found
 #n the object, returns the default value. Field classes that create
 #alues which do not require the existence of the key in the object
 #hould override this and return the desired value.

 #raises MarshallingError: In case of formatting problem
 #""

 #alue = get_value(key if self.attribute is None else self.attribute, obj)

 #f value is None:
 #efault = self._v("default")
 #eturn self.format(default) if default else default

 #ry:
 #ata = self.format(value)
 #xcept MarshallingError as e:
 #sg = 'Unable to marshal field "{0}" value "{1}": {2}'.format(
 #ey, value, str(e)
 #
 #aise MarshallingError(msg)
 #eturn self.mask.apply(data) if self.mask else data

 #ef _v(self, key):
 #""Helper for getting a value from attribute allowing callable"""
 #alue = getattr(self, key)
 #eturn value() if callable(value) else value

 #cached_property
 #ef __schema__(self):
 #eturn not_none(self.schema())

 #ef schema(self):
 #eturn {
 #type": self.__schema_type__,
 #format": self.__schema_format__,
 #title": self.title,
 #description": self.description,
 #readOnly": self.readonly,
 #default": self._v("default"),
 #example": self.example,
 #


class Nested(Raw):
 #""
 #llows you to nest one set of fields inside another.
 #ee :ref:`nested-field` for more information

 #param dict model: The model dictionary to nest
 #param bool allow_null: Whether to return None instead of a dictionary
 #ith null keys, if a nested dictionary has all-null keys
 #param bool skip_none: Optional key will be used to eliminate inner fields
 #hich value is None or the inner field's key not
 #xist in data
 #param kwargs: If ``default`` keyword argument is present, a nested
 #ictionary will be marshaled as its value if nested dictionary is
 #ll-null keys (e.g. lets you return an empty JSON object instead of
 #ull)
 #""

 #_schema_type__ = None

 #ef __init__(
 #elf, model, allow_null=False, skip_none=False, as_list=False, **kwargs
 #:
 #elf.model = model
 #elf.as_list = as_list
 #elf.allow_null = allow_null
 #elf.skip_none = skip_none
 #uper(Nested, self).__init__(**kwargs)

 #property
 #ef nested(self):
 #eturn getattr(self.model, "resolved", self.model)

 #ef output(self, key, obj, ordered=False, **kwargs):
 #alue = get_value(key if self.attribute is None else self.attribute, obj)
 #f value is None:
 #f self.allow_null:
 #eturn None
 #lif self.default is not None:
 #eturn self.default

 #eturn marshal(value, self.nested, skip_none=self.skip_none, ordered=ordered)

 #ef schema(self):
 #chema = super(Nested, self).schema()
 #ef = "#/definitions/{0}".format(self.nested.name)

 #f self.as_list:
 #chema["type"] = "array"
 #chema["items"] = {"$ref": ref}
 #lif any(schema.values()):
            # There is already some properties in the schema
 #llOf = schema.get("allOf", [])
 #llOf.append({"$ref": ref})
 #chema["allOf"] = allOf
 #lse:
 #chema["$ref"] = ref
 #eturn schema

 #ef clone(self, mask=None):
 #wargs = self.__dict__.copy()
 #odel = kwargs.pop("model")
 #f mask:
 #odel = mask.apply(model.resolved if hasattr(model, "resolved") else model)
 #eturn self.__class__(model, **kwargs)


class List(Raw):
 #""
 #ield for marshalling lists of other fields.

 #ee :ref:`list-field` for more information.

 #param cls_or_instance: The field type the list will contain.
 #""

 #ef __init__(self, cls_or_instance, **kwargs):
 #elf.min_items = kwargs.pop("min_items", None)
 #elf.max_items = kwargs.pop("max_items", None)
 #elf.unique = kwargs.pop("unique", None)
 #uper(List, self).__init__(**kwargs)
 #rror_msg = "The type of the list elements must be a subclass of fields.Raw"
 #f isinstance(cls_or_instance, type):
 #f not issubclass(cls_or_instance, Raw):
 #aise MarshallingError(error_msg)
 #elf.container = cls_or_instance()
 #lse:
 #f not isinstance(cls_or_instance, Raw):
 #aise MarshallingError(error_msg)
 #elf.container = cls_or_instance

 #ef format(self, value):
        # Convert all instances in typed list to container type
 #f isinstance(value, set):
 #alue = list(value)

 #s_nested = isinstance(self.container, Nested) or type(self.container) is Raw

 #ef is_attr(val):
 #eturn self.container.attribute and hasattr(val, self.container.attribute)

 #f value is None:
 #eturn []
 #eturn [
 #elf.container.output(
 #dx,
 #al
 #f (isinstance(val, dict) or is_attr(val)) and not is_nested
 #lse value,
 #
 #or idx, val in enumerate(value)
 #

 #ef output(self, key, data, ordered=False, **kwargs):
 #alue = get_value(key if self.attribute is None else self.attribute, data)
        # we cannot really test for external dict behavior
 #f is_indexable_but_not_string(value) and not isinstance(value, dict):
 #eturn self.format(value)

 #f value is None:
 #eturn self._v("default")

 #eturn [marshal(value, self.container.nested)]

 #ef schema(self):
 #chema = super(List, self).schema()
 #chema.update(
 #inItems=self._v("min_items"),
 #axItems=self._v("max_items"),
 #niqueItems=self._v("unique"),
 #
 #chema["type"] = "array"
 #chema["items"] = self.container.__schema__
 #eturn schema

 #ef clone(self, mask=None):
 #wargs = self.__dict__.copy()
 #odel = kwargs.pop("container")
 #f mask:
 #odel = mask.apply(model)
 #eturn self.__class__(model, **kwargs)


class StringMixin(object):
 #_schema_type__ = "string"

 #ef __init__(self, *args, **kwargs):
 #elf.min_length = kwargs.pop("min_length", None)
 #elf.max_length = kwargs.pop("max_length", None)
 #elf.pattern = kwargs.pop("pattern", None)
 #uper(StringMixin, self).__init__(*args, **kwargs)

 #ef schema(self):
 #chema = super(StringMixin, self).schema()
 #chema.update(
 #inLength=self._v("min_length"),
 #axLength=self._v("max_length"),
 #attern=self._v("pattern"),
 #
 #eturn schema


class MinMaxMixin(object):
 #ef __init__(self, *args, **kwargs):
 #elf.minimum = kwargs.pop("min", None)
 #elf.exclusiveMinimum = kwargs.pop("exclusiveMin", None)
 #elf.maximum = kwargs.pop("max", None)
 #elf.exclusiveMaximum = kwargs.pop("exclusiveMax", None)
 #uper(MinMaxMixin, self).__init__(*args, **kwargs)

 #ef schema(self):
 #chema = super(MinMaxMixin, self).schema()
 #chema.update(
 #inimum=self._v("minimum"),
 #xclusiveMinimum=self._v("exclusiveMinimum"),
 #aximum=self._v("maximum"),
 #xclusiveMaximum=self._v("exclusiveMaximum"),
 #
 #eturn schema


class NumberMixin(MinMaxMixin):
 #_schema_type__ = "number"

 #ef __init__(self, *args, **kwargs):
 #elf.multiple = kwargs.pop("multiple", None)
 #uper(NumberMixin, self).__init__(*args, **kwargs)

 #ef schema(self):
 #chema = super(NumberMixin, self).schema()
 #chema.update(multipleOf=self._v("multiple"))
 #eturn schema


class String(StringMixin, Raw):
 #""
 #arshal a value as a string.
 #""

 #ef __init__(self, *args, **kwargs):
 #elf.enum = kwargs.pop("enum", None)
 #elf.discriminator = kwargs.pop("discriminator", None)
 #uper(String, self).__init__(*args, **kwargs)
 #elf.required = self.discriminator or self.required

 #ef format(self, value):
 #ry:
 #eturn str(value)
 #xcept ValueError as ve:
 #aise MarshallingError(ve)

 #ef schema(self):
 #num = self._v("enum")
 #chema = super(String, self).schema()
 #f enum:
 #chema.update(enum=enum)
 #f enum and schema["example"] is None:
 #chema["example"] = enum[0]
 #eturn schema


class Integer(NumberMixin, Raw):
 #""
 #ield for outputting an integer value.

 #param int default: The default value for the field, if no value is specified.
 #""

 #_schema_type__ = "integer"

 #ef format(self, value):
 #ry:
 #f value is None:
 #eturn self.default
 #eturn int(value)
 #xcept (ValueError, TypeError) as ve:
 #aise MarshallingError(ve)


class Float(NumberMixin, Raw):
 #""
 # double as IEEE-754 double precision.

 #x : 3.141592653589793 3.1415926535897933e-06 3.141592653589793e+24 nan inf -inf
 #""

 #ef format(self, value):
 #ry:
 #f value is None:
 #eturn self.default
 #eturn float(value)
 #xcept (ValueError, TypeError) as ve:
 #aise MarshallingError(ve)


class Arbitrary(NumberMixin, Raw):
 #""
 # floating point number with an arbitrary precision.

 #x: 634271127864378216478362784632784678324.23432
 #""

 #ef format(self, value):
 #eturn str(Decimal(value))


ZERO = Decimal()


class Fixed(NumberMixin, Raw):
 #""
 # decimal number with a fixed precision.
 #""

 #ef __init__(self, decimals=5, **kwargs):
 #uper(Fixed, self).__init__(**kwargs)
 #elf.precision = Decimal("0." + "0" * (decimals - 1) + "1")

 #ef format(self, value):
 #value = Decimal(value)
 #f not dvalue.is_normal() and dvalue != ZERO:
 #aise MarshallingError("Invalid Fixed precision number.")
 #eturn str(dvalue.quantize(self.precision, rounding=ROUND_HALF_EVEN))


class Boolean(Raw):
 #""
 #ield for outputting a boolean value.

 #mpty collections such as ``""``, ``{}``, ``[]``, etc. will be converted to ``False``.
 #""

 #_schema_type__ = "boolean"

 #ef format(self, value):
 #eturn boolean(value)


class DateTime(MinMaxMixin, Raw):
 #""
 #eturn a formatted datetime string in UTC. Supported formats are RFC 822 and ISO 8601.

 #ee :func:`email.utils.formatdate` for more info on the RFC 822 format.

 #ee :meth:`datetime.datetime.isoformat` for more info on the ISO 8601 format.

 #param str dt_format: ``rfc822`` or ``iso8601``
 #""

 #_schema_type__ = "string"
 #_schema_format__ = "date-time"

 #ef __init__(self, dt_format="iso8601", **kwargs):
 #uper(DateTime, self).__init__(**kwargs)
 #elf.dt_format = dt_format

 #ef parse(self, value):
 #f value is None:
 #eturn None
 #lif isinstance(value, str):
 #arser = (
 #atetime_from_iso8601
 #f self.dt_format == "iso8601"
 #lse datetime_from_rfc822
 #
 #eturn parser(value)
 #lif isinstance(value, datetime):
 #eturn value
 #lif isinstance(value, date):
 #eturn datetime(value.year, value.month, value.day)
 #lse:
 #aise ValueError("Unsupported DateTime format")

 #ef format(self, value):
 #ry:
 #alue = self.parse(value)
 #f self.dt_format == "iso8601":
 #eturn self.format_iso8601(value)
 #lif self.dt_format == "rfc822":
 #eturn self.format_rfc822(value)
 #lse:
 #aise MarshallingError("Unsupported date format %s" % self.dt_format)
 #xcept (AttributeError, ValueError) as e:
 #aise MarshallingError(e)

 #ef format_rfc822(self, dt):
 #""
 #urn a datetime object into a formatted date.

 #param datetime dt: The datetime to transform
 #return: A RFC 822 formatted date string
 #""
 #eturn formatdate(timegm(dt.utctimetuple()))

 #ef format_iso8601(self, dt):
 #""
 #urn a datetime object into an ISO8601 formatted date.

 #param datetime dt: The datetime to transform
 #return: A ISO 8601 formatted date string
 #""
 #eturn dt.isoformat()

 #ef _for_schema(self, name):
 #alue = self.parse(self._v(name))
 #eturn self.format(value) if value else None

 #ef schema(self):
 #chema = super(DateTime, self).schema()
 #chema["default"] = self._for_schema("default")
 #chema["minimum"] = self._for_schema("minimum")
 #chema["maximum"] = self._for_schema("maximum")
 #eturn schema


class Date(DateTime):
 #""
 #eturn a formatted date string in UTC in ISO 8601.

 #ee :meth:`datetime.date.isoformat` for more info on the ISO 8601 format.
 #""

 #_schema_format__ = "date"

 #ef __init__(self, **kwargs):
 #wargs.pop("dt_format", None)
 #uper(Date, self).__init__(dt_format="iso8601", **kwargs)

 #ef parse(self, value):
 #f value is None:
 #eturn None
 #lif isinstance(value, str):
 #eturn date_from_iso8601(value)
 #lif isinstance(value, datetime):
 #eturn value.date()
 #lif isinstance(value, date):
 #eturn value
 #lse:
 #aise ValueError("Unsupported Date format")


class Url(StringMixin, Raw):
 #""
 # string representation of a Url

 #param str endpoint: Endpoint name. If endpoint is ``None``, ``request.endpoint`` is used instead
 #param bool absolute: If ``True``, ensures that the generated urls will have the hostname included
 #param str scheme: URL scheme specifier (e.g. ``http``, ``https``)
 #""

 #ef __init__(self, endpoint=None, absolute=False, scheme=None, **kwargs):
 #uper(Url, self).__init__(**kwargs)
 #elf.endpoint = endpoint
 #elf.absolute = absolute
 #elf.scheme = scheme

 #ef output(self, key, obj, **kwargs):
 #ry:
 #ata = to_marshallable_type(obj)
 #ndpoint = self.endpoint if self.endpoint is not None else request.endpoint
 # = urlparse(url_for(endpoint, _external=self.absolute, **data))
 #f self.absolute:
 #cheme = self.scheme if self.scheme is not None else o.scheme
 #eturn urlunparse((scheme, o.netloc, o.path, "", "", ""))
 #eturn urlunparse(("", "", o.path, "", "", ""))
 #xcept TypeError as te:
 #aise MarshallingError(te)


class FormattedString(StringMixin, Raw):
 #""
 #ormattedString is used to interpolate other values from
 #he response into this field. The syntax for the source string is
 #he same as the string :meth:`~str.format` method from the python
 #tdlib.

 #x::

 #ields = {
 #name': fields.String,
 #greeting': fields.FormattedString("Hello {name}")
 #
 #ata = {
 #name': 'Doug',
 #
 #arshal(data, fields)

 #param str src_str: the string to format with the other values from the response.
 #""

 #ef __init__(self, src_str, **kwargs):
 #uper(FormattedString, self).__init__(**kwargs)
 #elf.src_str = str(src_str)

 #ef output(self, key, obj, **kwargs):
 #ry:
 #ata = to_marshallable_type(obj)
 #eturn self.src_str.format(**data)
 #xcept (TypeError, IndexError) as error:
 #aise MarshallingError(error)


class ClassName(String):
 #""
 #eturn the serialized object class name as string.

 #param bool dash: If `True`, transform CamelCase to kebab_case.
 #""

 #ef __init__(self, dash=False, **kwargs):
 #uper(ClassName, self).__init__(**kwargs)
 #elf.dash = dash

 #ef output(self, key, obj, **kwargs):
 #lassname = obj.__class__.__name__
 #f classname == "dict":
 #eturn "object"
 #eturn camel_to_dash(classname) if self.dash else classname


class Polymorph(Nested):
 #""
 # Nested field handling inheritance.

 #llows you to specify a mapping between Python classes and fields specifications.

 #. code-block:: python

 #apping = {
 #hild1: child1_fields,
 #hild2: child2_fields,
 #

 #ields = api.model('Thing', {
 #wner: fields.Polymorph(mapping)
 #)

 #param dict mapping: Maps classes to their model/fields representation
 #""

 #ef __init__(self, mapping, required=False, **kwargs):
 #elf.mapping = mapping
 #arent = self.resolve_ancestor(list(mapping.values()))
 #uper(Polymorph, self).__init__(parent, allow_null=not required, **kwargs)

 #ef output(self, key, obj, ordered=False, **kwargs):
        # Copied from upstream NestedField
 #alue = get_value(key if self.attribute is None else self.attribute, obj)
 #f value is None:
 #f self.allow_null:
 #eturn None
 #lif self.default is not None:
 #eturn self.default

        # Handle mappings
 #f not hasattr(value, "__class__"):
 #aise ValueError("Polymorph field only accept class instances")

 #andidates = [
 #ields for cls, fields in self.mapping.items() if type(value) == cls
 #

 #f len(candidates) <= 0:
 #aise ValueError("Unknown class: " + value.__class__.__name__)
 #lif len(candidates) > 1:
 #aise ValueError(
 #Unable to determine a candidate for: " + value.__class__.__name__
 #
 #lse:
 #eturn marshal(
 #alue, candidates[0].resolved, mask=self.mask, ordered=ordered
 #

 #ef resolve_ancestor(self, models):
 #""
 #esolve the common ancestor for all models.

 #ssume there is only one common ancestor.
 #""
 #ncestors = [m.ancestors for m in models]
 #andidates = set.intersection(*ancestors)
 #f len(candidates) != 1:
 #ield_names = [f.name for f in models]
 #aise ValueError(
 #Unable to determine the common ancestor for: " + ", ".join(field_names)
 #

 #arent_name = candidates.pop()
 #eturn models[0].get_parent(parent_name)

 #ef clone(self, mask=None):
 #ata = self.__dict__.copy()
 #apping = data.pop("mapping")
 #or field in ("allow_null", "model"):
 #ata.pop(field, None)

 #ata["mask"] = mask
 #eturn Polymorph(mapping, **data)


class Wildcard(Raw):
 #""
 #ield for marshalling list of "unkown" fields.

 #param cls_or_instance: The field type the list will contain.
 #""

 #xclude = set()
    # cache the flat object
 #flat = None
 #obj = None
 #cache = set()
 #last = None

 #ef __init__(self, cls_or_instance, **kwargs):
 #uper(Wildcard, self).__init__(**kwargs)
 #rror_msg = "The type of the wildcard elements must be a subclass of fields.Raw"
 #f isinstance(cls_or_instance, type):
 #f not issubclass(cls_or_instance, Raw):
 #aise MarshallingError(error_msg)
 #elf.container = cls_or_instance()
 #lse:
 #f not isinstance(cls_or_instance, Raw):
 #aise MarshallingError(error_msg)
 #elf.container = cls_or_instance

 #ef _flatten(self, obj):
 #f obj is None:
 #eturn None
 #f obj == self._obj and self._flat is not None:
 #eturn self._flat
 #f isinstance(obj, dict):
 #elf._flat = [x for x in obj.items()]
 #lse:

 #ef __match_attributes(attribute):
 #ttr_name, attr_obj = attribute
 #f inspect.isroutine(attr_obj) or (
 #ttr_name.startswith("__") and attr_name.endswith("__")
 #:
 #eturn False
 #eturn True

 #ttributes = inspect.getmembers(obj)
 #elf._flat = [x for x in attributes if __match_attributes(x)]

 #elf._cache = set()
 #elf._obj = obj
 #eturn self._flat

 #property
 #ef key(self):
 #eturn self._last

 #ef reset(self):
 #elf.exclude = set()
 #elf._flat = None
 #elf._obj = None
 #elf._cache = set()
 #elf._last = None

 #ef output(self, key, obj, ordered=False):
 #alue = None
 #eg = fnmatch.translate(key)

 #f self._flatten(obj):
 #hile True:
 #ry:
                    # we are using pop() so that we don't
                    # loop over the whole object every time dropping the
                    # complexity to O(n)
 #f ordered:
                        # Get first element if respecting order
 #objkey, val) = self._flat.pop(0)
 #lse:
                        # Previous default retained
 #objkey, val) = self._flat.pop()
 #f (
 #bjkey not in self._cache
 #nd objkey not in self.exclude
 #nd re.match(reg, objkey, re.IGNORECASE)
 #:
 #alue = val
 #elf._cache.add(objkey)
 #elf._last = objkey
 #reak
 #xcept IndexError:
 #reak

 #f value is None:
 #f self.default is not None:
 #eturn self.container.format(self.default)
 #eturn None

 #f isinstance(self.container, Nested):
 #eturn marshal(
 #alue,
 #elf.container.nested,
 #kip_none=self.container.skip_none,
 #rdered=ordered,
 #
 #eturn self.container.format(value)

 #ef schema(self):
 #chema = super(Wildcard, self).schema()
 #chema["type"] = "object"
 #chema["additionalProperties"] = self.container.__schema__
 #eturn schema

 #ef clone(self):
 #wargs = self.__dict__.copy()
 #odel = kwargs.pop("container")
 #eturn self.__class__(model, **kwargs)
