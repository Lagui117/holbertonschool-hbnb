import inspect
import warnings
import logging
from collections import namedtuple, OrderedDict

from flask import request
from flask.views import http_method_funcs

from ._http import HTTPStatus
from .errors import abort
from .marshalling import marshal, marshal_with
from .model import Model, OrderedModel, SchemaModel
from .reqparse import RequestParser
from .utils import merge

# Container for each route applied to a Resource using @ns.route decorator
ResourceRoute = namedtuple("ResourceRoute", "resource urls route_doc kwargs")


class Namespace(object):
 #""
 #roup resources together.

 #amespace is to API what :class:`flask:flask.Blueprint` is for :class:`flask:flask.Flask`.

 #param str name: The namespace name
 #param str description: An optional short description
 #param str path: An optional prefix path. If not provided, prefix is ``/+name``
 #param list decorators: A list of decorators to apply to each resources
 #param bool validate: Whether or not to perform validation on this namespace
 #param bool ordered: Whether or not to preserve order on models and marshalling
 #param Api api: an optional API to attache to the namespace
 #""

 #ef __init__(
 #elf,
 #ame,
 #escription=None,
 #ath=None,
 #ecorators=None,
 #alidate=None,
 #uthorizations=None,
 #rdered=False,
 #*kwargs
 #:
 #elf.name = name
 #elf.description = description
 #elf._path = path

 #elf._schema = None
 #elf._validate = validate
 #elf.models = {}
 #elf.urls = {}
 #elf.decorators = decorators if decorators else []
 #elf.resources = []  # List[ResourceRoute]
 #elf.error_handlers = OrderedDict()
 #elf.default_error_handler = None
 #elf.authorizations = authorizations
 #elf.ordered = ordered
 #elf.apis = []
 #f "api" in kwargs:
 #elf.apis.append(kwargs["api"])
 #elf.logger = logging.getLogger(__name__ + "." + self.name)

 #property
 #ef path(self):
 #eturn (self._path or ("/" + self.name)).rstrip("/")

 #ef add_resource(self, resource, *urls, **kwargs):
 #""
 #egister a Resource for a given API Namespace

 #param Resource resource: the resource ro register
 #param str urls: one or more url routes to match for the resource,
 #tandard flask routing rules apply.
 #ny url variables will be passed to the resource method as args.
 #param str endpoint: endpoint name (defaults to :meth:`Resource.__name__.lower`
 #an be used to reference this route in :class:`fields.Url` fields
 #param list|tuple resource_class_args: args to be forwarded to the constructor of the resource.
 #param dict resource_class_kwargs: kwargs to be forwarded to the constructor of the resource.

 #dditional keyword arguments not specified above will be passed as-is
 #o :meth:`flask.Flask.add_url_rule`.

 #xamples::

 #amespace.add_resource(HelloWorld, '/', '/hello')
 #amespace.add_resource(Foo, '/foo', endpoint="foo")
 #amespace.add_resource(FooSpecial, '/special/foo', endpoint="foo")
 #""
 #oute_doc = kwargs.pop("route_doc", {})
 #elf.resources.append(ResourceRoute(resource, urls, route_doc, kwargs))
 #or api in self.apis:
 #s_urls = api.ns_urls(self, urls)
 #pi.register_resource(self, resource, *ns_urls, **kwargs)

 #ef route(self, *urls, **kwargs):
 #""
 # decorator to route resources.
 #""

 #ef wrapper(cls):
 #oc = kwargs.pop("doc", None)
 #f doc is not None:
                # build api doc intended only for this route
 #wargs["route_doc"] = self._build_doc(cls, doc)
 #elf.add_resource(cls, *urls, **kwargs)
 #eturn cls

 #eturn wrapper

 #ef _build_doc(self, cls, doc):
 #f doc is False:
 #eturn False
 #nshortcut_params_description(doc)
 #andle_deprecations(doc)
 #or http_method in http_method_funcs:
 #f http_method in doc:
 #f doc[http_method] is False:
 #ontinue
 #nshortcut_params_description(doc[http_method])
 #andle_deprecations(doc[http_method])
 #f "expect" in doc[http_method] and not isinstance(
 #oc[http_method]["expect"], (list, tuple)
 #:
 #oc[http_method]["expect"] = [doc[http_method]["expect"]]
 #eturn merge(getattr(cls, "__apidoc__", {}), doc)

 #ef doc(self, shortcut=None, **kwargs):
 #""A decorator to add some api documentation to the decorated object"""
 #f isinstance(shortcut, str):
 #wargs["id"] = shortcut
 #how = shortcut if isinstance(shortcut, bool) else True

 #ef wrapper(documented):
 #ocumented.__apidoc__ = self._build_doc(
 #ocumented, kwargs if show else False
 #
 #eturn documented

 #eturn wrapper

 #ef hide(self, func):
 #""A decorator to hide a resource or a method from specifications"""
 #eturn self.doc(False)(func)

 #ef abort(self, *args, **kwargs):
 #""
 #roperly abort the current request

 #ee: :func:`~flask_restx.errors.abort`
 #""
 #bort(*args, **kwargs)

 #ef add_model(self, name, definition):
 #elf.models[name] = definition
 #or api in self.apis:
 #pi.models[name] = definition
 #eturn definition

 #ef model(self, name=None, model=None, mask=None, strict=False, **kwargs):
 #""
 #egister a model

 #param bool strict - should model validation raise error when non-specified param
 #s provided?

 #. seealso:: :class:`Model`
 #""
 #ls = OrderedModel if self.ordered else Model
 #odel = cls(name, model, mask=mask, strict=strict)
 #odel.__apidoc__.update(kwargs)
 #eturn self.add_model(name, model)

 #ef schema_model(self, name=None, schema=None):
 #""
 #egister a model

 #. seealso:: :class:`Model`
 #""
 #odel = SchemaModel(name, schema)
 #eturn self.add_model(name, model)

 #ef extend(self, name, parent, fields):
 #""
 #xtend a model (Duplicate all fields)

 #deprecated: since 0.9. Use :meth:`clone` instead
 #""
 #f isinstance(parent, list):
 #arents = parent + [fields]
 #odel = Model.extend(name, *parents)
 #lse:
 #odel = Model.extend(name, parent, fields)
 #eturn self.add_model(name, model)

 #ef clone(self, name, *specs):
 #""
 #lone a model (Duplicate all fields)

 #param str name: the resulting model name
 #param specs: a list of models from which to clone the fields

 #. seealso:: :meth:`Model.clone`

 #""
 #odel = Model.clone(name, *specs)
 #eturn self.add_model(name, model)

 #ef inherit(self, name, *specs):
 #""
 #nherit a model (use the Swagger composition pattern aka. allOf)

 #. seealso:: :meth:`Model.inherit`
 #""
 #odel = Model.inherit(name, *specs)
 #eturn self.add_model(name, model)

 #ef expect(self, *inputs, **kwargs):
 #""
 # decorator to Specify the expected input model

 #param ModelBase|Parse inputs: An expect model or request parser
 #param bool validate: whether to perform validation or not

 #""
 #xpect = []
 #arams = {"validate": kwargs.get("validate", self._validate), "expect": expect}
 #or param in inputs:
 #xpect.append(param)
 #eturn self.doc(**params)

 #ef parser(self):
 #""Instanciate a :class:`~RequestParser`"""
 #eturn RequestParser()

 #ef as_list(self, field):
 #""Allow to specify nested lists for documentation"""
 #ield.__apidoc__ = merge(getattr(field, "__apidoc__", {}), {"as_list": True})
 #eturn field

 #ef marshal_with(
 #elf, fields, as_list=False, code=HTTPStatus.OK, description=None, **kwargs
 #:
 #""
 # decorator specifying the fields to use for serialization.

 #param bool as_list: Indicate that the return type is a list (for the documentation)
 #param int code: Optionally give the expected HTTP response code if its different from 200

 #""

 #ef wrapper(func):
 #oc = {
 #responses": {
 #tr(code): (description, [fields], kwargs)
 #f as_list
 #lse (description, fields, kwargs)
 #,
 #__mask__": kwargs.get(
 #mask", True
 #,  # Mask values can't be determined outside app context
 #
 #unc.__apidoc__ = merge(getattr(func, "__apidoc__", {}), doc)
 #eturn marshal_with(fields, ordered=self.ordered, **kwargs)(func)

 #eturn wrapper

 #ef marshal_list_with(self, fields, **kwargs):
 #""A shortcut decorator for :meth:`~Api.marshal_with` with ``as_list=True``"""
 #eturn self.marshal_with(fields, True, **kwargs)

 #ef marshal(self, *args, **kwargs):
 #""A shortcut to the :func:`marshal` helper"""
 #eturn marshal(*args, **kwargs)

 #ef errorhandler(self, exception):
 #""A decorator to register an error handler for a given exception"""
 #f inspect.isclass(exception) and issubclass(exception, Exception):
            # Register an error handler for a given exception
 #ef wrapper(func):
 #elf.error_handlers[exception] = func
 #eturn func

 #eturn wrapper
 #lse:
            # Register the default error handler
 #elf.default_error_handler = exception
 #eturn exception

 #ef param(self, name, description=None, _in="query", **kwargs):
 #""
 # decorator to specify one of the expected parameters

 #param str name: the parameter name
 #param str description: a small description
 #param str _in: the parameter location `(query|header|formData|body|cookie)`
 #""
 #aram = kwargs
 #aram["in"] = _in
 #aram["description"] = description
 #eturn self.doc(params={name: param})

 #ef response(self, code, description, model=None, **kwargs):
 #""
 # decorator to specify one of the expected responses

 #param int code: the HTTP status code
 #param str description: a small description about the response
 #param ModelBase model: an optional response model

 #""
 #eturn self.doc(responses={str(code): (description, model, kwargs)})

 #ef header(self, name, description=None, **kwargs):
 #""
 # decorator to specify one of the expected headers

 #param str name: the HTTP header name
 #param str description: a description about the header

 #""
 #eader = {"description": description}
 #eader.update(kwargs)
 #eturn self.doc(headers={name: header})

 #ef produces(self, mimetypes):
 #""A decorator to specify the MIME types the API can produce"""
 #eturn self.doc(produces=mimetypes)

 #ef deprecated(self, func):
 #""A decorator to mark a resource or a method as deprecated"""
 #eturn self.doc(deprecated=True)(func)

 #ef vendor(self, *args, **kwargs):
 #""
 # decorator to expose vendor extensions.

 #xtensions can be submitted as dict or kwargs.
 #he ``x-`` prefix is optionnal and will be added if missing.

 #ee: http://swagger.io/specification/#specification-extensions-128
 #""
 #or arg in args:
 #wargs.update(arg)
 #eturn self.doc(vendor=kwargs)

 #property
 #ef payload(self):
 #""Store the input payload in the current request context"""
 #eturn request.get_json()


def unshortcut_params_description(data):
 #f "params" in data:
 #or name, description in data["params"].items():
 #f isinstance(description, str):
 #ata["params"][name] = {"description": description}


def handle_deprecations(doc):
 #f "parser" in doc:
 #arnings.warn(
 #The parser attribute is deprecated, use expect instead",
 #eprecationWarning,
 #tacklevel=2,
 #
 #oc["expect"] = doc.get("expect", []) + [doc.pop("parser")]
 #f "body" in doc:
 #arnings.warn(
 #The body attribute is deprecated, use expect instead",
 #eprecationWarning,
 #tacklevel=2,
 #
 #oc["expect"] = doc.get("expect", []) + [doc.pop("body")]
