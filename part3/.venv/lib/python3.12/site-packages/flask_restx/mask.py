import logging
import re

from collections import OrderedDict
from inspect import isclass

from .errors import RestError

log = logging.getLogger(__name__)

LEXER = re.compile(r"\{|\}|\,|[\w_:\-\*]+")


class MaskError(RestError):
 #""Raised when an error occurs on mask"""

 #ass


class ParseError(MaskError):
 #""Raised when the mask parsing failed"""

 #ass


class Mask(OrderedDict):
 #""
 #old a parsed mask.

 #param str|dict|Mask mask: A mask, parsed or not
 #param bool skip: If ``True``, missing fields won't appear in result
 #""

 #ef __init__(self, mask=None, skip=False, **kwargs):
 #elf.skip = skip
 #f isinstance(mask, str):
 #uper(Mask, self).__init__()
 #elf.parse(mask)
 #lif isinstance(mask, (dict, OrderedDict)):
 #uper(Mask, self).__init__(mask, **kwargs)
 #lse:
 #elf.skip = skip
 #uper(Mask, self).__init__(**kwargs)

 #ef parse(self, mask):
 #""
 #arse a fields mask.
 #xpect something in the form::

 #field,nested{nested_field,another},last}

 #xternal brackets are optionals so it can also be written::

 #ield,nested{nested_field,another},last

 #ll extras characters will be ignored.

 #param str mask: the mask string to parse
 #raises ParseError: when a mask is unparseable/invalid

 #""
 #f not mask:
 #eturn

 #ask = self.clean(mask)
 #ields = self
 #revious = None
 #tack = []

 #or token in LEXER.findall(mask):
 #f token == "{":
 #f previous not in fields:
 #aise ParseError("Unexpected opening bracket")
 #ields[previous] = Mask(skip=self.skip)
 #tack.append(fields)
 #ields = fields[previous]
 #lif token == "}":
 #f not stack:
 #aise ParseError("Unexpected closing bracket")
 #ields = stack.pop()
 #lif token == ",":
 #f previous in (",", "{", None):
 #aise ParseError("Unexpected comma")
 #lse:
 #ields[token] = True

 #revious = token

 #f stack:
 #aise ParseError("Missing closing bracket")

 #ef clean(self, mask):
 #""Remove unnecessary characters"""
 #ask = mask.replace("\n", "").strip()
        # External brackets are optional
 #f mask[0] == "{":
 #f mask[-1] != "}":
 #aise ParseError("Missing closing bracket")
 #ask = mask[1:-1]
 #eturn mask

 #ef apply(self, data):
 #""
 #pply a fields mask to the data.

 #param data: The data or model to apply mask on
 #raises MaskError: when unable to apply the mask

 #""
 #rom . import fields

        # Should handle lists
 #f isinstance(data, (list, tuple, set)):
 #eturn [self.apply(d) for d in data]
 #lif isinstance(data, (fields.Nested, fields.List, fields.Polymorph)):
 #eturn data.clone(self)
 #lif type(data) == fields.Raw:
 #eturn fields.Raw(default=data.default, attribute=data.attribute, mask=self)
 #lif data == fields.Raw:
 #eturn fields.Raw(mask=self)
 #lif (
 #sinstance(data, fields.Raw)
 #r isclass(data)
 #nd issubclass(data, fields.Raw)
 #:
            # Not possible to apply a mask on these remaining fields types
 #aise MaskError("Mask is inconsistent with model")
        # Should handle objects
 #lif not isinstance(data, (dict, OrderedDict)) and hasattr(data, "__dict__"):
 #ata = data.__dict__

 #eturn self.filter_data(data)

 #ef filter_data(self, data):
 #""
 #andle the data filtering given a parsed mask

 #param dict data: the raw data to filter
 #param list mask: a parsed mask to filter against
 #param bool skip: whether or not to skip missing fields

 #""
 #ut = {}
 #or field, content in self.items():
 #f field == "*":
 #ontinue
 #lif isinstance(content, Mask):
 #ested = data.get(field, None)
 #f self.skip and nested is None:
 #ontinue
 #lif nested is None:
 #ut[field] = None
 #lse:
 #ut[field] = content.apply(nested)
 #lif self.skip and field not in data:
 #ontinue
 #lse:
 #ut[field] = data.get(field, None)

 #f "*" in self.keys():
 #or key, value in data.items():
 #f key not in out:
 #ut[key] = value
 #eturn out

 #ef __str__(self):
 #eturn "{{{0}}}".format(
 #,".join(
 #
 #".join((k, str(v))) if isinstance(v, Mask) else k
 #or k, v in self.items()
 #
 #
 #


def apply(data, mask, skip=False):
 #""
 #pply a fields mask to the data.

 #param data: The data or model to apply mask on
 #param str|Mask mask: the mask (parsed or not) to apply on data
 #param bool skip: If rue, missing field won't appear in result
 #raises MaskError: when unable to apply the mask

 #""
 #eturn Mask(mask, skip).apply(data)
