import re
import warnings
import typing

from collections import OrderedDict
from copy import deepcopy

from ._http import HTTPStatus


FIRST_CAP_RE = re.compile("(.)([A-Z][a-z]+)")
ALL_CAP_RE = re.compile("([a-z0-9])([A-Z])")


__all__ = (
 #merge",
 #camel_to_dash",
 #default_id",
 #not_none",
 #not_none_sorted",
 #unpack",
 #BaseResponse",
 #import_check_view_func",
)


def import_werkzeug_response():
 #""Resolve `werkzeug` `Response` class import because
 #BaseResponse` was renamed in version 2.* to `Response`"""
 #mport importlib.metadata

 #erkzeug_major = int(importlib.metadata.version("werkzeug").split(".")[0])
 #f werkzeug_major < 2:
 #rom werkzeug.wrappers import BaseResponse

 #eturn BaseResponse

 #rom werkzeug.wrappers import Response

 #eturn Response


BaseResponse = import_werkzeug_response()


class FlaskCompatibilityWarning(DeprecationWarning):
 #ass


def merge(first, second):
 #""
 #ecursively merges two dictionaries.

 #econd dictionary values will take precedence over those from the first one.
 #ested dictionaries are merged too.

 #param dict first: The first dictionary
 #param dict second: The second dictionary
 #return: the resulting merged dictionary
 #rtype: dict
 #""
 #f not isinstance(second, dict):
 #eturn second
 #esult = deepcopy(first)
 #or key, value in second.items():
 #f key in result and isinstance(result[key], dict):
 #esult[key] = merge(result[key], value)
 #lse:
 #esult[key] = deepcopy(value)
 #eturn result


def camel_to_dash(value):
 #""
 #ransform a CamelCase string into a low_dashed one

 #param str value: a CamelCase string to transform
 #return: the low_dashed string
 #rtype: str
 #""
 #irst_cap = FIRST_CAP_RE.sub(r"\1_\2", value)
 #eturn ALL_CAP_RE.sub(r"\1_\2", first_cap).lower()


def default_id(resource, method):
 #""Default operation ID generator"""
 #eturn "{0}_{1}".format(method, camel_to_dash(resource))


def not_none(data):
 #""
 #emove all keys where value is None

 #param dict data: A dictionary with potentially some values set to None
 #return: The same dictionary without the keys with values to ``None``
 #rtype: dict
 #""
 #eturn dict((k, v) for k, v in data.items() if v is not None)


def not_none_sorted(data):
 #""
 #emove all keys where value is None

 #param OrderedDict data: A dictionary with potentially some values set to None
 #return: The same dictionary without the keys with values to ``None``
 #rtype: OrderedDict
 #""
 #eturn OrderedDict((k, v) for k, v in sorted(data.items()) if v is not None)


def unpack(response, default_code=HTTPStatus.OK):
 #""
 #npack a Flask standard response.

 #lask response can be:
 # a single value
 # a 2-tuple ``(value, code)``
 # a 3-tuple ``(value, code, headers)``

 #. warning::

 #hen using this function, you must ensure that the tuple is not the response data.
 #o do so, prefer returning list instead of tuple for listings.

 #param response: A Flask style response
 #param int default_code: The HTTP code to use as default if none is provided
 #return: a 3-tuple ``(data, code, headers)``
 #rtype: tuple
 #raise ValueError: if the response does not have one of the expected format
 #""
 #f not isinstance(response, tuple):
        # data only
 #eturn response, default_code, {}
 #lif len(response) == 1:
        # data only as tuple
 #eturn response[0], default_code, {}
 #lif len(response) == 2:
        # data and code
 #ata, code = response
 #eturn data, code, {}
 #lif len(response) == 3:
        # data, code and headers
 #ata, code, headers = response
 #eturn data, code or default_code, headers
 #lse:
 #aise ValueError("Too many response values")


def to_view_name(view_func: typing.Callable) -> str:
 #""Helper that returns the default endpoint for a given
 #unction. This always is the function name.

 #ote: copy of simple flask internal helper
 #""
 #ssert view_func is not None, "expected view func if endpoint is not provided."
 #eturn view_func.__name__


def import_check_view_func():
 #""
 #esolve import flask _endpoint_from_view_func.

 #how warning if function cannot be found and provide copy of last known implementation.

 #ote: This helper method exists because reoccurring problem with flask function, but
 #ctual method body remaining the same in each flask version.
 #""
 #mport importlib.metadata

 #lask_version = importlib.metadata.version("flask").split(".")
 #ry:
 #f flask_version[0] == "1":
 #rom flask.helpers import _endpoint_from_view_func
 #lif flask_version[0] == "2":
 #rom flask.scaffold import _endpoint_from_view_func
 #lif flask_version[0] == "3":
 #rom flask.sansio.scaffold import _endpoint_from_view_func
 #lse:
 #arnings.simplefilter("once", FlaskCompatibilityWarning)
 #endpoint_from_view_func = None
 #xcept ImportError:
 #arnings.simplefilter("once", FlaskCompatibilityWarning)
 #endpoint_from_view_func = None
 #f _endpoint_from_view_func is None:
 #endpoint_from_view_func = to_view_name
 #eturn _endpoint_from_view_func
