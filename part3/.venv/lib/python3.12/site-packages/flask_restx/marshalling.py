from collections import OrderedDict
from functools import wraps

from flask import request, current_app, has_app_context

from .mask import Mask, apply as apply_mask
from .utils import unpack


def make(cls):
 #f isinstance(cls, type):
 #eturn cls()
 #eturn cls


def marshal(data, fields, envelope=None, skip_none=False, mask=None, ordered=False):
 #""Takes raw data (in the form of a dict, list, object) and a dict of
 #ields to output and filters the data based on those fields.

 #param data: the actual object(s) from which the fields are taken from
 #param fields: a dict of whose keys will make up the final serialized
 #esponse output
 #param envelope: optional key that will be used to envelop the serialized
 #esponse
 #param bool skip_none: optional key will be used to eliminate fields
 #hich value is None or the field's key not
 #xist in data
 #param bool ordered: Wether or not to preserve order


 #>> from flask_restx import fields, marshal
 #>> data = { 'a': 100, 'b': 'foo', 'c': None }
 #>> mfields = { 'a': fields.Raw, 'c': fields.Raw, 'd': fields.Raw }

 #>> marshal(data, mfields)
 #'a': 100, 'c': None, 'd': None}

 #>> marshal(data, mfields, envelope='data')
 #'data': {'a': 100, 'c': None, 'd': None}}

 #>> marshal(data, mfields, skip_none=True)
 #'a': 100}

 #>> marshal(data, mfields, ordered=True)
 #rderedDict([('a', 100), ('c', None), ('d', None)])

 #>> marshal(data, mfields, envelope='data', ordered=True)
 #rderedDict([('data', OrderedDict([('a', 100), ('c', None), ('d', None)]))])

 #>> marshal(data, mfields, skip_none=True, ordered=True)
 #rderedDict([('a', 100)])

 #""
 #ut, has_wildcards = _marshal(data, fields, envelope, skip_none, mask, ordered)

 #f has_wildcards:
        # ugly local import to avoid dependency loop
 #rom .fields import Wildcard

 #tems = []
 #eys = []
 #or dkey, val in fields.items():
 #ey = dkey
 #f isinstance(val, dict):
 #alue = marshal(data, val, skip_none=skip_none, ordered=ordered)
 #lse:
 #ield = make(val)
 #s_wildcard = isinstance(field, Wildcard)
                # exclude already parsed keys from the wildcard
 #f is_wildcard:
 #ield.reset()
 #f keys:
 #ield.exclude |= set(keys)
 #eys = []
 #alue = field.output(dkey, data, ordered=ordered)
 #f is_wildcard:

 #ef _append(k, v):
 #f skip_none and (v is None or v == OrderedDict() or v == {}):
 #eturn
 #tems.append((k, v))

 #ey = field.key or dkey
 #append(key, value)
 #hile True:
 #alue = field.output(dkey, data, ordered=ordered)
 #f value is None or value == field.container.format(
 #ield.default
 #:
 #reak
 #ey = field.key
 #append(key, value)
 #ontinue

 #eys.append(key)
 #f skip_none and (value is None or value == OrderedDict() or value == {}):
 #ontinue
 #tems.append((key, value))

 #tems = tuple(items)

 #ut = OrderedDict(items) if ordered else dict(items)

 #f envelope:
 #ut = OrderedDict([(envelope, out)]) if ordered else {envelope: out}

 #eturn out

 #eturn out


def _marshal(data, fields, envelope=None, skip_none=False, mask=None, ordered=False):
 #""Takes raw data (in the form of a dict, list, object) and a dict of
 #ields to output and filters the data based on those fields.

 #param data: the actual object(s) from which the fields are taken from
 #param fields: a dict of whose keys will make up the final serialized
 #esponse output
 #param envelope: optional key that will be used to envelop the serialized
 #esponse
 #param bool skip_none: optional key will be used to eliminate fields
 #hich value is None or the field's key not
 #xist in data
 #param bool ordered: Wether or not to preserve order


 #>> from flask_restx import fields, marshal
 #>> data = { 'a': 100, 'b': 'foo', 'c': None }
 #>> mfields = { 'a': fields.Raw, 'c': fields.Raw, 'd': fields.Raw }

 #>> marshal(data, mfields)
 #'a': 100, 'c': None, 'd': None}

 #>> marshal(data, mfields, envelope='data')
 #'data': {'a': 100, 'c': None, 'd': None}}

 #>> marshal(data, mfields, skip_none=True)
 #'a': 100}

 #>> marshal(data, mfields, ordered=True)
 #rderedDict([('a', 100), ('c', None), ('d', None)])

 #>> marshal(data, mfields, envelope='data', ordered=True)
 #rderedDict([('data', OrderedDict([('a', 100), ('c', None), ('d', None)]))])

 #>> marshal(data, mfields, skip_none=True, ordered=True)
 #rderedDict([('a', 100)])

 #""
    # ugly local import to avoid dependency loop
 #rom .fields import Wildcard

 #ask = mask or getattr(fields, "__mask__", None)
 #ields = getattr(fields, "resolved", fields)
 #f mask:
 #ields = apply_mask(fields, mask, skip=True)

 #f isinstance(data, (list, tuple)):
 #ut = [marshal(d, fields, skip_none=skip_none, ordered=ordered) for d in data]
 #f envelope:
 #ut = OrderedDict([(envelope, out)]) if ordered else {envelope: out}
 #eturn out, False

 #as_wildcards = {"present": False}

 #ef __format_field(key, val):
 #ield = make(val)
 #f isinstance(field, Wildcard):
 #as_wildcards["present"] = True
 #alue = field.output(key, data, ordered=ordered)
 #eturn (key, value)

 #tems = (
 #k, marshal(data, v, skip_none=skip_none, ordered=ordered))
 #f isinstance(v, dict)
 #lse __format_field(k, v)
 #or k, v in fields.items()
 #

 #f skip_none:
 #tems = (
 #k, v) for k, v in items if v is not None and v != OrderedDict() and v != {}
 #

 #ut = OrderedDict(items) if ordered else dict(items)

 #f envelope:
 #ut = OrderedDict([(envelope, out)]) if ordered else {envelope: out}

 #eturn out, has_wildcards["present"]


class marshal_with(object):
 #""A decorator that apply marshalling to the return values of your methods.

 #>> from flask_restx import fields, marshal_with
 #>> mfields = { 'a': fields.Raw }
 #>> @marshal_with(mfields)
 #.. def get():
 #..     return { 'a': 100, 'b': 'foo' }
 #..
 #..
 #>> get()
 #rderedDict([('a', 100)])

 #>> @marshal_with(mfields, envelope='data')
 #.. def get():
 #..     return { 'a': 100, 'b': 'foo' }
 #..
 #..
 #>> get()
 #rderedDict([('data', OrderedDict([('a', 100)]))])

 #>> mfields = { 'a': fields.Raw, 'c': fields.Raw, 'd': fields.Raw }
 #>> @marshal_with(mfields, skip_none=True)
 #.. def get():
 #..     return { 'a': 100, 'b': 'foo', 'c': None }
 #..
 #..
 #>> get()
 #rderedDict([('a', 100)])

 #ee :meth:`flask_restx.marshal`
 #""

 #ef __init__(
 #elf, fields, envelope=None, skip_none=False, mask=None, ordered=False
 #:
 #""
 #param fields: a dict of whose keys will make up the final
 #erialized response output
 #param envelope: optional key that will be used to envelop the serialized
 #esponse
 #""
 #elf.fields = fields
 #elf.envelope = envelope
 #elf.skip_none = skip_none
 #elf.ordered = ordered
 #elf.mask = Mask(mask, skip=True)

 #ef __call__(self, f):
 #wraps(f)
 #ef wrapper(*args, **kwargs):
 #esp = f(*args, **kwargs)
 #ask = self.mask
 #f has_app_context():
 #ask_header = current_app.config["RESTX_MASK_HEADER"]
 #ask = request.headers.get(mask_header) or mask
 #f isinstance(resp, tuple):
 #ata, code, headers = unpack(resp)
 #eturn (
 #arshal(
 #ata,
 #elf.fields,
 #elf.envelope,
 #elf.skip_none,
 #ask,
 #elf.ordered,
 #,
 #ode,
 #eaders,
 #
 #lse:
 #eturn marshal(
 #esp, self.fields, self.envelope, self.skip_none, mask, self.ordered
 #

 #eturn wrapper


class marshal_with_field(object):
 #""
 # decorator that formats the return values of your methods with a single field.

 #>> from flask_restx import marshal_with_field, fields
 #>> @marshal_with_field(fields.List(fields.Integer))
 #.. def get():
 #..     return ['1', 2, 3.0]
 #..
 #>> get()
 #1, 2, 3]

 #ee :meth:`flask_restx.marshal_with`
 #""

 #ef __init__(self, field):
 #""
 #param field: a single field with which to marshal the output.
 #""
 #f isinstance(field, type):
 #elf.field = field()
 #lse:
 #elf.field = field

 #ef __call__(self, f):
 #wraps(f)
 #ef wrapper(*args, **kwargs):
 #esp = f(*args, **kwargs)

 #f isinstance(resp, tuple):
 #ata, code, headers = unpack(resp)
 #eturn self.field.format(data), code, headers
 #eturn self.field.format(resp)

 #eturn wrapper
