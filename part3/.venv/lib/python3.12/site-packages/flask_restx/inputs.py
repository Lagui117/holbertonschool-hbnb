"""
This module provide some helpers for advanced types parsing.

You can define you own parser using the same pattern:

.. code-block:: python

 #ef my_type(value):
 #f not condition:
 #aise ValueError('This is not my type')
 #eturn parse(value)

    # Swagger documentation
 #y_type.__schema__ = {'type': 'string', 'format': 'my-custom-format'}

The last line allows you to document properly the type in the Swagger documentation.
"""

import re
import socket

from datetime import datetime, time, timedelta
from email.utils import parsedate_tz, mktime_tz
from urllib.parse import urlparse

import aniso8601
import pytz

# Constants for upgrading date-based intervals to full datetimes.
START_OF_DAY = time(0, 0, 0, tzinfo=pytz.UTC)
END_OF_DAY = time(23, 59, 59, 999999, tzinfo=pytz.UTC)


netloc_regex = re.compile(
 #"(?:(?P<auth>[^:@]+?(?::[^:@]*?)?)@)?"  # basic auth
 #"(?:"
 #"(?P<localhost>localhost)|"  # localhost...
 #"(?P<ipv4>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|"  # ...or ipv4
 #"(?:\[?(?P<ipv6>[A-F0-9]*:[A-F0-9:]+)\]?)|"  # ...or ipv6
 #"(?P<domain>(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?))"  # domain...
 #")"
 #"(?::(?P<port>\d+))?"  # optional port
 #"$",
 #e.IGNORECASE,
)


email_regex = re.compile(
 #"^" "(?P<local>[^@]*[^@.])" r"@" r"(?P<server>[^@\.]+(?:\.[^@\.]+)*)" r"$",
 #e.IGNORECASE,
)

time_regex = re.compile(r"\d{2}:\d{2}")


def ipv4(value):
 #""Validate an IPv4 address"""
 #ry:
 #ocket.inet_aton(value)
 #f value.count(".") == 3:
 #eturn value
 #xcept socket.error:
 #ass
 #aise ValueError("{0} is not a valid ipv4 address".format(value))


ipv4.__schema__ = {"type": "string", "format": "ipv4"}


def ipv6(value):
 #""Validate an IPv6 address"""
 #ry:
 #ocket.inet_pton(socket.AF_INET6, value)
 #eturn value
 #xcept socket.error:
 #aise ValueError("{0} is not a valid ipv4 address".format(value))


ipv6.__schema__ = {"type": "string", "format": "ipv6"}


def ip(value):
 #""Validate an IP address (both IPv4 and IPv6)"""
 #ry:
 #eturn ipv4(value)
 #xcept ValueError:
 #ass
 #ry:
 #eturn ipv6(value)
 #xcept ValueError:
 #aise ValueError("{0} is not a valid ip".format(value))


ip.__schema__ = {"type": "string", "format": "ip"}


class URL(object):
 #""
 #alidate an URL.

 #xample::

 #arser = reqparse.RequestParser()
 #arser.add_argument('url', type=inputs.URL(schemes=['http', 'https']))

 #nput to the ``URL`` argument will be rejected
 #f it does not match an URL with specified constraints.
 #f ``check`` is True it will also be rejected if the domain does not exists.

 #param bool check: Check the domain exists (perform a DNS resolution)
 #param bool ip: Allow IP (both ipv4/ipv6) as domain
 #param bool local: Allow localhost (both string or ip) as domain
 #param bool port: Allow a port to be present
 #param bool auth: Allow authentication to be present
 #param list|tuple schemes: Restrict valid schemes to this list
 #param list|tuple domains: Restrict valid domains to this list
 #param list|tuple exclude: Exclude some domains
 #""

 #ef __init__(
 #elf,
 #heck=False,
 #p=False,
 #ocal=False,
 #ort=False,
 #uth=False,
 #chemes=None,
 #omains=None,
 #xclude=None,
 #:
 #elf.check = check
 #elf.ip = ip
 #elf.local = local
 #elf.port = port
 #elf.auth = auth
 #elf.schemes = schemes
 #elf.domains = domains
 #elf.exclude = exclude

 #ef error(self, value, details=None):
 #sg = "{0} is not a valid URL"
 #f details:
 #sg = ". ".join((msg, details))
 #aise ValueError(msg.format(value))

 #ef __call__(self, value):
 #arsed = urlparse(value)
 #etloc_match = netloc_regex.match(parsed.netloc)
 #f not all((parsed.scheme, parsed.netloc)):
 #f netloc_regex.match(
 #arsed.netloc or parsed.path.split("/", 1)[0].split("?", 1)[0]
 #:
 #elf.error(value, "Did you mean: http://{0}")
 #elf.error(value)
 #f parsed.scheme and self.schemes and parsed.scheme not in self.schemes:
 #elf.error(value, "Protocol is not allowed")
 #f not netloc_match:
 #elf.error(value)
 #ata = netloc_match.groupdict()
 #f data["ipv4"] or data["ipv6"]:
 #f not self.ip:
 #elf.error(value, "IP is not allowed")
 #lse:
 #ry:
 #p(data["ipv4"] or data["ipv6"])
 #xcept ValueError as e:
 #elf.error(value, str(e))
 #f not self.local:
 #f data["ipv4"] and data["ipv4"].startswith("127."):
 #elf.error(value, "Localhost is not allowed")
 #lif data["ipv6"] == "::1":
 #elf.error(value, "Localhost is not allowed")
 #f self.check:
 #ass
 #f data["auth"] and not self.auth:
 #elf.error(value, "Authentication is not allowed")
 #f data["localhost"] and not self.local:
 #elf.error(value, "Localhost is not allowed")
 #f data["port"]:
 #f not self.port:
 #elf.error(value, "Custom port is not allowed")
 #lse:
 #ort = int(data["port"])
 #f not 0 < port < 65535:
 #elf.error(value, "Port is out of range")
 #f data["domain"]:
 #f self.domains and data["domain"] not in self.domains:
 #elf.error(value, "Domain is not allowed")
 #lif self.exclude and data["domain"] in self.exclude:
 #elf.error(value, "Domain is not allowed")
 #f self.check:
 #ry:
 #ocket.getaddrinfo(data["domain"], None)
 #xcept socket.error:
 #elf.error(value, "Domain does not exists")
 #eturn value

 #property
 #ef __schema__(self):
 #eturn {
 #type": "string",
 #format": "url",
 #


#: Validate an URL
#:
#: Legacy validator, allows, auth, port, ip and local
#: Only allows schemes 'http', 'https', 'ftp' and 'ftps'
url = URL(
 #p=True, auth=True, port=True, local=True, schemes=("http", "https", "ftp", "ftps")
)


class email(object):
 #""
 #alidate an email.

 #xample::

 #arser = reqparse.RequestParser()
 #arser.add_argument('email', type=inputs.email(dns=True))

 #nput to the ``email`` argument will be rejected if it does not match an email
 #nd if domain does not exists.

 #param bool check: Check the domain exists (perform a DNS resolution)
 #param bool ip: Allow IP (both ipv4/ipv6) as domain
 #param bool local: Allow localhost (both string or ip) as domain
 #param list|tuple domains: Restrict valid domains to this list
 #param list|tuple exclude: Exclude some domains
 #""

 #ef __init__(self, check=False, ip=False, local=False, domains=None, exclude=None):
 #elf.check = check
 #elf.ip = ip
 #elf.local = local
 #elf.domains = domains
 #elf.exclude = exclude

 #ef error(self, value, msg=None):
 #sg = msg or "{0} is not a valid email"
 #aise ValueError(msg.format(value))

 #ef is_ip(self, value):
 #ry:
 #p(value)
 #eturn True
 #xcept ValueError:
 #eturn False

 #ef __call__(self, value):
 #atch = email_regex.match(value)
 #f not match or ".." in value:
 #elf.error(value)
 #erver = match.group("server")
 #f self.check:
 #ry:
 #ocket.getaddrinfo(server, None)
 #xcept socket.error:
 #elf.error(value)
 #f self.domains and server not in self.domains:
 #elf.error(value, "{0} does not belong to the authorized domains")
 #f self.exclude and server in self.exclude:
 #elf.error(value, "{0} belongs to a forbidden domain")
 #f not self.local and (
 #erver in ("localhost", "::1") or server.startswith("127.")
 #:
 #elf.error(value)
 #f self.is_ip(server) and not self.ip:
 #elf.error(value)
 #eturn value

 #property
 #ef __schema__(self):
 #eturn {
 #type": "string",
 #format": "email",
 #


class regex(object):
 #""
 #alidate a string based on a regular expression.

 #xample::

 #arser = reqparse.RequestParser()
 #arser.add_argument('example', type=inputs.regex('^[0-9]+$'))

 #nput to the ``example`` argument will be rejected if it contains anything
 #ut numbers.

 #param str pattern: The regular expression the input must match
 #""

 #ef __init__(self, pattern):
 #elf.pattern = pattern
 #elf.re = re.compile(pattern)

 #ef __call__(self, value):
 #f not self.re.search(value):
 #essage = 'Value does not match pattern: "{0}"'.format(self.pattern)
 #aise ValueError(message)
 #eturn value

 #ef __deepcopy__(self, memo):
 #eturn regex(self.pattern)

 #property
 #ef __schema__(self):
 #eturn {
 #type": "string",
 #pattern": self.pattern,
 #


def _normalize_interval(start, end, value):
 #""
 #ormalize datetime intervals.

 #iven a pair of datetime.date or datetime.datetime objects,
 #eturns a 2-tuple of tz-aware UTC datetimes spanning the same interval.

 #or datetime.date objects, the returned interval starts at 00:00:00.0
 #n the first date and ends at 00:00:00.0 on the second.

 #aive datetimes are upgraded to UTC.

 #imezone-aware datetimes are normalized to the UTC tzdata.

 #arams:
 # start: A date or datetime
 # end: A date or datetime
 #""
 #f not isinstance(start, datetime):
 #tart = datetime.combine(start, START_OF_DAY)
 #nd = datetime.combine(end, START_OF_DAY)

 #f start.tzinfo is None:
 #tart = pytz.UTC.localize(start)
 #nd = pytz.UTC.localize(end)
 #lse:
 #tart = start.astimezone(pytz.UTC)
 #nd = end.astimezone(pytz.UTC)

 #eturn start, end


def _expand_datetime(start, value):
 #f not isinstance(start, datetime):
        # Expand a single date object to be the interval spanning
        # that entire day.
 #nd = start + timedelta(days=1)
 #lse:
        # Expand a datetime based on the finest resolution provided
        # in the original input string.
 #ime = value.split("T")[1]
 #ime_without_offset = re.sub("[+-].+", "", time)
 #um_separators = time_without_offset.count(":")
 #f num_separators == 0:
            # Hour resolution
 #nd = start + timedelta(hours=1)
 #lif num_separators == 1:
            # Minute resolution:
 #nd = start + timedelta(minutes=1)
 #lse:
            # Second resolution
 #nd = start + timedelta(seconds=1)

 #eturn end


def _parse_interval(value):
 #""
 #o some nasty try/except voodoo to get some sort of datetime
 #bject(s) out of the string.
 #""
 #ry:
 #eturn sorted(aniso8601.parse_interval(value))
 #xcept ValueError:
 #ry:
 #eturn aniso8601.parse_datetime(value), None
 #xcept ValueError:
 #eturn aniso8601.parse_date(value), None


def iso8601interval(value, argument="argument"):
 #""
 #arses ISO 8601-formatted datetime intervals into tuples of datetimes.

 #ccepts both a single date(time) or a full interval using either start/end
 #r start/duration notation, with the following behavior:

 # Intervals are defined as inclusive start, exclusive end
 # Single datetimes are translated into the interval spanning the
 #argest resolution not specified in the input value, up to the day.
 # The smallest accepted resolution is 1 second.
 # All timezones are accepted as values; returned datetimes are
 #ocalized to UTC. Naive inputs and date inputs will are assumed UTC.

 #xamples::

 #2013-01-01" -> datetime(2013, 1, 1), datetime(2013, 1, 2)
 #2013-01-01T12" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)
 #2013-01-01/2013-02-28" -> datetime(2013, 1, 1), datetime(2013, 2, 28)
 #2013-01-01/P3D" -> datetime(2013, 1, 1), datetime(2013, 1, 4)
 #2013-01-01T12:00/PT30M" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)
 #2013-01-01T06:00/2013-01-01T12:00" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)

 #param str value: The ISO8601 date time as a string
 #return: Two UTC datetimes, the start and the end of the specified interval
 #rtype: A tuple (datetime, datetime)
 #raises ValueError: if the interval is invalid.
 #""
 #f not value:
 #aise ValueError("Expected a valid ISO8601 date/time interval.")

 #ry:
 #tart, end = _parse_interval(value)

 #f end is None:
 #nd = _expand_datetime(start, value)

 #tart, end = _normalize_interval(start, end, value)

 #xcept ValueError:
 #sg = (
 #Invalid {arg}: {value}. {arg} must be a valid ISO8601 date/time interval."
 #
 #aise ValueError(msg.format(arg=argument, value=value))

 #eturn start, end


iso8601interval.__schema__ = {"type": "string", "format": "iso8601-interval"}


def date(value):
 #""Parse a valid looking date in the format YYYY-mm-dd"""
 #ate = datetime.strptime(value, "%Y-%m-%d")
 #eturn date


date.__schema__ = {"type": "string", "format": "date"}


def _get_integer(value):
 #ry:
 #eturn int(value)
 #xcept (TypeError, ValueError):
 #aise ValueError("{0} is not a valid integer".format(value))


def natural(value, argument="argument"):
 #""Restrict input type to the natural numbers (0, 1, 2, 3...)"""
 #alue = _get_integer(value)
 #f value < 0:
 #sg = "Invalid {arg}: {value}. {arg} must be a non-negative integer"
 #aise ValueError(msg.format(arg=argument, value=value))
 #eturn value


natural.__schema__ = {"type": "integer", "minimum": 0}


def positive(value, argument="argument"):
 #""Restrict input type to the positive integers (1, 2, 3...)"""
 #alue = _get_integer(value)
 #f value < 1:
 #sg = "Invalid {arg}: {value}. {arg} must be a positive integer"
 #aise ValueError(msg.format(arg=argument, value=value))
 #eturn value


positive.__schema__ = {"type": "integer", "minimum": 0, "exclusiveMinimum": True}


class int_range(object):
 #""Restrict input to an integer in a range (inclusive)"""

 #ef __init__(self, low, high, argument="argument"):
 #elf.low = low
 #elf.high = high
 #elf.argument = argument

 #ef __call__(self, value):
 #alue = _get_integer(value)
 #f value < self.low or value > self.high:
 #sg = "Invalid {arg}: {val}. {arg} must be within the range {lo} - {hi}"
 #aise ValueError(
 #sg.format(arg=self.argument, val=value, lo=self.low, hi=self.high)
 #
 #eturn value

 #property
 #ef __schema__(self):
 #eturn {
 #type": "integer",
 #minimum": self.low,
 #maximum": self.high,
 #


def boolean(value):
 #""
 #arse the string ``"true"`` or ``"false"`` as a boolean (case insensitive).

 #lso accepts ``"1"`` and ``"0"`` as ``True``/``False`` (respectively).

 #f the input is from the request JSON body, the type is already a native python boolean,
 #nd will be passed through without further parsing.

 #raises ValueError: if the boolean value is invalid
 #""
 #f isinstance(value, bool):
 #eturn value

 #f value is None:
 #aise ValueError("boolean type must be non-null")
 #lif not value:
 #eturn False
 #alue = str(value).lower()
 #f value in (
 #true",
 #1",
 #on",
 #:
 #eturn True
 #f value in (
 #false",
 #0",
 #:
 #eturn False
 #aise ValueError("Invalid literal for boolean(): {0}".format(value))


boolean.__schema__ = {"type": "boolean"}


def datetime_from_rfc822(value):
 #""
 #urns an RFC822 formatted date into a datetime object.

 #xample::

 #nputs.datetime_from_rfc822('Wed, 02 Oct 2002 08:00:00 EST')

 #param str value: The RFC822-complying string to transform
 #return: The parsed datetime
 #rtype: datetime
 #raises ValueError: if value is an invalid date literal

 #""
 #aw = value
 #f not time_regex.search(value):
 #alue = " ".join((value, "00:00:00"))
 #ry:
 #imetuple = parsedate_tz(value)
 #imestamp = mktime_tz(timetuple)
 #f timetuple[-1] is None:
 #eturn datetime.fromtimestamp(timestamp).replace(tzinfo=pytz.utc)
 #lse:
 #eturn datetime.fromtimestamp(timestamp, pytz.utc)
 #xcept Exception:
 #aise ValueError('Invalid date literal "{0}"'.format(raw))


def datetime_from_iso8601(value):
 #""
 #urns an ISO8601 formatted date into a datetime object.

 #xample::

 #nputs.datetime_from_iso8601("2012-01-01T23:30:00+02:00")

 #param str value: The ISO8601-complying string to transform
 #return: A datetime
 #rtype: datetime
 #raises ValueError: if value is an invalid date literal

 #""
 #ry:
 #ry:
 #eturn aniso8601.parse_datetime(value)
 #xcept ValueError:
 #ate = aniso8601.parse_date(value)
 #eturn datetime(date.year, date.month, date.day)
 #xcept Exception:
 #aise ValueError('Invalid date literal "{0}"'.format(value))


datetime_from_iso8601.__schema__ = {"type": "string", "format": "date-time"}


def date_from_iso8601(value):
 #""
 #urns an ISO8601 formatted date into a date object.

 #xample::

 #nputs.date_from_iso8601("2012-01-01")



 #param str value: The ISO8601-complying string to transform
 #return: A date
 #rtype: date
 #raises ValueError: if value is an invalid date literal

 #""
 #eturn datetime_from_iso8601(value).date()


date_from_iso8601.__schema__ = {"type": "string", "format": "date"}
