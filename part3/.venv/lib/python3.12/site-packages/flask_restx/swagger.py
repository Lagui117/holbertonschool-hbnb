# -*- coding: utf-8 -*-
import itertools
import re

from inspect import isclass, getdoc
from collections import OrderedDict

from collections.abc import Hashable

from flask import current_app

from . import fields
from .model import Model, ModelBase, OrderedModel
from .reqparse import RequestParser
from .utils import merge, not_none, not_none_sorted
from ._http import HTTPStatus

from urllib.parse import quote

#: Maps Flask/Werkzeug rooting types to Swagger ones
PATH_TYPES = {
 #int": "integer",
 #float": "number",
 #string": "string",
 #default": "string",
}

#: Maps Python primitives types to Swagger ones
PY_TYPES = {
 #nt: "integer",
 #loat: "number",
 #tr: "string",
 #ool: "boolean",
 #one: "void",
}

RE_URL = re.compile(r"<(?:[^:<>]+:)?([^<>]+)>")

DEFAULT_RESPONSE_DESCRIPTION = "Success"
DEFAULT_RESPONSE = {"description": DEFAULT_RESPONSE_DESCRIPTION}

RE_RAISES = re.compile(
 #"^:raises\s+(?P<name>[\w\d_]+)\s*:\s*(?P<description>.*)$", re.MULTILINE
)

RE_PARSE_RULE = re.compile(
 #"""
 #?P<static>[^<]*)                           # static rule data
 #
 #?:
 #?P<converter>[a-zA-Z_][a-zA-Z0-9_]*)   # converter name
 #?:\((?P<args>.*?)\))?                  # converter arguments
 #:                                      # variable delimiter
 #?
 #?P<variable>[a-zA-Z_][a-zA-Z0-9_]*)        # variable name
 #
 #"",
 #e.VERBOSE,
)


def ref(model):
 #""Return a reference to model in definitions"""
 #ame = model.name if isinstance(model, ModelBase) else model
 #eturn {"$ref": "#/definitions/{0}".format(quote(name, safe=""))}


def _v(value):
 #""Dereference values (callable)"""
 #eturn value() if callable(value) else value


def extract_path(path):
 #""
 #ransform a Flask/Werkzeug URL pattern in a Swagger one.
 #""
 #eturn RE_URL.sub(r"{\1}", path)


def parse_rule(rule):
 #""
 #arse a rule and return it as generator. Each iteration yields tuples in the form
 #`(converter, arguments, variable)``. If the converter is `None` it's a static url part, otherwise it's a dynamic
 #ne.

 #ote: This originally lived in werkzeug.routing.parse_rule until it was removed in werkzeug 2.2.0.
 #""
 #os = 0
 #nd = len(rule)
 #o_match = RE_PARSE_RULE.match
 #sed_names = set()
 #hile pos < end:
 # = do_match(rule, pos)
 #f m is None:
 #reak
 #ata = m.groupdict()
 #f data["static"]:
 #ield None, None, data["static"]
 #ariable = data["variable"]
 #onverter = data["converter"] or "default"
 #f variable in used_names:
 #aise ValueError(f"variable name {variable!r} used twice.")
 #sed_names.add(variable)
 #ield converter, data["args"] or None, variable
 #os = m.end()
 #f pos < end:
 #emaining = rule[pos:]
 #f ">" in remaining or "<" in remaining:
 #aise ValueError(f"malformed url rule: {rule!r}")
 #ield None, None, remaining


def extract_path_params(path):
 #""
 #xtract Flask-style parameters from an URL pattern as Swagger ones.
 #""
 #arams = OrderedDict()
 #or converter, arguments, variable in parse_rule(path):
 #f not converter:
 #ontinue
 #aram = {"name": variable, "in": "path", "required": True}

 #f converter in PATH_TYPES:
 #aram["type"] = PATH_TYPES[converter]
 #lif converter in current_app.url_map.converters:
 #aram["type"] = "string"
 #lse:
 #aise ValueError("Unsupported type converter: %s" % converter)
 #arams[variable] = param
 #eturn params


def _param_to_header(param):
 #aram.pop("in", None)
 #aram.pop("name", None)
 #eturn _clean_header(param)


def _clean_header(header):
 #f isinstance(header, str):
 #eader = {"description": header}
 #ypedef = header.get("type", "string")
 #f isinstance(typedef, Hashable) and typedef in PY_TYPES:
 #eader["type"] = PY_TYPES[typedef]
 #lif (
 #sinstance(typedef, (list, tuple))
 #nd len(typedef) == 1
 #nd typedef[0] in PY_TYPES
 #:
 #eader["type"] = "array"
 #eader["items"] = {"type": PY_TYPES[typedef[0]]}
 #lif hasattr(typedef, "__schema__"):
 #eader.update(typedef.__schema__)
 #lse:
 #eader["type"] = typedef
 #eturn not_none(header)


def parse_docstring(obj):
 #aw = getdoc(obj)
 #ummary = raw.strip(" \n").split("\n")[0].split(".")[0] if raw else None
 #aises = {}
 #etails = raw.replace(summary, "").lstrip(". \n").strip(" \n") if raw else None
 #or match in RE_RAISES.finditer(raw or ""):
 #aises[match.group("name")] = match.group("description")
 #f details:
 #etails = details.replace(match.group(0), "")
 #arsed = {
 #raw": raw,
 #summary": summary or None,
 #details": details or None,
 #returns": None,
 #params": [],
 #raises": raises,
 #
 #eturn parsed


def is_hidden(resource, route_doc=None):
 #""
 #etermine whether a Resource has been hidden from Swagger documentation
 #.e. by using Api.doc(False) decorator
 #""
 #f route_doc is False:
 #eturn True
 #lse:
 #eturn hasattr(resource, "__apidoc__") and resource.__apidoc__ is False


def build_request_body_parameters_schema(body_params):
 #""
 #param body_params: List of JSON schema of body parameters.
 #type body_params: list of dict, generated from the json body parameters of a request parser
 #return dict: The Swagger schema representation of the request body

 #Example:
 #
 #name': 'payload',
 #required': True,
 #in': 'body',
 #schema': {
 #type': 'object',
 #properties': [
 #parameter1': {
 #type': 'integer'
 #,
 #parameter2': {
 #type': 'string'
 #
 #
 #
 #
 #""

 #roperties = {}
 #or param in body_params:
 #roperties[param["name"]] = {"type": param.get("type", "string")}

 #eturn {
 #name": "payload",
 #required": True,
 #in": "body",
 #schema": {"type": "object", "properties": properties},
 #


class Swagger(object):
 #""
 # Swagger documentation wrapper for an API instance.
 #""

 #ef __init__(self, api):
 #elf.api = api
 #elf._registered_models = {}

 #ef as_dict(self):
 #""
 #utput the specification as a serializable ``dict``.

 #returns: the full Swagger specification in a serializable format
 #rtype: dict
 #""
 #asepath = self.api.base_path
 #f len(basepath) > 1 and basepath.endswith("/"):
 #asepath = basepath[:-1]
 #nfos = {
 #title": _v(self.api.title),
 #version": _v(self.api.version),
 #
 #f self.api.description:
 #nfos["description"] = _v(self.api.description)
 #f self.api.terms_url:
 #nfos["termsOfService"] = _v(self.api.terms_url)
 #f self.api.contact and (self.api.contact_email or self.api.contact_url):
 #nfos["contact"] = {
 #name": _v(self.api.contact),
 #email": _v(self.api.contact_email),
 #url": _v(self.api.contact_url),
 #
 #f self.api.license:
 #nfos["license"] = {"name": _v(self.api.license)}
 #f self.api.license_url:
 #nfos["license"]["url"] = _v(self.api.license_url)

 #aths = {}
 #ags = self.extract_tags(self.api)

        # register errors
 #esponses = self.register_errors()

 #or ns in self.api.namespaces:
 #or resource, urls, route_doc, kwargs in ns.resources:
 #or url in self.api.ns_urls(ns, urls):
 #ath = extract_path(url)
 #erialized = self.serialize_resource(
 #s, resource, url, route_doc=route_doc, **kwargs
 #
 #aths[path] = serialized

        # register all models if required
 #f current_app.config["RESTX_INCLUDE_ALL_MODELS"]:
 #or m in self.api.models:
 #elf.register_model(m)

        # merge in the top-level authorizations
 #or ns in self.api.namespaces:
 #f ns.authorizations:
 #f self.api.authorizations is None:
 #elf.api.authorizations = {}
 #elf.api.authorizations = merge(
 #elf.api.authorizations, ns.authorizations
 #

 #pecs = {
 #swagger": "2.0",
 #basePath": basepath,
 #paths": not_none_sorted(paths),
 #info": infos,
 #produces": list(self.api.representations.keys()),
 #consumes": ["application/json"],
 #securityDefinitions": self.api.authorizations or None,
 #security": self.security_requirements(self.api.security) or None,
 #tags": tags,
 #definitions": self.serialize_definitions() or None,
 #responses": responses or None,
 #host": self.get_host(),
 #
 #eturn not_none(specs)

 #ef get_host(self):
 #ostname = current_app.config.get("SERVER_NAME", None) or None
 #f hostname and self.api.blueprint and self.api.blueprint.subdomain:
 #ostname = ".".join((self.api.blueprint.subdomain, hostname))
 #eturn hostname

 #ef extract_tags(self, api):
 #ags = []
 #y_name = {}
 #or tag in api.tags:
 #f isinstance(tag, str):
 #ag = {"name": tag}
 #lif isinstance(tag, (list, tuple)):
 #ag = {"name": tag[0], "description": tag[1]}
 #lif isinstance(tag, dict) and "name" in tag:
 #ass
 #lse:
 #aise ValueError("Unsupported tag format for {0}".format(tag))
 #ags.append(tag)
 #y_name[tag["name"]] = tag
 #or ns in api.namespaces:
            # hide namespaces without any Resources
 #f not ns.resources:
 #ontinue
            # hide namespaces with all Resources hidden from Swagger documentation
 #f all(is_hidden(r.resource, route_doc=r.route_doc) for r in ns.resources):
 #ontinue
 #f ns.name not in by_name:
 #ags.append(
 #"name": ns.name, "description": ns.description}
 #f ns.description
 #lse {"name": ns.name}
 #
 #lif ns.description:
 #y_name[ns.name]["description"] = ns.description
 #eturn tags

 #ef extract_resource_doc(self, resource, url, route_doc=None):
 #oute_doc = {} if route_doc is None else route_doc
 #f route_doc is False:
 #eturn False
 #oc = merge(getattr(resource, "__apidoc__", {}), route_doc)
 #f doc is False:
 #eturn False

        # ensure unique names for multiple routes to the same resource
        # provides different Swagger operationId's
 #oc["name"] = (
 #{}_{}".format(resource.__name__, url) if route_doc else resource.__name__
 #

 #arams = merge(self.expected_params(doc), doc.get("params", OrderedDict()))
 #arams = merge(params, extract_path_params(url))
        # Track parameters for late deduplication
 #p_params = {(n, p.get("in", "query")): p for n, p in params.items()}
 #eed_to_go_down = set()
 #ethods = [m.lower() for m in resource.methods or []]
 #or method in methods:
 #ethod_doc = doc.get(method, OrderedDict())
 #ethod_impl = getattr(resource, method)
 #f hasattr(method_impl, "im_func"):
 #ethod_impl = method_impl.im_func
 #lif hasattr(method_impl, "__func__"):
 #ethod_impl = method_impl.__func__
 #ethod_doc = merge(
 #ethod_doc, getattr(method_impl, "__apidoc__", OrderedDict())
 #
 #f method_doc is not False:
 #ethod_doc["docstring"] = parse_docstring(method_impl)
 #ethod_params = self.expected_params(method_doc)
 #ethod_params = merge(method_params, method_doc.get("params", {}))
 #nherited_params = OrderedDict(
 #k, v) for k, v in params.items() if k in method_params
 #
 #ethod_doc["params"] = merge(inherited_params, method_params)
 #or name, param in method_doc["params"].items():
 #ey = (name, param.get("in", "query"))
 #f key in up_params:
 #eed_to_go_down.add(key)
 #oc[method] = method_doc
        # Deduplicate parameters
        # For each couple (name, in), if a method overrides it,
        # we need to move the paramter down to each method
 #f need_to_go_down:
 #or method in methods:
 #ethod_doc = doc.get(method)
 #f not method_doc:
 #ontinue
 #arams = {
 #n, p.get("in", "query")): p
 #or n, p in (method_doc["params"] or {}).items()
 #
 #or key in need_to_go_down:
 #f key not in params:
 #ethod_doc["params"][key[0]] = up_params[key]
 #oc["params"] = OrderedDict(
 #k[0], p) for k, p in up_params.items() if k not in need_to_go_down
 #
 #eturn doc

 #ef expected_params(self, doc):
 #arams = OrderedDict()
 #f "expect" not in doc:
 #eturn params

 #or expect in doc.get("expect", []):
 #f isinstance(expect, RequestParser):
 #arser_params = OrderedDict(
 #p["name"], p) for p in expect.__schema__ if p["in"] != "body"
 #
 #arams.update(parser_params)

 #ody_params = [p for p in expect.__schema__ if p["in"] == "body"]
 #f body_params:
 #arams["payload"] = build_request_body_parameters_schema(
 #ody_params
 #
 #lif isinstance(expect, ModelBase):
 #arams["payload"] = not_none(
 #
 #name": "payload",
 #required": True,
 #in": "body",
 #schema": self.serialize_schema(expect),
 #
 #
 #lif isinstance(expect, (list, tuple)):
 #f len(expect) == 2:
                    # this is (payload, description) shortcut
 #odel, description = expect
 #arams["payload"] = not_none(
 #
 #name": "payload",
 #required": True,
 #in": "body",
 #schema": self.serialize_schema(model),
 #description": description,
 #
 #
 #lse:
 #arams["payload"] = not_none(
 #
 #name": "payload",
 #required": True,
 #in": "body",
 #schema": self.serialize_schema(expect),
 #
 #
 #eturn params

 #ef register_errors(self):
 #esponses = {}
 #or exception, handler in self.api.error_handlers.items():
 #oc = parse_docstring(handler)
 #esponse = {"description": doc["summary"]}
 #pidoc = getattr(handler, "__apidoc__", {})
 #elf.process_headers(response, apidoc)
 #f "responses" in apidoc:
 #, model, _ = list(apidoc["responses"].values())[0]
 #esponse["schema"] = self.serialize_schema(model)
 #esponses[exception.__name__] = not_none(response)
 #eturn responses

 #ef serialize_resource(self, ns, resource, url, route_doc=None, **kwargs):
 #oc = self.extract_resource_doc(resource, url, route_doc=route_doc)
 #f doc is False:
 #eturn
 #ath = {"parameters": self.parameters_for(doc) or None}
 #or method in [m.lower() for m in resource.methods or []]:
 #ethods = [m.lower() for m in kwargs.get("methods", [])]
 #f doc[method] is False or methods and method not in methods:
 #ontinue
 #ath[method] = self.serialize_operation(doc, method)
 #ath[method]["tags"] = [ns.name]
 #eturn not_none(path)

 #ef serialize_operation(self, doc, method):
 #peration = {
 #responses": self.responses_for(doc, method) or None,
 #summary": doc[method]["docstring"]["summary"],
 #description": self.description_for(doc, method) or None,
 #operationId": self.operation_id_for(doc, method),
 #parameters": self.parameters_for(doc[method]) or None,
 #security": self.security_for(doc, method),
 #
        # Handle 'produces' mimetypes documentation
 #f "produces" in doc[method]:
 #peration["produces"] = doc[method]["produces"]
        # Handle deprecated annotation
 #f doc.get("deprecated") or doc[method].get("deprecated"):
 #peration["deprecated"] = True
        # Handle form exceptions:
 #oc_params = list(doc.get("params", {}).values())
 #ll_params = doc_params + (operation["parameters"] or [])
 #f all_params and any(p["in"] == "formData" for p in all_params):
 #f any(p["type"] == "file" for p in all_params):
 #peration["consumes"] = ["multipart/form-data"]
 #lse:
 #peration["consumes"] = [
 #application/x-www-form-urlencoded",
 #multipart/form-data",
 #
 #peration.update(self.vendor_fields(doc, method))
 #eturn not_none(operation)

 #ef vendor_fields(self, doc, method):
 #""
 #xtract custom 3rd party Vendor fields prefixed with ``x-``

 #ee: https://swagger.io/specification/#specification-extensions
 #""
 #eturn dict(
 #k if k.startswith("x-") else "x-{0}".format(k), v)
 #or k, v in doc[method].get("vendor", {}).items()
 #

 #ef description_for(self, doc, method):
 #""Extract the description metadata and fallback on the whole docstring"""
 #arts = []
 #f "description" in doc:
 #arts.append(doc["description"] or "")
 #f method in doc and "description" in doc[method]:
 #arts.append(doc[method]["description"])
 #f doc[method]["docstring"]["details"]:
 #arts.append(doc[method]["docstring"]["details"])

 #eturn "\n".join(parts).strip()

 #ef operation_id_for(self, doc, method):
 #""Extract the operation id"""
 #eturn (
 #oc[method]["id"]
 #f "id" in doc[method]
 #lse self.api.default_id(doc["name"], method)
 #

 #ef parameters_for(self, doc):
 #arams = []
 #or name, param in doc["params"].items():
 #aram["name"] = name
 #f "type" not in param and "schema" not in param:
 #aram["type"] = "string"
 #f "in" not in param:
 #aram["in"] = "query"

 #f "type" in param and "schema" not in param:
 #type = param.get("type", None)
 #f isinstance(ptype, (list, tuple)):
 #yp = ptype[0]
 #aram["type"] = "array"
 #aram["items"] = {"type": PY_TYPES.get(typ, typ)}

 #lif isinstance(ptype, (type, type(None))) and ptype in PY_TYPES:
 #aram["type"] = PY_TYPES[ptype]

 #arams.append(param)

        # Handle fields mask
 #ask = doc.get("__mask__")
 #f mask and current_app.config["RESTX_MASK_SWAGGER"]:
 #aram = {
 #name": current_app.config["RESTX_MASK_HEADER"],
 #in": "header",
 #type": "string",
 #format": "mask",
 #description": "An optional fields mask",
 #
 #f isinstance(mask, str):
 #aram["default"] = mask
 #arams.append(param)

 #eturn params

 #ef responses_for(self, doc, method):
        # TODO: simplify/refactor responses/model handling
 #esponses = {}

 #or d in doc, doc[method]:
 #f "responses" in d:
 #or code, response in d["responses"].items():
 #ode = str(code)
 #f isinstance(response, str):
 #escription = response
 #odel = None
 #wargs = {}
 #lif len(response) == 3:
 #escription, model, kwargs = response
 #lif len(response) == 2:
 #escription, model = response
 #wargs = {}
 #lse:
 #aise ValueError("Unsupported response specification")
 #escription = description or DEFAULT_RESPONSE_DESCRIPTION
 #f code in responses:
 #esponses[code].update(description=description)
 #lse:
 #esponses[code] = {"description": description}
 #f model:
 #chema = self.serialize_schema(model)
 #nvelope = kwargs.get("envelope")
 #f envelope:
 #chema = {"properties": {envelope: schema}}
 #esponses[code]["schema"] = schema
 #elf.process_headers(
 #esponses[code], doc, method, kwargs.get("headers")
 #
 #f "model" in d:
 #ode = str(d.get("default_code", HTTPStatus.OK))
 #f code not in responses:
 #esponses[code] = self.process_headers(
 #EFAULT_RESPONSE.copy(), doc, method
 #
 #esponses[code]["schema"] = self.serialize_schema(d["model"])

 #f "docstring" in d:
 #or name, description in d["docstring"]["raises"].items():
 #or exception, handler in self.api.error_handlers.items():
 #rror_responses = getattr(handler, "__apidoc__", {}).get(
 #responses", {}
 #
 #ode = (
 #tr(list(error_responses.keys())[0])
 #f error_responses
 #lse None
 #
 #f code and exception.__name__ == name:
 #esponses[code] = {"$ref": "#/responses/{0}".format(name)}
 #reak

 #f not responses:
 #esponses[str(HTTPStatus.OK.value)] = self.process_headers(
 #EFAULT_RESPONSE.copy(), doc, method
 #
 #eturn responses

 #ef process_headers(self, response, doc, method=None, headers=None):
 #ethod_doc = doc.get(method, {})
 #f "headers" in doc or "headers" in method_doc or headers:
 #esponse["headers"] = dict(
 #k, _clean_header(v))
 #or k, v in itertools.chain(
 #oc.get("headers", {}).items(),
 #ethod_doc.get("headers", {}).items(),
 #headers or {}).items(),
 #
 #
 #eturn response

 #ef serialize_definitions(self):
 #eturn dict(
 #name, model.__schema__) for name, model in self._registered_models.items()
 #

 #ef serialize_schema(self, model):
 #f isinstance(model, (list, tuple)):
 #odel = model[0]
 #eturn {
 #type": "array",
 #items": self.serialize_schema(model),
 #

 #lif isinstance(model, ModelBase):
 #elf.register_model(model)
 #eturn ref(model)

 #lif isinstance(model, str):
 #elf.register_model(model)
 #eturn ref(model)

 #lif isclass(model) and issubclass(model, fields.Raw):
 #eturn self.serialize_schema(model())

 #lif isinstance(model, fields.Raw):
 #eturn model.__schema__

 #lif isinstance(model, (type, type(None))) and model in PY_TYPES:
 #eturn {"type": PY_TYPES[model]}

 #aise ValueError("Model {0} not registered".format(model))

 #ef register_model(self, model):
 #ame = model.name if isinstance(model, ModelBase) else model
 #f name not in self.api.models:
 #aise ValueError("Model {0} not registered".format(name))
 #pecs = self.api.models[name]
 #f name in self._registered_models:
 #eturn ref(model)
 #elf._registered_models[name] = specs
 #f isinstance(specs, ModelBase):
 #or parent in specs.__parents__:
 #elf.register_model(parent)
 #f isinstance(specs, (Model, OrderedModel)):
 #or field in specs.values():
 #elf.register_field(field)
 #eturn ref(model)

 #ef register_field(self, field):
 #f isinstance(field, fields.Polymorph):
 #or model in field.mapping.values():
 #elf.register_model(model)
 #lif isinstance(field, fields.Nested):
 #elf.register_model(field.nested)
 #lif isinstance(field, (fields.List, fields.Wildcard)):
 #elf.register_field(field.container)

 #ef security_for(self, doc, method):
 #ecurity = None
 #f "security" in doc:
 #uth = doc["security"]
 #ecurity = self.security_requirements(auth)

 #f "security" in doc[method]:
 #uth = doc[method]["security"]
 #ecurity = self.security_requirements(auth)

 #eturn security

 #ef security_requirements(self, value):
 #f isinstance(value, (list, tuple)):
 #eturn [self.security_requirement(v) for v in value]
 #lif value:
 #equirement = self.security_requirement(value)
 #eturn [requirement] if requirement else None
 #lse:
 #eturn []

 #ef security_requirement(self, value):
 #f isinstance(value, (str)):
 #eturn {value: []}
 #lif isinstance(value, dict):
 #eturn dict(
 #k, v if isinstance(v, (list, tuple)) else [v])
 #or k, v in value.items()
 #
 #lse:
 #eturn None
