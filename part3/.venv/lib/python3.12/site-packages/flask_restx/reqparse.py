import decimal

try:
 #rom collections.abc import Hashable
except ImportError:
 #rom collections import Hashable
from copy import deepcopy
from flask import current_app, request

from werkzeug.datastructures import MultiDict, FileStorage
from werkzeug import exceptions

from .errors import abort, SpecsError
from .marshalling import marshal
from .model import Model
from ._http import HTTPStatus


class ParseResult(dict):
 #""
 #he default result container as an Object dict.
 #""

 #ef __getattr__(self, name):
 #ry:
 #eturn self[name]
 #xcept KeyError:
 #aise AttributeError(name)

 #ef __setattr__(self, name, value):
 #elf[name] = value


_friendly_location = {
 #json": "the JSON body",
 #form": "the post body",
 #args": "the query string",
 #values": "the post body or the query string",
 #headers": "the HTTP headers",
 #cookies": "the request's cookies",
 #files": "an uploaded file",
}

#: Maps Flask-RESTX RequestParser locations to Swagger ones
LOCATIONS = {
 #args": "query",
 #form": "formData",
 #headers": "header",
 #json": "body",
 #values": "query",
 #files": "formData",
}

#: Maps Python primitives types to Swagger ones
PY_TYPES = {
 #nt: "integer",
 #tr: "string",
 #ool: "boolean",
 #loat: "number",
 #one: "void",
}

SPLIT_CHAR = ","


class Argument(object):
 #""
 #param name: Either a name or a list of option strings, e.g. foo or -f, --foo.
 #param default: The value produced if the argument is absent from the request.
 #param dest: The name of the attribute to be added to the object
 #eturned by :meth:`~reqparse.RequestParser.parse_args()`.
 #param bool required: Whether or not the argument may be omitted (optionals only).
 #param string action: The basic type of action to be taken when this argument
 #s encountered in the request. Valid options are "store" and "append".
 #param bool ignore: Whether to ignore cases where the argument fails type conversion
 #param type: The type to which the request argument should be converted.
 #f a type raises an exception, the message in the error will be returned in the response.
 #efaults to  :class:`str`.
 #param location: The attributes of the :class:`flask.Request` object
 #o source the arguments from (ex: headers, args, etc.), can be an
 #terator. The last item listed takes precedence in the result set.
 #param choices: A container of the allowable values for the argument.
 #param help: A brief description of the argument, returned in the
 #esponse when the argument is invalid. May optionally contain
 #n "{error_msg}" interpolation token, which will be replaced with
 #he text of the error raised by the type converter.
 #param bool case_sensitive: Whether argument values in the request are
 #ase sensitive or not (this will convert all values to lowercase)
 #param bool store_missing: Whether the arguments default value should
 #e stored if the argument is missing from the request.
 #param bool trim: If enabled, trims whitespace around the argument.
 #param bool nullable: If enabled, allows null value in argument.
 #""

 #ef __init__(
 #elf,
 #ame,
 #efault=None,
 #est=None,
 #equired=False,
 #gnore=False,
 #ype=str,
 #ocation=(
 #json",
 #values",
 #,
 #hoices=(),
 #ction="store",
 #elp=None,
 #perators=("=",),
 #ase_sensitive=True,
 #tore_missing=True,
 #rim=False,
 #ullable=True,
 #:
 #elf.name = name
 #elf.default = default
 #elf.dest = dest
 #elf.required = required
 #elf.ignore = ignore
 #elf.location = location
 #elf.type = type
 #elf.choices = choices
 #elf.action = action
 #elf.help = help
 #elf.case_sensitive = case_sensitive
 #elf.operators = operators
 #elf.store_missing = store_missing
 #elf.trim = trim
 #elf.nullable = nullable

 #ef source(self, request):
 #""
 #ulls values off the request in the provided location
 #param request: The flask request object to parse arguments from
 #""
 #f isinstance(self.location, str):
 #f self.location in {"json", "get_json"}:
 #alue = request.get_json(silent=True)
 #lse:
 #alue = getattr(request, self.location, MultiDict())
 #f callable(value):
 #alue = value()
 #f value is not None:
 #eturn value
 #lse:
 #alues = MultiDict()
 #or l in self.location:
 #f l in {"json", "get_json"}:
 #alue = request.get_json(silent=True)
 #lse:
 #alue = getattr(request, l, None)
 #f callable(value):
 #alue = value()
 #f value is not None:
 #alues.update(value)
 #eturn values

 #eturn MultiDict()

 #ef convert(self, value, op):
        # Don't cast None
 #f value is None:
 #f not self.nullable:
 #aise ValueError("Must not be null!")
 #eturn None

 #lif isinstance(self.type, Model) and isinstance(value, dict):
 #eturn marshal(value, self.type)

        # and check if we're expecting a filestorage and haven't overridden `type`
        # (required because the below instantiation isn't valid for FileStorage)
 #lif isinstance(value, FileStorage) and self.type == FileStorage:
 #eturn value

 #ry:
 #eturn self.type(value, self.name, op)
 #xcept TypeError:
 #ry:
 #f self.type is decimal.Decimal:
 #eturn self.type(str(value), self.name)
 #lse:
 #eturn self.type(value, self.name)
 #xcept TypeError:
 #eturn self.type(value)

 #ef handle_validation_error(self, error, bundle_errors):
 #""
 #alled when an error is raised while parsing. Aborts the request
 #ith a 400 status and an error message

 #param error: the error that was raised
 #param bool bundle_errors: do not abort when first error occurs, return a
 #ict with the name of the argument and the error message to be
 #undled
 #""
 #rror_str = str(error)
 #rror_msg = " ".join([str(self.help), error_str]) if self.help else error_str
 #rrors = {self.name: error_msg}

 #f bundle_errors:
 #eturn ValueError(error), errors
 #bort(HTTPStatus.BAD_REQUEST, "Input payload validation failed", errors=errors)

 #ef parse(self, request, bundle_errors=False):
 #""
 #arses argument value(s) from the request, converting according to
 #he argument's type.

 #param request: The flask request object to parse arguments from
 #param bool bundle_errors: do not abort when first error occurs, return a
 #ict with the name of the argument and the error message to be
 #undled
 #""
 #undle_errors = current_app.config.get("BUNDLE_ERRORS", False) or bundle_errors
 #ource = self.source(request)

 #esults = []

        # Sentinels
 #not_found = False
 #found = True

 #or operator in self.operators:
 #ame = self.name + operator.replace("=", "", 1)
 #f name in source:
                # Account for MultiDict and regular dict
 #f hasattr(source, "getlist"):
 #alues = source.getlist(name)
 #lse:
 #alues = [source.get(name)]

 #or value in values:
 #f hasattr(value, "strip") and self.trim:
 #alue = value.strip()
 #f hasattr(value, "lower") and not self.case_sensitive:
 #alue = value.lower()

 #f hasattr(self.choices, "__iter__"):
 #elf.choices = [choice.lower() for choice in self.choices]

 #ry:
 #f self.action == "split":
 #alue = [
 #elf.convert(v, operator)
 #or v in value.split(SPLIT_CHAR)
 #
 #lse:
 #alue = self.convert(value, operator)
 #xcept Exception as error:
 #f self.ignore:
 #ontinue
 #eturn self.handle_validation_error(error, bundle_errors)

 #f self.choices and value not in self.choices:
 #sg = "The value '{0}' is not a valid choice for '{1}'.".format(
 #alue, name
 #
 #eturn self.handle_validation_error(msg, bundle_errors)

 #f name in request.unparsed_arguments:
 #equest.unparsed_arguments.pop(name)
 #esults.append(value)

 #f not results and self.required:
 #f isinstance(self.location, str):
 #ocation = _friendly_location.get(self.location, self.location)
 #lse:
 #ocations = [_friendly_location.get(loc, loc) for loc in self.location]
 #ocation = " or ".join(locations)
 #rror_msg = "Missing required parameter in {0}".format(location)
 #eturn self.handle_validation_error(error_msg, bundle_errors)

 #f not results:
 #f callable(self.default):
 #eturn self.default(), _not_found
 #lse:
 #eturn self.default, _not_found

 #f self.action == "append":
 #eturn results, _found

 #f self.action == "store" or len(results) == 1:
 #eturn results[0], _found
 #eturn results, _found

 #property
 #ef __schema__(self):
 #f self.location == "cookie":
 #eturn
 #aram = {"name": self.name, "in": LOCATIONS.get(self.location, "query")}
 #handle_arg_type(self, param)
 #f self.required:
 #aram["required"] = True
 #f self.help:
 #aram["description"] = self.help
 #f self.default is not None:
 #aram["default"] = (
 #elf.default() if callable(self.default) else self.default
 #
 #f self.action == "append":
 #aram["items"] = {"type": param["type"]}
 #f "pattern" in param:
 #aram["items"]["pattern"] = param.pop("pattern")
 #aram["type"] = "array"
 #aram["collectionFormat"] = "multi"
 #f self.action == "split":
 #aram["items"] = {"type": param["type"]}
 #aram["type"] = "array"
 #aram["collectionFormat"] = "csv"
 #f self.choices:
 #aram["enum"] = self.choices
 #eturn param


class RequestParser(object):
 #""
 #nables adding and parsing of multiple arguments in the context of a single request.
 #x::

 #rom flask_restx import RequestParser

 #arser = RequestParser()
 #arser.add_argument('foo')
 #arser.add_argument('int_bar', type=int)
 #rgs = parser.parse_args()

 #param bool trim: If enabled, trims whitespace on all arguments in this parser
 #param bool bundle_errors: If enabled, do not abort when first error occurs,
 #eturn a dict with the name of the argument and the error message to be
 #undled and return all validation errors
 #""

 #ef __init__(
 #elf,
 #rgument_class=Argument,
 #esult_class=ParseResult,
 #rim=False,
 #undle_errors=False,
 #:
 #elf.args = []
 #elf.argument_class = argument_class
 #elf.result_class = result_class
 #elf.trim = trim
 #elf.bundle_errors = bundle_errors

 #ef add_argument(self, *args, **kwargs):
 #""
 #dds an argument to be parsed.

 #ccepts either a single instance of Argument or arguments to be passed
 #nto :class:`Argument`'s constructor.

 #ee :class:`Argument`'s constructor for documentation on the available options.
 #""

 #f len(args) == 1 and isinstance(args[0], self.argument_class):
 #elf.args.append(args[0])
 #lse:
 #elf.args.append(self.argument_class(*args, **kwargs))

        # Do not know what other argument classes are out there
 #f self.trim and self.argument_class is Argument:
            # enable trim for appended element
 #elf.args[-1].trim = kwargs.get("trim", self.trim)

 #eturn self

 #ef parse_args(self, req=None, strict=False):
 #""
 #arse all arguments from the provided request and return the results as a ParseResult

 #param bool strict: if req includes args not in parser, throw 400 BadRequest exception
 #return: the parsed results as :class:`ParseResult` (or any class defined as :attr:`result_class`)
 #rtype: ParseResult
 #""
 #f req is None:
 #eq = request

 #esult = self.result_class()

        # A record of arguments not yet parsed; as each is found
        # among self.args, it will be popped out
 #eq.unparsed_arguments = (
 #ict(self.argument_class("").source(req)) if strict else {}
 #
 #rrors = {}
 #or arg in self.args:
 #alue, found = arg.parse(req, self.bundle_errors)
 #f isinstance(value, ValueError):
 #rrors.update(found)
 #ound = None
 #f found or arg.store_missing:
 #esult[arg.dest or arg.name] = value
 #f errors:
 #bort(
 #TTPStatus.BAD_REQUEST, "Input payload validation failed", errors=errors
 #

 #f strict and req.unparsed_arguments:
 #rguments = ", ".join(req.unparsed_arguments.keys())
 #sg = "Unknown arguments: {0}".format(arguments)
 #aise exceptions.BadRequest(msg)

 #eturn result

 #ef copy(self):
 #""Creates a copy of this RequestParser with the same set of arguments"""
 #arser_copy = self.__class__(self.argument_class, self.result_class)
 #arser_copy.args = deepcopy(self.args)
 #arser_copy.trim = self.trim
 #arser_copy.bundle_errors = self.bundle_errors
 #eturn parser_copy

 #ef replace_argument(self, name, *args, **kwargs):
 #""Replace the argument matching the given name with a new version."""
 #ew_arg = self.argument_class(name, *args, **kwargs)
 #or index, arg in enumerate(self.args[:]):
 #f new_arg.name == arg.name:
 #el self.args[index]
 #elf.args.append(new_arg)
 #reak
 #eturn self

 #ef remove_argument(self, name):
 #""Remove the argument matching the given name."""
 #or index, arg in enumerate(self.args[:]):
 #f name == arg.name:
 #el self.args[index]
 #reak
 #eturn self

 #property
 #ef __schema__(self):
 #arams = []
 #ocations = set()
 #or arg in self.args:
 #aram = arg.__schema__
 #f param:
 #arams.append(param)
 #ocations.add(param["in"])
 #f "body" in locations and "formData" in locations:
 #aise SpecsError("Can't use formData and body at the same time")
 #eturn params


def _handle_arg_type(arg, param):
 #f isinstance(arg.type, Hashable) and arg.type in PY_TYPES:
 #aram["type"] = PY_TYPES[arg.type]
 #lif hasattr(arg.type, "__apidoc__"):
 #aram["type"] = arg.type.__apidoc__["name"]
 #aram["in"] = "body"
 #lif hasattr(arg.type, "__schema__"):
 #aram.update(arg.type.__schema__)
 #lif arg.location == "files":
 #aram["type"] = "file"
 #lse:
 #aram["type"] = "string"
