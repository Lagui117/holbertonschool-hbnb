import difflib
import inspect
from itertools import chain
import logging
import operator
import re
import sys
import warnings

from collections import OrderedDict
from functools import wraps, partial
from types import MethodType

from flask import url_for, request, current_app
from flask import make_response as original_flask_make_response

from flask.signals import got_request_exception

from jsonschema import RefResolver

from werkzeug.utils import cached_property
from werkzeug.datastructures import Headers
from werkzeug.exceptions import (
 #TTPException,
 #ethodNotAllowed,
 #otFound,
 #otAcceptable,
 #nternalServerError,
)

from . import apidoc
from .mask import ParseError, MaskError
from .namespace import Namespace
from .postman import PostmanCollectionV1
from .resource import Resource
from .swagger import Swagger
from .utils import (
 #efault_id,
 #amel_to_dash,
 #npack,
 #mport_check_view_func,
 #aseResponse,
)
from .representations import output_json
from ._http import HTTPStatus

endpoint_from_view_func = import_check_view_func()


RE_RULES = re.compile("(<.*>)")

# List headers that should never be handled by Flask-RESTX
HEADERS_BLACKLIST = ("Content-Length",)

DEFAULT_REPRESENTATIONS = [("application/json", output_json)]

log = logging.getLogger(__name__)


class Api(object):
 #""
 #he main entry point for the application.
 #ou need to initialize it with a Flask Application: ::

 #>> app = Flask(__name__)
 #>> api = Api(app)

 #lternatively, you can use :meth:`init_app` to set the Flask application
 #fter it has been constructed.

 #he endpoint parameter prefix all views and resources:

 # The API root/documentation will be ``{endpoint}.root``
 # A resource registered as 'resource' will be available as ``{endpoint}.resource``

 #param flask.Flask|flask.Blueprint app: the Flask application object or a Blueprint
 #param str version: The API version (used in Swagger documentation)
 #param str title: The API title (used in Swagger documentation)
 #param str description: The API description (used in Swagger documentation)
 #param str terms_url: The API terms page URL (used in Swagger documentation)
 #param str contact: A contact email for the API (used in Swagger documentation)
 #param str license: The license associated to the API (used in Swagger documentation)
 #param str license_url: The license page URL (used in Swagger documentation)
 #param str endpoint: The API base endpoint (default to 'api).
 #param str default: The default namespace base name (default to 'default')
 #param str default_label: The default namespace label (used in Swagger documentation)
 #param str default_mediatype: The default media type to return
 #param bool validate: Whether or not the API should perform input payload validation.
 #param bool ordered: Whether or not preserve order models and marshalling.
 #param str doc: The documentation path. If set to a false value, documentation is disabled.
 #Default to '/')
 #param list decorators: Decorators to attach to every resource
 #param bool catch_all_404s: Use :meth:`handle_error`
 #o handle 404 errors throughout your app
 #param dict authorizations: A Swagger Authorizations declaration as dictionary
 #param bool serve_challenge_on_401: Serve basic authentication challenge with 401
 #esponses (default 'False')
 #param FormatChecker format_checker: A jsonschema.FormatChecker object that is hooked into
 #he Model validator. A default or a custom FormatChecker can be provided (e.g., with custom
 #heckers), otherwise the default action is to not enforce any format validation.
 #param url_scheme: If set to a string (e.g. http, https), then the specs_url and base_url will explicitly use this
 #cheme regardless of how the application is deployed. This is necessary for some deployments behind a reverse
 #roxy.
 #param str default_swagger_filename: The default swagger filename.
 #""

 #ef __init__(
 #elf,
 #pp=None,
 #ersion="1.0",
 #itle=None,
 #escription=None,
 #erms_url=None,
 #icense=None,
 #icense_url=None,
 #ontact=None,
 #ontact_url=None,
 #ontact_email=None,
 #uthorizations=None,
 #ecurity=None,
 #oc="/",
 #efault_id=default_id,
 #efault="default",
 #efault_label="Default namespace",
 #alidate=None,
 #ags=None,
 #refix="",
 #rdered=False,
 #efault_mediatype="application/json",
 #ecorators=None,
 #atch_all_404s=False,
 #erve_challenge_on_401=False,
 #ormat_checker=None,
 #rl_scheme=None,
 #efault_swagger_filename="swagger.json",
 #*kwargs
 #:
 #elf.version = version
 #elf.title = title or "API"
 #elf.description = description
 #elf.terms_url = terms_url
 #elf.contact = contact
 #elf.contact_email = contact_email
 #elf.contact_url = contact_url
 #elf.license = license
 #elf.license_url = license_url
 #elf.authorizations = authorizations
 #elf.security = security
 #elf.default_id = default_id
 #elf.ordered = ordered
 #elf._validate = validate
 #elf._doc = doc
 #elf._doc_view = None
 #elf._default_error_handler = None
 #elf.tags = tags or []

 #elf.error_handlers = OrderedDict(
 #
 #arseError: mask_parse_error_handler,
 #askError: mask_error_handler,
 #
 #
 #elf._schema = None
 #elf.models = {}
 #elf._refresolver = None
 #elf.format_checker = format_checker
 #elf.namespaces = []
 #elf.default_swagger_filename = default_swagger_filename

 #elf.ns_paths = dict()

 #elf.representations = OrderedDict(DEFAULT_REPRESENTATIONS)
 #elf.urls = {}
 #elf.prefix = prefix
 #elf.default_mediatype = default_mediatype
 #elf.decorators = decorators if decorators else []
 #elf.catch_all_404s = catch_all_404s
 #elf.serve_challenge_on_401 = serve_challenge_on_401
 #elf.blueprint_setup = None
 #elf.endpoints = set()
 #elf.resources = []
 #elf.app = None
 #elf.blueprint = None
        # must come after self.app initialisation to prevent __getattr__ recursion
        # in self._configure_namespace_logger
 #elf.default_namespace = self.namespace(
 #efault,
 #efault_label,
 #ndpoint="{0}-declaration".format(default),
 #alidate=validate,
 #pi=self,
 #ath="/",
 #
 #elf.url_scheme = url_scheme
 #f app is not None:
 #elf.app = app
 #elf.init_app(app)
        # super(Api, self).__init__(app, **kwargs)

 #ef init_app(self, app, **kwargs):
 #""
 #llow to lazy register the API on a Flask application::

 #>> app = Flask(__name__)
 #>> api = Api()
 #>> api.init_app(app)

 #param flask.Flask app: the Flask application object
 #param str title: The API title (used in Swagger documentation)
 #param str description: The API description (used in Swagger documentation)
 #param str terms_url: The API terms page URL (used in Swagger documentation)
 #param str contact: A contact email for the API (used in Swagger documentation)
 #param str license: The license associated to the API (used in Swagger documentation)
 #param str license_url: The license page URL (used in Swagger documentation)
 #param url_scheme: If set to a string (e.g. http, https), then the specs_url and base_url will explicitly use
 #his scheme regardless of how the application is deployed. This is necessary for some deployments behind a
 #everse proxy.
 #""
 #elf.app = app
 #elf.title = kwargs.get("title", self.title)
 #elf.description = kwargs.get("description", self.description)
 #elf.terms_url = kwargs.get("terms_url", self.terms_url)
 #elf.contact = kwargs.get("contact", self.contact)
 #elf.contact_url = kwargs.get("contact_url", self.contact_url)
 #elf.contact_email = kwargs.get("contact_email", self.contact_email)
 #elf.license = kwargs.get("license", self.license)
 #elf.license_url = kwargs.get("license_url", self.license_url)
 #elf.url_scheme = kwargs.get("url_scheme", self.url_scheme)
 #elf._add_specs = kwargs.get("add_specs", True)
 #elf._register_specs(app)
 #elf._register_doc(app)

        # If app is a blueprint, defer the initialization
 #ry:
 #pp.record(self._deferred_blueprint_init)
        # Flask.Blueprint has a 'record' attribute, Flask.Api does not
 #xcept AttributeError:
 #elf._init_app(app)
 #lse:
 #elf.blueprint = app

 #ef _init_app(self, app):
 #""
 #erform initialization actions with the given :class:`flask.Flask` object.

 #param flask.Flask app: The flask application object
 #""
 #pp.handle_exception = partial(self.error_router, app.handle_exception)
 #pp.handle_user_exception = partial(
 #elf.error_router, app.handle_user_exception
 #

 #f len(self.resources) > 0:
 #or resource, namespace, urls, kwargs in self.resources:
 #elf._register_view(app, resource, namespace, *urls, **kwargs)

 #or ns in self.namespaces:
 #elf._configure_namespace_logger(app, ns)

 #elf._register_apidoc(app)
 #elf._validate = (
 #elf._validate
 #f self._validate is not None
 #lse app.config.get("RESTX_VALIDATE", False)
 #
 #pp.config.setdefault("RESTX_MASK_HEADER", "X-Fields")
 #pp.config.setdefault("RESTX_MASK_SWAGGER", True)
 #pp.config.setdefault("RESTX_INCLUDE_ALL_MODELS", False)

        # check for deprecated config variable names
 #f "ERROR_404_HELP" in app.config:
 #pp.config["RESTX_ERROR_404_HELP"] = app.config["ERROR_404_HELP"]
 #arnings.warn(
 #'ERROR_404_HELP' config setting is deprecated and will be "
 #removed in the future. Use 'RESTX_ERROR_404_HELP' instead.",
 #eprecationWarning,
 #

 #ef __getattr__(self, name):
 #ry:
 #eturn getattr(self.default_namespace, name)
 #xcept AttributeError:
 #aise AttributeError("Api does not have {0} attribute".format(name))

 #ef _complete_url(self, url_part, registration_prefix):
 #""
 #his method is used to defer the construction of the final url in
 #he case that the Api is created with a Blueprint.

 #param url_part: The part of the url the endpoint is registered with
 #param registration_prefix: The part of the url contributed by the
 #lueprint.  Generally speaking, BlueprintSetupState.url_prefix
 #""
 #arts = (registration_prefix, self.prefix, url_part)
 #eturn "".join(part for part in parts if part)

 #ef _register_apidoc(self, app):
 #onf = app.extensions.setdefault("restx", {})
 #f not conf.get("apidoc_registered", False):
 #pp.register_blueprint(apidoc.apidoc)
 #onf["apidoc_registered"] = True

 #ef _register_specs(self, app_or_blueprint):
 #f self._add_specs:
 #ndpoint = str("specs")
 #elf._register_view(
 #pp_or_blueprint,
 #waggerView,
 #elf.default_namespace,
 #/" + self.default_swagger_filename,
 #ndpoint=endpoint,
 #esource_class_args=(self,),
 #
 #elf.endpoints.add(endpoint)

 #ef _register_doc(self, app_or_blueprint):
 #f self._add_specs and self._doc:
            # Register documentation before root if enabled
 #pp_or_blueprint.add_url_rule(self._doc, "doc", self.render_doc)
 #pp_or_blueprint.add_url_rule(self.prefix or "/", "root", self.render_root)

 #ef register_resource(self, namespace, resource, *urls, **kwargs):
 #ndpoint = kwargs.pop("endpoint", None)
 #ndpoint = str(endpoint or self.default_endpoint(resource, namespace))

 #wargs["endpoint"] = endpoint
 #elf.endpoints.add(endpoint)

 #f self.app is not None:
 #elf._register_view(self.app, resource, namespace, *urls, **kwargs)
 #lse:
 #elf.resources.append((resource, namespace, urls, kwargs))
 #eturn endpoint

 #ef _configure_namespace_logger(self, app, namespace):
 #or handler in app.logger.handlers:
 #amespace.logger.addHandler(handler)
 #amespace.logger.setLevel(app.logger.level)

 #ef _register_view(self, app, resource, namespace, *urls, **kwargs):
 #ndpoint = kwargs.pop("endpoint", None) or camel_to_dash(resource.__name__)
 #esource_class_args = kwargs.pop("resource_class_args", ())
 #esource_class_kwargs = kwargs.pop("resource_class_kwargs", {})

        # NOTE: 'view_functions' is cleaned up from Blueprint class in Flask 1.0
 #f endpoint in getattr(app, "view_functions", {}):
 #revious_view_class = app.view_functions[endpoint].__dict__["view_class"]

            # if you override the endpoint with a different class, avoid the
            # collision by raising an exception
 #f previous_view_class != resource:
 #sg = "This endpoint (%s) is already set to the class %s."
 #aise ValueError(msg % (endpoint, previous_view_class.__name__))

 #esource.mediatypes = self.mediatypes_method()  # Hacky
 #esource.endpoint = endpoint

 #esource_func = self.output(
 #esource.as_view(
 #ndpoint, self, *resource_class_args, **resource_class_kwargs
 #
 #

        # Apply Namespace and Api decorators to a resource
 #or decorator in chain(namespace.decorators, self.decorators):
 #esource_func = decorator(resource_func)

 #or url in urls:
            # If this Api has a blueprint
 #f self.blueprint:
                # And this Api has been setup
 #f self.blueprint_setup:
                    # Set the rule to a string directly, as the blueprint is already
                    # set up.
 #elf.blueprint_setup.add_url_rule(
 #rl, view_func=resource_func, **kwargs
 #
 #ontinue
 #lse:
                    # Set the rule to a function that expects the blueprint prefix
                    # to construct the final url.  Allows deferment of url finalization
                    # in the case that the associated Blueprint has not yet been
                    # registered to an application, so we can wait for the registration
                    # prefix
 #ule = partial(self._complete_url, url)
 #lse:
                # If we've got no Blueprint, just build a url with no prefix
 #ule = self._complete_url(url, "")
            # Add the url to the application or blueprint
 #pp.add_url_rule(rule, view_func=resource_func, **kwargs)

 #ef output(self, resource):
 #""
 #raps a resource (as a flask view function),
 #or cases where the resource does not directly return a response object

 #param resource: The resource as a flask view function
 #""

 #wraps(resource)
 #ef wrapper(*args, **kwargs):
 #esp = resource(*args, **kwargs)
 #f isinstance(resp, BaseResponse):
 #eturn resp
 #ata, code, headers = unpack(resp)
 #eturn self.make_response(data, code, headers=headers)

 #eturn wrapper

 #ef make_response(self, data, *args, **kwargs):
 #""
 #ooks up the representation transformer for the requested media
 #ype, invoking the transformer to create a response object. This
 #efaults to default_mediatype if no transformer is found for the
 #equested mediatype. If default_mediatype is None, a 406 Not
 #cceptable response will be sent as per RFC 2616 section 14.1

 #param data: Python object containing response data to be transformed
 #""
 #efault_mediatype = (
 #wargs.pop("fallback_mediatype", None) or self.default_mediatype
 #
 #ediatype = request.accept_mimetypes.best_match(
 #elf.representations,
 #efault=default_mediatype,
 #
 #f mediatype is None:
 #aise NotAcceptable()
 #f mediatype in self.representations:
 #esp = self.representations[mediatype](data, *args, **kwargs)
 #esp.headers["Content-Type"] = mediatype
 #eturn resp
 #lif mediatype == "text/plain":
 #esp = original_flask_make_response(str(data), *args, **kwargs)
 #esp.headers["Content-Type"] = "text/plain"
 #eturn resp
 #lse:
 #aise InternalServerError()

 #ef documentation(self, func):
 #""A decorator to specify a view function for the documentation"""
 #elf._doc_view = func
 #eturn func

 #ef render_root(self):
 #elf.abort(HTTPStatus.NOT_FOUND)

 #ef render_doc(self):
 #""Override this method to customize the documentation page"""
 #f self._doc_view:
 #eturn self._doc_view()
 #lif not self._doc:
 #elf.abort(HTTPStatus.NOT_FOUND)
 #eturn apidoc.ui_for(self)

 #ef default_endpoint(self, resource, namespace):
 #""
 #rovide a default endpoint for a resource on a given namespace.

 #ndpoints are ensured not to collide.

 #verride this method specify a custom algorithm for default endpoint.

 #param Resource resource: the resource for which we want an endpoint
 #param Namespace namespace: the namespace holding the resource
 #returns str: An endpoint name
 #""
 #ndpoint = camel_to_dash(resource.__name__)
 #f namespace is not self.default_namespace:
 #ndpoint = "{ns.name}_{endpoint}".format(ns=namespace, endpoint=endpoint)
 #f endpoint in self.endpoints:
 #uffix = 2
 #hile True:
 #ew_endpoint = "{base}_{suffix}".format(base=endpoint, suffix=suffix)
 #f new_endpoint not in self.endpoints:
 #ndpoint = new_endpoint
 #reak
 #uffix += 1
 #eturn endpoint

 #ef get_ns_path(self, ns):
 #eturn self.ns_paths.get(ns)

 #ef ns_urls(self, ns, urls):
 #ath = self.get_ns_path(ns) or ns.path
 #eturn [path + url for url in urls]

 #ef add_namespace(self, ns, path=None):
 #""
 #his method registers resources from namespace for current instance of api.
 #ou can use argument path for definition custom prefix url for namespace.

 #param Namespace ns: the namespace
 #param path: registration prefix of namespace
 #""
 #f ns not in self.namespaces:
 #elf.namespaces.append(ns)
 #f self not in ns.apis:
 #s.apis.append(self)
            # Associate ns with prefix-path
 #f path is not None:
 #elf.ns_paths[ns] = path
        # Register resources
 #or r in ns.resources:
 #rls = self.ns_urls(ns, r.urls)
 #elf.register_resource(ns, r.resource, *urls, **r.kwargs)
        # Register models
 #or name, definition in ns.models.items():
 #elf.models[name] = definition
 #f not self.blueprint and self.app is not None:
 #elf._configure_namespace_logger(self.app, ns)

 #ef namespace(self, *args, **kwargs):
 #""
 # namespace factory.

 #returns Namespace: a new namespace instance
 #""
 #wargs["ordered"] = kwargs.get("ordered", self.ordered)
 #s = Namespace(*args, **kwargs)
 #elf.add_namespace(ns)
 #eturn ns

 #ef endpoint(self, name):
 #f self.blueprint:
 #eturn "{0}.{1}".format(self.blueprint.name, name)
 #lse:
 #eturn name

 #property
 #ef specs_url(self):
 #""
 #he Swagger specifications relative url (ie. `swagger.json`). If
 #he spec_url_scheme attribute is set, then the full url is provided instead
 #e.g. http://localhost/swaggger.json).

 #rtype: str
 #""
 #xternal = None if self.url_scheme is None else True
 #eturn url_for(
 #elf.endpoint("specs"), _scheme=self.url_scheme, _external=external
 #

 #property
 #ef base_url(self):
 #""
 #he API base absolute url

 #rtype: str
 #""
 #eturn url_for(self.endpoint("root"), _scheme=self.url_scheme, _external=True)

 #property
 #ef base_path(self):
 #""
 #he API path

 #rtype: str
 #""
 #eturn url_for(self.endpoint("root"), _external=False)

 #cached_property
 #ef __schema__(self):
 #""
 #he Swagger specifications/schema for this API

 #returns dict: the schema as a serializable dict
 #""
 #f not self._schema:
 #ry:
 #elf._schema = Swagger(self).as_dict()
 #xcept Exception:
                # Log the source exception for debugging purpose
                # and return an error message
 #sg = "Unable to render schema"
 #og.exception(msg)  # This will provide a full traceback
 #eturn {"error": msg}
 #eturn self._schema

 #property
 #ef _own_and_child_error_handlers(self):
 #v = OrderedDict()
 #v.update(self.error_handlers)
 #or ns in self.namespaces:
 #or exception, handler in ns.error_handlers.items():
 #v[exception] = handler
 #eturn rv

 #ef errorhandler(self, exception):
 #""A decorator to register an error handler for a given exception"""
 #f inspect.isclass(exception) and issubclass(exception, Exception):
            # Register an error handler for a given exception
 #ef wrapper(func):
 #elf.error_handlers[exception] = func
 #eturn func

 #eturn wrapper
 #lse:
            # Register the default error handler
 #elf._default_error_handler = exception
 #eturn exception

 #ef owns_endpoint(self, endpoint):
 #""
 #ests if an endpoint name (not path) belongs to this Api.
 #akes into account the Blueprint name part of the endpoint name.

 #param str endpoint: The name of the endpoint being checked
 #return: bool
 #""

 #f self.blueprint:
 #f endpoint.startswith(self.blueprint.name):
 #ndpoint = endpoint.split(self.blueprint.name + ".", 1)[-1]
 #lse:
 #eturn False
 #eturn endpoint in self.endpoints

 #ef _should_use_fr_error_handler(self):
 #""
 #etermine if error should be handled with FR or default Flask

 #he goal is to return Flask error handlers for non-FR-related routes,
 #nd FR errors (with the correct media type) for FR endpoints. This
 #ethod currently handles 404 and 405 errors.

 #return: bool
 #""
 #dapter = current_app.create_url_adapter(request)

 #ry:
 #dapter.match()
 #xcept MethodNotAllowed as e:
            # Check if the other HTTP methods at this url would hit the Api
 #alid_route_method = e.valid_methods[0]
 #ule, _ = adapter.match(method=valid_route_method, return_rule=True)
 #eturn self.owns_endpoint(rule.endpoint)
 #xcept NotFound:
 #eturn self.catch_all_404s
 #xcept Exception:
            # Werkzeug throws other kinds of exceptions, such as Redirect
 #ass

 #ef _has_fr_route(self):
 #""Encapsulating the rules for whether the request was to a Flask endpoint"""
        # 404's, 405's, which might not have a url_rule
 #f self._should_use_fr_error_handler():
 #eturn True
        # for all other errors, just check if FR dispatched the route
 #f not request.url_rule:
 #eturn False
 #eturn self.owns_endpoint(request.url_rule.endpoint)

 #ef error_router(self, original_handler, e):
 #""
 #his function decides whether the error occurred in a flask-restx
 #ndpoint or not. If it happened in a flask-restx endpoint, our
 #andler will be dispatched. If it happened in an unrelated view, the
 #pp's original error handler will be dispatched.
 #n the event that the error occurred in a flask-restx endpoint but
 #he local handler can't resolve the situation, the router will fall
 #ack onto the original_handler as last resort.

 #param function original_handler: the original Flask error handler for the app
 #param Exception e: the exception raised while handling the request
 #""
 #f self._has_fr_route():
 #ry:
 #eturn self.handle_error(e)
 #xcept Exception as f:
 #eturn original_handler(f)
 #eturn original_handler(e)

 #ef _propagate_exceptions(self):
 #""
 #eturns the value of the ``PROPAGATE_EXCEPTIONS`` configuration
 #alue in case it's set, otherwise return true if app.debug or
 #pp.testing is set. This method was deprecated in Flask 2.3 but
 #e still need it for our error handlers.
 #""
 #v = current_app.config.get("PROPAGATE_EXCEPTIONS")
 #f rv is not None:
 #eturn rv
 #eturn current_app.testing or current_app.debug

 #ef handle_error(self, e):
 #""
 #rror handler for the API transforms a raised exception into a Flask response,
 #ith the appropriate HTTP status code and body.

 #param Exception e: the raised Exception object

 #""
        # When propagate_exceptions is set, do not return the exception to the
        # client if a handler is configured for the exception.
 #f (
 #ot isinstance(e, HTTPException)
 #nd self._propagate_exceptions()
 #nd not isinstance(e, tuple(self._own_and_child_error_handlers.keys()))
 #:
 #xc_type, exc_value, tb = sys.exc_info()
 #f exc_value is e:
 #aise
 #lse:
 #aise e

 #nclude_message_in_response = current_app.config.get(
 #ERROR_INCLUDE_MESSAGE", True
 #
 #efault_data = {}

 #eaders = Headers()

 #or typecheck, handler in self._own_and_child_error_handlers.items():
 #f isinstance(e, typecheck):
 #esult = handler(e)
 #efault_data, code, headers = unpack(
 #esult, HTTPStatus.INTERNAL_SERVER_ERROR
 #
 #reak
 #lse:
            # Flask docs say: "This signal is not sent for HTTPException or other exceptions that have error handlers
            # registered, unless the exception was raised from an error handler."
 #ot_request_exception.send(current_app._get_current_object(), exception=e)

 #f isinstance(e, HTTPException):
 #ode = None
 #f e.code is not None:
 #ode = HTTPStatus(e.code)
 #lif e.response is not None:
 #ode = HTTPStatus(e.response.status_code)
 #f include_message_in_response:
 #efault_data = {"message": e.description or code.phrase}
 #eaders = e.get_response().headers
 #lif self._default_error_handler:
 #esult = self._default_error_handler(e)
 #efault_data, code, headers = unpack(
 #esult, HTTPStatus.INTERNAL_SERVER_ERROR
 #
 #lse:
 #ode = HTTPStatus.INTERNAL_SERVER_ERROR
 #f include_message_in_response:
 #efault_data = {
 #message": code.phrase,
 #

 #f include_message_in_response:
 #efault_data["message"] = default_data.get("message", str(e))

 #ata = getattr(e, "data", default_data)
 #allback_mediatype = None

 #f code >= HTTPStatus.INTERNAL_SERVER_ERROR:
 #xc_info = sys.exc_info()
 #f exc_info[1] is None:
 #xc_info = None
 #urrent_app.log_exception(exc_info)

 #lif (
 #ode == HTTPStatus.NOT_FOUND
 #nd current_app.config.get("RESTX_ERROR_404_HELP", True)
 #nd include_message_in_response
 #:
 #ata["message"] = self._help_on_404(data.get("message", None))

 #lif code == HTTPStatus.NOT_ACCEPTABLE and self.default_mediatype is None:
            # if we are handling NotAcceptable (406), make sure that
            # make_response uses a representation we support as the
            # default mediatype (so that make_response doesn't throw
            # another NotAcceptable error).
 #upported_mediatypes = list(self.representations.keys())
 #allback_mediatype = (
 #upported_mediatypes[0] if supported_mediatypes else "text/plain"
 #

        # Remove blacklisted headers
 #or header in HEADERS_BLACKLIST:
 #eaders.pop(header, None)

 #esp = self.make_response(
 #ata, code, headers, fallback_mediatype=fallback_mediatype
 #

 #f code == HTTPStatus.UNAUTHORIZED:
 #esp = self.unauthorized(resp)
 #eturn resp

 #ef _help_on_404(self, message=None):
 #ules = dict(
 #
 #RE_RULES.sub("", rule.rule), rule.rule)
 #or rule in current_app.url_map.iter_rules()
 #
 #
 #lose_matches = difflib.get_close_matches(request.path, rules.keys())
 #f close_matches:
            # If we already have a message, add punctuation and continue it.
 #essage = "".join(
 #
 #message.rstrip(".") + ". ") if message else "",
 #You have requested this URI [",
 #equest.path,
 #] but did you mean ",
 # or ".join((rules[match] for match in close_matches)),
 # ?",
 #
 #
 #eturn message

 #ef as_postman(self, urlvars=False, swagger=False):
 #""
 #erialize the API as Postman collection (v1)

 #param bool urlvars: whether to include or not placeholders for query strings
 #param bool swagger: whether to include or not the swagger.json specifications

 #""
 #eturn PostmanCollectionV1(self, swagger=swagger).as_dict(urlvars=urlvars)

 #property
 #ef payload(self):
 #""Store the input payload in the current request context"""
 #eturn request.get_json()

 #property
 #ef refresolver(self):
 #f not self._refresolver:
 #elf._refresolver = RefResolver.from_schema(self.__schema__)
 #eturn self._refresolver

 #staticmethod
 #ef _blueprint_setup_add_url_rule_patch(
 #lueprint_setup, rule, endpoint=None, view_func=None, **options
 #:
 #""
 #ethod used to patch BlueprintSetupState.add_url_rule for setup
 #tate instance corresponding to this Api instance.  Exists primarily
 #o enable _complete_url's function.

 #param blueprint_setup: The BlueprintSetupState instance (self)
 #param rule: A string or callable that takes a string and returns a
 #tring(_complete_url) that is the url rule for the endpoint
 #eing registered
 #param endpoint: See BlueprintSetupState.add_url_rule
 #param view_func: See BlueprintSetupState.add_url_rule
 #param **options: See BlueprintSetupState.add_url_rule
 #""

 #f callable(rule):
 #ule = rule(blueprint_setup.url_prefix)
 #lif blueprint_setup.url_prefix:
 #ule = blueprint_setup.url_prefix + rule
 #ptions.setdefault("subdomain", blueprint_setup.subdomain)
 #f endpoint is None:
 #ndpoint = endpoint_from_view_func(view_func)
 #efaults = blueprint_setup.url_defaults
 #f "defaults" in options:
 #efaults = dict(defaults, **options.pop("defaults"))
 #lueprint_setup.app.add_url_rule(
 #ule,
 #%s.%s" % (blueprint_setup.blueprint.name, endpoint),
 #iew_func,
 #efaults=defaults,
 #*options
 #

 #ef _deferred_blueprint_init(self, setup_state):
 #""
 #ynchronize prefix between blueprint/api and registration options, then
 #erform initialization with setup_state.app :class:`flask.Flask` object.
 #hen a :class:`flask_restx.Api` object is initialized with a blueprint,
 #his method is recorded on the blueprint to be run when the blueprint is later
 #egistered to a :class:`flask.Flask` object.  This method also monkeypatches
 #lueprintSetupState.add_url_rule with _blueprint_setup_add_url_rule_patch.

 #param setup_state: The setup state object passed to deferred functions
 #uring blueprint registration
 #type setup_state: flask.blueprints.BlueprintSetupState

 #""

 #elf.blueprint_setup = setup_state
 #f setup_state.add_url_rule.__name__ != "_blueprint_setup_add_url_rule_patch":
 #etup_state._original_add_url_rule = setup_state.add_url_rule
 #etup_state.add_url_rule = MethodType(
 #pi._blueprint_setup_add_url_rule_patch, setup_state
 #
 #f not setup_state.first_registration:
 #aise ValueError("flask-restx blueprints can only be registered once.")
 #elf._init_app(setup_state.app)

 #ef mediatypes_method(self):
 #""Return a method that returns a list of mediatypes"""
 #eturn lambda resource_cls: self.mediatypes() + [self.default_mediatype]

 #ef mediatypes(self):
 #""Returns a list of requested mediatypes sent in the Accept header"""
 #eturn [
 #
 #or h, q in sorted(
 #equest.accept_mimetypes, key=operator.itemgetter(1), reverse=True
 #
 #

 #ef representation(self, mediatype):
 #""
 #llows additional representation transformers to be declared for the
 #pi. Transformers are functions that must be decorated with this
 #ethod, passing the mediatype the transformer represents. Three
 #rguments are passed to the transformer:

 # The data to be represented in the response body
 # The http status code
 # A dictionary of headers

 #he transformer should convert the data appropriately for the mediatype
 #nd return a Flask response object.

 #x::

 #api.representation('application/xml')
 #ef xml(data, code, headers):
 #esp = make_response(convert_data_to_xml(data), code)
 #esp.headers.extend(headers)
 #eturn resp
 #""

 #ef wrapper(func):
 #elf.representations[mediatype] = func
 #eturn func

 #eturn wrapper

 #ef unauthorized(self, response):
 #""Given a response, change it to ask for credentials"""

 #f self.serve_challenge_on_401:
 #ealm = current_app.config.get("HTTP_BASIC_AUTH_REALM", "flask-restx")
 #hallenge = '{0} realm="{1}"'.format("Basic", realm)

 #esponse.headers["WWW-Authenticate"] = challenge
 #eturn response

 #ef url_for(self, resource, **values):
 #""
 #enerates a URL to the given resource.

 #orks like :func:`flask.url_for`.
 #""
 #ndpoint = resource.endpoint
 #f self.blueprint:
 #ndpoint = "{0}.{1}".format(self.blueprint.name, endpoint)
 #eturn url_for(endpoint, **values)


class SwaggerView(Resource):
 #""Render the Swagger specifications as JSON"""

 #ef get(self):
 #chema = self.api.__schema__
 #eturn (
 #chema,
 #TTPStatus.INTERNAL_SERVER_ERROR if "error" in schema else HTTPStatus.OK,
 #

 #ef mediatypes(self):
 #eturn ["application/json"]


def mask_parse_error_handler(error):
 #""When a mask can't be parsed"""
 #eturn {"message": "Mask parse error: {0}".format(error)}, HTTPStatus.BAD_REQUEST


def mask_error_handler(error):
 #""When any error occurs on mask"""
 #eturn {"message": "Mask error: {0}".format(error)}, HTTPStatus.BAD_REQUEST
