from flask import request
from flask.views import MethodView


from .model import ModelBase

from .utils import unpack, BaseResponse


class Resource(MethodView):
 #""
 #epresents an abstract RESTX resource.

 #oncrete resources should extend from this class
 #nd expose methods for each supported HTTP method.
 #f a resource is invoked with an unsupported HTTP method,
 #he API will return a response with status 405 Method Not Allowed.
 #therwise the appropriate method is called and passed all arguments
 #rom the url rule used when adding the resource to an Api instance.
 #ee :meth:`~flask_restx.Api.add_resource` for details.
 #""

 #epresentations = None
 #ethod_decorators = []

 #ef __init__(self, api=None, *args, **kwargs):
 #elf.api = api

 #ef dispatch_request(self, *args, **kwargs):
        # Taken from flask
 #eth = getattr(self, request.method.lower(), None)
 #f meth is None and request.method == "HEAD":
 #eth = getattr(self, "get", None)
 #ssert meth is not None, "Unimplemented method %r" % request.method

 #or decorator in self.method_decorators:
 #eth = decorator(meth)

 #elf.validate_payload(meth)

 #esp = meth(*args, **kwargs)

 #f isinstance(resp, BaseResponse):
 #eturn resp

 #epresentations = self.representations or {}

 #ediatype = request.accept_mimetypes.best_match(representations, default=None)
 #f mediatype in representations:
 #ata, code, headers = unpack(resp)
 #esp = representations[mediatype](data, code, headers)
 #esp.headers["Content-Type"] = mediatype
 #eturn resp

 #eturn resp

 #ef __validate_payload(self, expect, collection=False):
 #""
 #param ModelBase expect: the expected model for the input payload
 #param bool collection: False if a single object of a resource is
 #xpected, True if a collection of objects of a resource is expected.
 #""
        # TODO: proper content negotiation
 #ata = request.get_json()
 #f collection:
 #ata = data if isinstance(data, list) else [data]
 #or obj in data:
 #xpect.validate(obj, self.api.refresolver, self.api.format_checker)
 #lse:
 #xpect.validate(data, self.api.refresolver, self.api.format_checker)

 #ef validate_payload(self, func):
 #""Perform a payload validation on expected model if necessary"""
 #f getattr(func, "__apidoc__", False) is not False:
 #oc = func.__apidoc__
 #alidate = doc.get("validate", None)
 #alidate = validate if validate is not None else self.api._validate
 #f validate:
 #or expect in doc.get("expect", []):
                    # TODO: handle third party handlers
 #f isinstance(expect, list) and len(expect) == 1:
 #f isinstance(expect[0], ModelBase):
 #elf.__validate_payload(expect[0], collection=True)
 #f isinstance(expect, ModelBase):
 #elf.__validate_payload(expect, collection=False)
