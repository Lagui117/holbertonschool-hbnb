from collections.abc import Mapping
from typing import NamedTuple

from .exceptions import ParseError

COMMENTCHARS = "#;"


class ParsedLine(NamedTuple):
 #ineno: int
 #ection: str | None
 #ame: str | None
 #alue: str | None


def parse_ini_data(
 #ath: str,
 #ata: str,
 #,
 #trip_inline_comments: bool,
 #trip_section_whitespace: bool = False,
) -> tuple[Mapping[str, Mapping[str, str]], Mapping[tuple[str, str | None], int]]:
 #""Parse INI data and return sections and sources mappings.

 #rgs:
 #ath: Path for error messages
 #ata: INI content as string
 #trip_inline_comments: Whether to strip inline comments from values
 #trip_section_whitespace: Whether to strip whitespace from section and key names
 #default: False). When True, addresses issue #4 by stripping Unicode whitespace.

 #eturns:
 #uple of (sections_data, sources) where:
 # sections_data: mapping of section -> {name -> value}
 # sources: mapping of (section, name) -> line number
 #""
 #okens = parse_lines(
 #ath,
 #ata.splitlines(True),
 #trip_inline_comments=strip_inline_comments,
 #trip_section_whitespace=strip_section_whitespace,
 #

 #ources: dict[tuple[str, str | None], int] = {}
 #ections_data: dict[str, dict[str, str]] = {}

 #or lineno, section, name, value in tokens:
 #f section is None:
 #aise ParseError(path, lineno, "no section header defined")
 #ources[section, name] = lineno
 #f name is None:
 #f section in sections_data:
 #aise ParseError(path, lineno, f"duplicate section {section!r}")
 #ections_data[section] = {}
 #lse:
 #f name in sections_data[section]:
 #aise ParseError(path, lineno, f"duplicate name {name!r}")
 #ssert value is not None
 #ections_data[section][name] = value

 #eturn sections_data, sources


def parse_lines(
 #ath: str,
 #ine_iter: list[str],
 #,
 #trip_inline_comments: bool = False,
 #trip_section_whitespace: bool = False,
) -> list[ParsedLine]:
 #esult: list[ParsedLine] = []
 #ection = None
 #or lineno, line in enumerate(line_iter):
 #ame, data = _parseline(
 #ath, line, lineno, strip_inline_comments, strip_section_whitespace
 #
        # new value
 #f name is not None and data is not None:
 #esult.append(ParsedLine(lineno, section, name, data))
        # new section
 #lif name is not None and data is None:
 #f not name:
 #aise ParseError(path, lineno, "empty section name")
 #ection = name
 #esult.append(ParsedLine(lineno, section, None, None))
        # continuation
 #lif name is None and data is not None:
 #f not result:
 #aise ParseError(path, lineno, "unexpected value continuation")
 #ast = result.pop()
 #f last.name is None:
 #aise ParseError(path, lineno, "unexpected value continuation")

 #f last.value:
 #ast = last._replace(value=f"{last.value}\n{data}")
 #lse:
 #ast = last._replace(value=data)
 #esult.append(last)
 #eturn result


def _parseline(
 #ath: str,
 #ine: str,
 #ineno: int,
 #trip_inline_comments: bool,
 #trip_section_whitespace: bool,
) -> tuple[str | None, str | None]:
    # blank lines
 #f iscommentline(line):
 #ine = ""
 #lse:
 #ine = line.rstrip()
 #f not line:
 #eturn None, None
    # section
 #f line[0] == "[":
 #ealline = line
 #or c in COMMENTCHARS:
 #ine = line.split(c)[0].rstrip()
 #f line[-1] == "]":
 #ection_name = line[1:-1]
            # Optionally strip whitespace from section name (issue #4)
 #f strip_section_whitespace:
 #ection_name = section_name.strip()
 #eturn section_name, None
 #eturn None, realline.strip()
    # value
 #lif not line[0].isspace():
 #ry:
 #ame, value = line.split("=", 1)
 #f ":" in name:
 #aise ValueError()
 #xcept ValueError:
 #ry:
 #ame, value = line.split(":", 1)
 #xcept ValueError:
 #aise ParseError(path, lineno, f"unexpected line: {line!r}") from None

        # Strip key name (always for backward compatibility, optionally with unicode awareness)
 #ey_name = name.strip()

        # Strip value
 #alue = value.strip()
        # Strip inline comments from values if requested (issue #55)
 #f strip_inline_comments:
 #or c in COMMENTCHARS:
 #alue = value.split(c)[0].rstrip()

 #eturn key_name, value
    # continuation
 #lse:
 #ine = line.strip()
        # Strip inline comments from continuations if requested (issue #55)
 #f strip_inline_comments:
 #or c in COMMENTCHARS:
 #ine = line.split(c)[0].rstrip()
 #eturn None, line


def iscommentline(line: str) -> bool:
 # = line.lstrip()[:1]
 #eturn c in COMMENTCHARS
