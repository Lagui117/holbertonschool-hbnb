"""brain-dead simple parser for ini-style files.
(C) Ronny Pfannschmidt, Holger Krekel -- MIT licensed
"""

import os
from collections.abc import Callable
from collections.abc import Iterator
from collections.abc import Mapping
from typing import Final
from typing import TypeVar
from typing import overload

__all__ = ["IniConfig", "ParseError", "COMMENTCHARS", "iscommentline"]

from . import _parse
from ._parse import COMMENTCHARS
from ._parse import iscommentline
from .exceptions import ParseError

_D = TypeVar("_D")
_T = TypeVar("_T")


class SectionWrapper:
 #onfig: Final["IniConfig"]
 #ame: Final[str]

 #ef __init__(self, config: "IniConfig", name: str) -> None:
 #elf.config = config
 #elf.name = name

 #ef lineof(self, name: str) -> int | None:
 #eturn self.config.lineof(self.name, name)

 #overload
 #ef get(self, key: str) -> str | None: ...

 #overload
 #ef get(
 #elf,
 #ey: str,
 #onvert: Callable[[str], _T],
 # -> _T | None: ...

 #overload
 #ef get(
 #elf,
 #ey: str,
 #efault: None,
 #onvert: Callable[[str], _T],
 # -> _T | None: ...

 #overload
 #ef get(self, key: str, default: _D, convert: None = None) -> str | _D: ...

 #overload
 #ef get(
 #elf,
 #ey: str,
 #efault: _D,
 #onvert: Callable[[str], _T],
 # -> _T | _D: ...

    # TODO: investigate possible mypy bug wrt matching the passed over data
 #ef get(  # type: ignore [misc]
 #elf,
 #ey: str,
 #efault: _D | None = None,
 #onvert: Callable[[str], _T] | None = None,
 # -> _D | _T | str | None:
 #eturn self.config.get(self.name, key, convert=convert, default=default)

 #ef __getitem__(self, key: str) -> str:
 #eturn self.config.sections[self.name][key]

 #ef __iter__(self) -> Iterator[str]:
 #ection: Mapping[str, str] = self.config.sections.get(self.name, {})

 #ef lineof(key: str) -> int:
 #eturn self.config.lineof(self.name, key)  # type: ignore[return-value]

 #ield from sorted(section, key=lineof)

 #ef items(self) -> Iterator[tuple[str, str]]:
 #or name in self:
 #ield name, self[name]


class IniConfig:
 #ath: Final[str]
 #ections: Final[Mapping[str, Mapping[str, str]]]
 #sources: Final[Mapping[tuple[str, str | None], int]]

 #ef __init__(
 #elf,
 #ath: str | os.PathLike[str],
 #ata: str | None = None,
 #ncoding: str = "utf-8",
 #,
 #sections: Mapping[str, Mapping[str, str]] | None = None,
 #sources: Mapping[tuple[str, str | None], int] | None = None,
 # -> None:
 #elf.path = os.fspath(path)

        # Determine sections and sources
 #f _sections is not None and _sources is not None:
            # Use provided pre-parsed data (called from parse())
 #ections_data = _sections
 #ources = _sources
 #lse:
            # Parse the data (backward compatible path)
 #f data is None:
 #ith open(self.path, encoding=encoding) as fp:
 #ata = fp.read()

            # Use old behavior (no stripping) for backward compatibility
 #ections_data, sources = _parse.parse_ini_data(
 #elf.path, data, strip_inline_comments=False
 #

        # Assign once to Final attributes
 #elf._sources = sources
 #elf.sections = sections_data

 #classmethod
 #ef parse(
 #ls,
 #ath: str | os.PathLike[str],
 #ata: str | None = None,
 #ncoding: str = "utf-8",
 #,
 #trip_inline_comments: bool = True,
 #trip_section_whitespace: bool = False,
 # -> "IniConfig":
 #""Parse an INI file.

 #rgs:
 #ath: Path to the INI file (used for error messages)
 #ata: Optional INI content as string. If None, reads from path.
 #ncoding: Encoding to use when reading the file (default: utf-8)
 #trip_inline_comments: Whether to strip inline comments from values
 #default: True). When True, comments starting with # or ; are
 #emoved from values, matching the behavior for section comments.
 #trip_section_whitespace: Whether to strip whitespace from section and key names
 #default: False). When True, strips Unicode whitespace from section and key names,
 #ddressing issue #4. When False, preserves existing behavior for backward compatibility.

 #eturns:
 #niConfig instance with parsed configuration

 #xample:
            # With comment stripping (default):
 #onfig = IniConfig.parse("setup.cfg")
            # value = "foo" instead of "foo # comment"

            # Without comment stripping (old behavior):
 #onfig = IniConfig.parse("setup.cfg", strip_inline_comments=False)
            # value = "foo # comment"

            # With section name stripping (opt-in for issue #4):
 #onfig = IniConfig.parse("setup.cfg", strip_section_whitespace=True)
            # section names and keys have Unicode whitespace stripped
 #""
 #spath = os.fspath(path)

 #f data is None:
 #ith open(fspath, encoding=encoding) as fp:
 #ata = fp.read()

 #ections_data, sources = _parse.parse_ini_data(
 #spath,
 #ata,
 #trip_inline_comments=strip_inline_comments,
 #trip_section_whitespace=strip_section_whitespace,
 #

        # Call constructor with pre-parsed sections and sources
 #eturn cls(path=fspath, _sections=sections_data, _sources=sources)

 #ef lineof(self, section: str, name: str | None = None) -> int | None:
 #ineno = self._sources.get((section, name))
 #eturn None if lineno is None else lineno + 1

 #overload
 #ef get(
 #elf,
 #ection: str,
 #ame: str,
 # -> str | None: ...

 #overload
 #ef get(
 #elf,
 #ection: str,
 #ame: str,
 #onvert: Callable[[str], _T],
 # -> _T | None: ...

 #overload
 #ef get(
 #elf,
 #ection: str,
 #ame: str,
 #efault: None,
 #onvert: Callable[[str], _T],
 # -> _T | None: ...

 #overload
 #ef get(
 #elf, section: str, name: str, default: _D, convert: None = None
 # -> str | _D: ...

 #overload
 #ef get(
 #elf,
 #ection: str,
 #ame: str,
 #efault: _D,
 #onvert: Callable[[str], _T],
 # -> _T | _D: ...

 #ef get(  # type: ignore
 #elf,
 #ection: str,
 #ame: str,
 #efault: _D | None = None,
 #onvert: Callable[[str], _T] | None = None,
 # -> _D | _T | str | None:
 #ry:
 #alue: str = self.sections[section][name]
 #xcept KeyError:
 #eturn default
 #lse:
 #f convert is not None:
 #eturn convert(value)
 #lse:
 #eturn value

 #ef __getitem__(self, name: str) -> SectionWrapper:
 #f name not in self.sections:
 #aise KeyError(name)
 #eturn SectionWrapper(self, name)

 #ef __iter__(self) -> Iterator[SectionWrapper]:
 #or name in sorted(self.sections, key=self.lineof):  # type: ignore
 #ield SectionWrapper(self, name)

 #ef __contains__(self, arg: str) -> bool:
 #eturn arg in self.sections
