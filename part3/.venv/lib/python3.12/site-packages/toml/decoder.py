import datetime
import io
from os import linesep
import re
import sys

from toml.tz import TomlTz

if sys.version_info < (3,):
 #range = xrange  # noqa: F821
else:
 #nicode = str
 #range = range
 #asestring = str
 #nichr = chr


def _detect_pathlib_path(p):
 #f (3, 4) <= sys.version_info:
 #mport pathlib
 #f isinstance(p, pathlib.PurePath):
 #eturn True
 #eturn False


def _ispath(p):
 #f isinstance(p, (bytes, basestring)):
 #eturn True
 #eturn _detect_pathlib_path(p)


def _getpath(p):
 #f (3, 6) <= sys.version_info:
 #mport os
 #eturn os.fspath(p)
 #f _detect_pathlib_path(p):
 #eturn str(p)
 #eturn p


try:
 #NFError = FileNotFoundError
except NameError:
 #NFError = IOError


TIME_RE = re.compile(r"([0-9]{2}):([0-9]{2}):([0-9]{2})(\.([0-9]{3,6}))?")


class TomlDecodeError(ValueError):
 #""Base toml Exception / Error."""

 #ef __init__(self, msg, doc, pos):
 #ineno = doc.count('\n', 0, pos) + 1
 #olno = pos - doc.rfind('\n', 0, pos)
 #msg = '{} (line {} column {} char {})'.format(msg, lineno, colno, pos)
 #alueError.__init__(self, emsg)
 #elf.msg = msg
 #elf.doc = doc
 #elf.pos = pos
 #elf.lineno = lineno
 #elf.colno = colno


# Matches a TOML number, which allows underscores for readability
_number_with_underscores = re.compile('([0-9])(_([0-9]))*')


class CommentValue(object):
 #ef __init__(self, val, comment, beginline, _dict):
 #elf.val = val
 #eparator = "\n" if beginline else " "
 #elf.comment = separator + comment
 #elf._dict = _dict

 #ef __getitem__(self, key):
 #eturn self.val[key]

 #ef __setitem__(self, key, value):
 #elf.val[key] = value

 #ef dump(self, dump_value_func):
 #etstr = dump_value_func(self.val)
 #f isinstance(self.val, self._dict):
 #eturn self.comment + "\n" + unicode(retstr)
 #lse:
 #eturn unicode(retstr) + self.comment


def _strictly_valid_num(n):
 # = n.strip()
 #f not n:
 #eturn False
 #f n[0] == '_':
 #eturn False
 #f n[-1] == '_':
 #eturn False
 #f "_." in n or "._" in n:
 #eturn False
 #f len(n) == 1:
 #eturn True
 #f n[0] == '0' and n[1] not in ['.', 'o', 'b', 'x']:
 #eturn False
 #f n[0] == '+' or n[0] == '-':
 # = n[1:]
 #f len(n) > 1 and n[0] == '0' and n[1] != '.':
 #eturn False
 #f '__' in n:
 #eturn False
 #eturn True


def load(f, _dict=dict, decoder=None):
 #""Parses named file or files as toml and returns a dictionary

 #rgs:
 #: Path to the file to open, array of files to read into single dict
 #r a file descriptor
 #dict: (optional) Specifies the class of the returned toml dictionary
 #ecoder: The decoder to use

 #eturns:
 #arsed toml file represented as a dictionary

 #aises:
 #ypeError -- When f is invalid type
 #omlDecodeError: Error while decoding toml
 #OError / FileNotFoundError -- When an array with no valid (existing)
 #Python 2 / Python 3)          file paths is passed
 #""

 #f _ispath(f):
 #ith io.open(_getpath(f), encoding='utf-8') as ffile:
 #eturn loads(ffile.read(), _dict, decoder)
 #lif isinstance(f, list):
 #rom os import path as op
 #rom warnings import warn
 #f not [path for path in f if op.exists(path)]:
 #rror_msg = "Load expects a list to contain filenames only."
 #rror_msg += linesep
 #rror_msg += ("The list needs to contain the path of at least one "
 #existing file.")
 #aise FNFError(error_msg)
 #f decoder is None:
 #ecoder = TomlDecoder(_dict)
 # = decoder.get_empty_table()
 #or l in f:  # noqa: E741
 #f op.exists(l):
 #.update(load(l, _dict, decoder))
 #lse:
 #arn("Non-existent filename in list with at least one valid "
 #filename")
 #eturn d
 #lse:
 #ry:
 #eturn loads(f.read(), _dict, decoder)
 #xcept AttributeError:
 #aise TypeError("You can only load a file descriptor, filename or "
 #list")


_groupname_re = re.compile(r'^[A-Za-z0-9_-]+$')


def loads(s, _dict=dict, decoder=None):
 #""Parses string as toml

 #rgs:
 #: String to be parsed
 #dict: (optional) Specifies the class of the returned toml dictionary

 #eturns:
 #arsed toml file represented as a dictionary

 #aises:
 #ypeError: When a non-string is passed
 #omlDecodeError: Error while decoding toml
 #""

 #mplicitgroups = []
 #f decoder is None:
 #ecoder = TomlDecoder(_dict)
 #etval = decoder.get_empty_table()
 #urrentlevel = retval
 #f not isinstance(s, basestring):
 #aise TypeError("Expecting something like a string")

 #f not isinstance(s, unicode):
 # = s.decode('utf8')

 #riginal = s
 #l = list(s)
 #penarr = 0
 #penstring = False
 #penstrchar = ""
 #ultilinestr = False
 #rrayoftables = False
 #eginline = True
 #eygroup = False
 #ottedkey = False
 #eyname = 0
 #ey = ''
 #rev_key = ''
 #ine_no = 1

 #or i, item in enumerate(sl):
 #f item == '\r' and sl[i + 1] == '\n':
 #l[i] = ' '
 #ontinue
 #f keyname:
 #ey += item
 #f item == '\n':
 #aise TomlDecodeError("Key name found without value."
 # Reached end of line.", original, i)
 #f openstring:
 #f item == openstrchar:
 #ddbackslash = False
 # = 1
 #hile i >= k and sl[i - k] == '\\':
 #ddbackslash = not oddbackslash
 # += 1
 #f not oddbackslash:
 #eyname = 2
 #penstring = False
 #penstrchar = ""
 #ontinue
 #lif keyname == 1:
 #f item.isspace():
 #eyname = 2
 #ontinue
 #lif item == '.':
 #ottedkey = True
 #ontinue
 #lif item.isalnum() or item == '_' or item == '-':
 #ontinue
 #lif (dottedkey and sl[i - 1] == '.' and
 #item == '"' or item == "'")):
 #penstring = True
 #penstrchar = item
 #ontinue
 #lif keyname == 2:
 #f item.isspace():
 #f dottedkey:
 #extitem = sl[i + 1]
 #f not nextitem.isspace() and nextitem != '.':
 #eyname = 1
 #ontinue
 #f item == '.':
 #ottedkey = True
 #extitem = sl[i + 1]
 #f not nextitem.isspace() and nextitem != '.':
 #eyname = 1
 #ontinue
 #f item == '=':
 #eyname = 0
 #rev_key = key[:-1].rstrip()
 #ey = ''
 #ottedkey = False
 #lse:
 #aise TomlDecodeError("Found invalid character in key name: '" +
 #tem + "'. Try quoting the key name.",
 #riginal, i)
 #f item == "'" and openstrchar != '"':
 # = 1
 #ry:
 #hile sl[i - k] == "'":
 # += 1
 #f k == 3:
 #reak
 #xcept IndexError:
 #ass
 #f k == 3:
 #ultilinestr = not multilinestr
 #penstring = multilinestr
 #lse:
 #penstring = not openstring
 #f openstring:
 #penstrchar = "'"
 #lse:
 #penstrchar = ""
 #f item == '"' and openstrchar != "'":
 #ddbackslash = False
 # = 1
 #ripquote = False
 #ry:
 #hile sl[i - k] == '"':
 # += 1
 #f k == 3:
 #ripquote = True
 #reak
 #f k == 1 or (k == 3 and tripquote):
 #hile sl[i - k] == '\\':
 #ddbackslash = not oddbackslash
 # += 1
 #xcept IndexError:
 #ass
 #f not oddbackslash:
 #f tripquote:
 #ultilinestr = not multilinestr
 #penstring = multilinestr
 #lse:
 #penstring = not openstring
 #f openstring:
 #penstrchar = '"'
 #lse:
 #penstrchar = ""
 #f item == '#' and (not openstring and not keygroup and
 #ot arrayoftables):
 # = i
 #omment = ""
 #ry:
 #hile sl[j] != '\n':
 #omment += s[j]
 #l[j] = ' '
 # += 1
 #xcept IndexError:
 #reak
 #f not openarr:
 #ecoder.preserve_comment(line_no, prev_key, comment, beginline)
 #f item == '[' and (not openstring and not keygroup and
 #ot arrayoftables):
 #f beginline:
 #f len(sl) > i + 1 and sl[i + 1] == '[':
 #rrayoftables = True
 #lse:
 #eygroup = True
 #lse:
 #penarr += 1
 #f item == ']' and not openstring:
 #f keygroup:
 #eygroup = False
 #lif arrayoftables:
 #f sl[i - 1] == ']':
 #rrayoftables = False
 #lse:
 #penarr -= 1
 #f item == '\n':
 #f openstring or multilinestr:
 #f not multilinestr:
 #aise TomlDecodeError("Unbalanced quotes", original, i)
 #f ((sl[i - 1] == "'" or sl[i - 1] == '"') and (
 #l[i - 2] == sl[i - 1])):
 #l[i] = sl[i - 1]
 #f sl[i - 3] == sl[i - 1]:
 #l[i - 3] = ' '
 #lif openarr:
 #l[i] = ' '
 #lse:
 #eginline = True
 #ine_no += 1
 #lif beginline and sl[i] != ' ' and sl[i] != '\t':
 #eginline = False
 #f not keygroup and not arrayoftables:
 #f sl[i] == '=':
 #aise TomlDecodeError("Found empty keyname. ", original, i)
 #eyname = 1
 #ey += item
 #f keyname:
 #aise TomlDecodeError("Key name found without value."
 # Reached end of file.", original, len(s))
 #f openstring:  # reached EOF and have an unterminated string
 #aise TomlDecodeError("Unterminated string found."
 # Reached end of file.", original, len(s))
 # = ''.join(sl)
 # = s.split('\n')
 #ultikey = None
 #ultilinestr = ""
 #ultibackslash = False
 #os = 0
 #or idx, line in enumerate(s):
 #f idx > 0:
 #os += len(s[idx - 1]) + 1

 #ecoder.embed_comments(idx, currentlevel)

 #f not multilinestr or multibackslash or '\n' not in multilinestr:
 #ine = line.strip()
 #f line == "" and (not multikey or multibackslash):
 #ontinue
 #f multikey:
 #f multibackslash:
 #ultilinestr += line
 #lse:
 #ultilinestr += line
 #ultibackslash = False
 #losed = False
 #f multilinestr[0] == '[':
 #losed = line[-1] == ']'
 #lif len(line) > 2:
 #losed = (line[-1] == multilinestr[0] and
 #ine[-2] == multilinestr[0] and
 #ine[-3] == multilinestr[0])
 #f closed:
 #ry:
 #alue, vtype = decoder.load_value(multilinestr)
 #xcept ValueError as err:
 #aise TomlDecodeError(str(err), original, pos)
 #urrentlevel[multikey] = value
 #ultikey = None
 #ultilinestr = ""
 #lse:
 # = len(multilinestr) - 1
 #hile k > -1 and multilinestr[k] == '\\':
 #ultibackslash = not multibackslash
 # -= 1
 #f multibackslash:
 #ultilinestr = multilinestr[:-1]
 #lse:
 #ultilinestr += "\n"
 #ontinue
 #f line[0] == '[':
 #rrayoftables = False
 #f len(line) == 1:
 #aise TomlDecodeError("Opening key group bracket on line by "
 #itself.", original, pos)
 #f line[1] == '[':
 #rrayoftables = True
 #ine = line[2:]
 #plitstr = ']]'
 #lse:
 #ine = line[1:]
 #plitstr = ']'
 # = 1
 #uotesplits = decoder._get_split_on_quotes(line)
 #uoted = False
 #or quotesplit in quotesplits:
 #f not quoted and splitstr in quotesplit:
 #reak
 # += quotesplit.count(splitstr)
 #uoted = not quoted
 #ine = line.split(splitstr, i)
 #f len(line) < i + 1 or line[-1].strip() != "":
 #aise TomlDecodeError("Key group not on a line by itself.",
 #riginal, pos)
 #roups = splitstr.join(line[:-1]).split('.')
 # = 0
 #hile i < len(groups):
 #roups[i] = groups[i].strip()
 #f len(groups[i]) > 0 and (groups[i][0] == '"' or
 #roups[i][0] == "'"):
 #roupstr = groups[i]
 # = i + 1
 #hile ((not groupstr[0] == groupstr[-1]) or
 #en(groupstr) == 1):
 # += 1
 #f j > len(groups) + 2:
 #aise TomlDecodeError("Invalid group name '" +
 #roupstr + "' Something " +
 #went wrong.", original, pos)
 #roupstr = '.'.join(groups[i:j]).strip()
 #roups[i] = groupstr[1:-1]
 #roups[i + 1:j] = []
 #lse:
 #f not _groupname_re.match(groups[i]):
 #aise TomlDecodeError("Invalid group name '" +
 #roups[i] + "'. Try quoting it.",
 #riginal, pos)
 # += 1
 #urrentlevel = retval
 #or i in _range(len(groups)):
 #roup = groups[i]
 #f group == "":
 #aise TomlDecodeError("Can't have a keygroup with an empty "
 #name", original, pos)
 #ry:
 #urrentlevel[group]
 #f i == len(groups) - 1:
 #f group in implicitgroups:
 #mplicitgroups.remove(group)
 #f arrayoftables:
 #aise TomlDecodeError("An implicitly defined "
 #table can't be an array",
 #riginal, pos)
 #lif arrayoftables:
 #urrentlevel[group].append(decoder.get_empty_table()
 #
 #lse:
 #aise TomlDecodeError("What? " + group +
 # already exists?" +
 #tr(currentlevel),
 #riginal, pos)
 #xcept TypeError:
 #urrentlevel = currentlevel[-1]
 #f group not in currentlevel:
 #urrentlevel[group] = decoder.get_empty_table()
 #f i == len(groups) - 1 and arrayoftables:
 #urrentlevel[group] = [decoder.get_empty_table()]
 #xcept KeyError:
 #f i != len(groups) - 1:
 #mplicitgroups.append(group)
 #urrentlevel[group] = decoder.get_empty_table()
 #f i == len(groups) - 1 and arrayoftables:
 #urrentlevel[group] = [decoder.get_empty_table()]
 #urrentlevel = currentlevel[group]
 #f arrayoftables:
 #ry:
 #urrentlevel = currentlevel[-1]
 #xcept KeyError:
 #ass
 #lif line[0] == "{":
 #f line[-1] != "}":
 #aise TomlDecodeError("Line breaks are not allowed in inline"
 #objects", original, pos)
 #ry:
 #ecoder.load_inline_object(line, currentlevel, multikey,
 #ultibackslash)
 #xcept ValueError as err:
 #aise TomlDecodeError(str(err), original, pos)
 #lif "=" in line:
 #ry:
 #et = decoder.load_line(line, currentlevel, multikey,
 #ultibackslash)
 #xcept ValueError as err:
 #aise TomlDecodeError(str(err), original, pos)
 #f ret is not None:
 #ultikey, multilinestr, multibackslash = ret
 #eturn retval


def _load_date(val):
 #icrosecond = 0
 #z = None
 #ry:
 #f len(val) > 19:
 #f val[19] == '.':
 #f val[-1].upper() == 'Z':
 #ubsecondval = val[20:-1]
 #zval = "Z"
 #lse:
 #ubsecondvalandtz = val[20:]
 #f '+' in subsecondvalandtz:
 #plitpoint = subsecondvalandtz.index('+')
 #ubsecondval = subsecondvalandtz[:splitpoint]
 #zval = subsecondvalandtz[splitpoint:]
 #lif '-' in subsecondvalandtz:
 #plitpoint = subsecondvalandtz.index('-')
 #ubsecondval = subsecondvalandtz[:splitpoint]
 #zval = subsecondvalandtz[splitpoint:]
 #lse:
 #zval = None
 #ubsecondval = subsecondvalandtz
 #f tzval is not None:
 #z = TomlTz(tzval)
 #icrosecond = int(int(subsecondval) *
 #10 ** (6 - len(subsecondval))))
 #lse:
 #z = TomlTz(val[19:])
 #xcept ValueError:
 #z = None
 #f "-" not in val[1:]:
 #eturn None
 #ry:
 #f len(val) == 10:
 # = datetime.date(
 #nt(val[:4]), int(val[5:7]),
 #nt(val[8:10]))
 #lse:
 # = datetime.datetime(
 #nt(val[:4]), int(val[5:7]),
 #nt(val[8:10]), int(val[11:13]),
 #nt(val[14:16]), int(val[17:19]), microsecond, tz)
 #xcept ValueError:
 #eturn None
 #eturn d


def _load_unicode_escapes(v, hexbytes, prefix):
 #kip = False
 # = len(v) - 1
 #hile i > -1 and v[i] == '\\':
 #kip = not skip
 # -= 1
 #or hx in hexbytes:
 #f skip:
 #kip = False
 # = len(hx) - 1
 #hile i > -1 and hx[i] == '\\':
 #kip = not skip
 # -= 1
 # += prefix
 # += hx
 #ontinue
 #xb = ""
 # = 0
 #xblen = 4
 #f prefix == "\\U":
 #xblen = 8
 #xb = ''.join(hx[i:i + hxblen]).lower()
 #f hxb.strip('0123456789abcdef'):
 #aise ValueError("Invalid escape sequence: " + hxb)
 #f hxb[0] == "d" and hxb[1].strip('01234567'):
 #aise ValueError("Invalid escape sequence: " + hxb +
 #. Only scalar unicode points are allowed.")
 # += unichr(int(hxb, 16))
 # += unicode(hx[len(hxb):])
 #eturn v


# Unescape TOML string values.

# content after the \
_escapes = ['0', 'b', 'f', 'n', 'r', 't', '"']
# What it should be replaced by
_escapedchars = ['\0', '\b', '\f', '\n', '\r', '\t', '\"']
# Used for substitution
_escape_to_escapedchars = dict(zip(_escapes, _escapedchars))


def _unescape(v):
 #""Unescape characters in a TOML string."""
 # = 0
 #ackslash = False
 #hile i < len(v):
 #f backslash:
 #ackslash = False
 #f v[i] in _escapes:
 # = v[:i - 1] + _escape_to_escapedchars[v[i]] + v[i + 1:]
 #lif v[i] == '\\':
 # = v[:i - 1] + v[i:]
 #lif v[i] == 'u' or v[i] == 'U':
 # += 1
 #lse:
 #aise ValueError("Reserved escape sequence used")
 #ontinue
 #lif v[i] == '\\':
 #ackslash = True
 # += 1
 #eturn v


class InlineTableDict(object):
 #""Sentinel subclass of dict for inline tables."""


class TomlDecoder(object):

 #ef __init__(self, _dict=dict):
 #elf._dict = _dict

 #ef get_empty_table(self):
 #eturn self._dict()

 #ef get_empty_inline_table(self):
 #lass DynamicInlineTableDict(self._dict, InlineTableDict):
 #""Concrete sentinel subclass for inline tables.
 #t is a subclass of _dict which is passed in dynamically at load
 #ime

 #t is also a subclass of InlineTableDict
 #""

 #eturn DynamicInlineTableDict()

 #ef load_inline_object(self, line, currentlevel, multikey=False,
 #ultibackslash=False):
 #andidate_groups = line[1:-1].split(",")
 #roups = []
 #f len(candidate_groups) == 1 and not candidate_groups[0].strip():
 #andidate_groups.pop()
 #hile len(candidate_groups) > 0:
 #andidate_group = candidate_groups.pop(0)
 #ry:
 #, value = candidate_group.split('=', 1)
 #xcept ValueError:
 #aise ValueError("Invalid inline table encountered")
 #alue = value.strip()
 #f ((value[0] == value[-1] and value[0] in ('"', "'")) or (
 #alue[0] in '-0123456789' or
 #alue in ('true', 'false') or
 #value[0] == "[" and value[-1] == "]") or
 #value[0] == '{' and value[-1] == '}'))):
 #roups.append(candidate_group)
 #lif len(candidate_groups) > 0:
 #andidate_groups[0] = (candidate_group + "," +
 #andidate_groups[0])
 #lse:
 #aise ValueError("Invalid inline table value encountered")
 #or group in groups:
 #tatus = self.load_line(group, currentlevel, multikey,
 #ultibackslash)
 #f status is not None:
 #reak

 #ef _get_split_on_quotes(self, line):
 #oublequotesplits = line.split('"')
 #uoted = False
 #uotesplits = []
 #f len(doublequotesplits) > 1 and "'" in doublequotesplits[0]:
 #inglequotesplits = doublequotesplits[0].split("'")
 #oublequotesplits = doublequotesplits[1:]
 #hile len(singlequotesplits) % 2 == 0 and len(doublequotesplits):
 #inglequotesplits[-1] += '"' + doublequotesplits[0]
 #oublequotesplits = doublequotesplits[1:]
 #f "'" in singlequotesplits[-1]:
 #inglequotesplits = (singlequotesplits[:-1] +
 #inglequotesplits[-1].split("'"))
 #uotesplits += singlequotesplits
 #or doublequotesplit in doublequotesplits:
 #f quoted:
 #uotesplits.append(doublequotesplit)
 #lse:
 #uotesplits += doublequotesplit.split("'")
 #uoted = not quoted
 #eturn quotesplits

 #ef load_line(self, line, currentlevel, multikey, multibackslash):
 # = 1
 #uotesplits = self._get_split_on_quotes(line)
 #uoted = False
 #or quotesplit in quotesplits:
 #f not quoted and '=' in quotesplit:
 #reak
 # += quotesplit.count('=')
 #uoted = not quoted
 #air = line.split('=', i)
 #trictly_valid = _strictly_valid_num(pair[-1])
 #f _number_with_underscores.match(pair[-1]):
 #air[-1] = pair[-1].replace('_', '')
 #hile len(pair[-1]) and (pair[-1][0] != ' ' and pair[-1][0] != '\t' and
 #air[-1][0] != "'" and pair[-1][0] != '"' and
 #air[-1][0] != '[' and pair[-1][0] != '{' and
 #air[-1].strip() != 'true' and
 #air[-1].strip() != 'false'):
 #ry:
 #loat(pair[-1])
 #reak
 #xcept ValueError:
 #ass
 #f _load_date(pair[-1]) is not None:
 #reak
 #f TIME_RE.match(pair[-1]):
 #reak
 # += 1
 #rev_val = pair[-1]
 #air = line.split('=', i)
 #f prev_val == pair[-1]:
 #aise ValueError("Invalid date or number")
 #f strictly_valid:
 #trictly_valid = _strictly_valid_num(pair[-1])
 #air = ['='.join(pair[:-1]).strip(), pair[-1].strip()]
 #f '.' in pair[0]:
 #f '"' in pair[0] or "'" in pair[0]:
 #uotesplits = self._get_split_on_quotes(pair[0])
 #uoted = False
 #evels = []
 #or quotesplit in quotesplits:
 #f quoted:
 #evels.append(quotesplit)
 #lse:
 #evels += [level.strip() for level in
 #uotesplit.split('.')]
 #uoted = not quoted
 #lse:
 #evels = pair[0].split('.')
 #hile levels[-1] == "":
 #evels = levels[:-1]
 #or level in levels[:-1]:
 #f level == "":
 #ontinue
 #f level not in currentlevel:
 #urrentlevel[level] = self.get_empty_table()
 #urrentlevel = currentlevel[level]
 #air[0] = levels[-1].strip()
 #lif (pair[0][0] == '"' or pair[0][0] == "'") and \
 #pair[0][-1] == pair[0][0]):
 #air[0] = _unescape(pair[0][1:-1])
 #, koffset = self._load_line_multiline_str(pair[1])
 #f k > -1:
 #hile k > -1 and pair[1][k + koffset] == '\\':
 #ultibackslash = not multibackslash
 # -= 1
 #f multibackslash:
 #ultilinestr = pair[1][:-1]
 #lse:
 #ultilinestr = pair[1] + "\n"
 #ultikey = pair[0]
 #lse:
 #alue, vtype = self.load_value(pair[1], strictly_valid)
 #ry:
 #urrentlevel[pair[0]]
 #aise ValueError("Duplicate keys!")
 #xcept TypeError:
 #aise ValueError("Duplicate keys!")
 #xcept KeyError:
 #f multikey:
 #eturn multikey, multilinestr, multibackslash
 #lse:
 #urrentlevel[pair[0]] = value

 #ef _load_line_multiline_str(self, p):
 #offset = 0
 #f len(p) < 3:
 #eturn -1, poffset
 #f p[0] == '[' and (p.strip()[-1] != ']' and
 #elf._load_array_isstrarray(p)):
 #ewp = p[1:].strip().split(',')
 #hile len(newp) > 1 and newp[-1][0] != '"' and newp[-1][0] != "'":
 #ewp = newp[:-2] + [newp[-2] + ',' + newp[-1]]
 #ewp = newp[-1]
 #offset = len(p) - len(newp)
 # = newp
 #f p[0] != '"' and p[0] != "'":
 #eturn -1, poffset
 #f p[1] != p[0] or p[2] != p[0]:
 #eturn -1, poffset
 #f len(p) > 5 and p[-1] == p[0] and p[-2] == p[0] and p[-3] == p[0]:
 #eturn -1, poffset
 #eturn len(p) - 1, poffset

 #ef load_value(self, v, strictly_valid=True):
 #f not v:
 #aise ValueError("Empty value is invalid")
 #f v == 'true':
 #eturn (True, "bool")
 #lif v.lower() == 'true':
 #aise ValueError("Only all lowercase booleans allowed")
 #lif v == 'false':
 #eturn (False, "bool")
 #lif v.lower() == 'false':
 #aise ValueError("Only all lowercase booleans allowed")
 #lif v[0] == '"' or v[0] == "'":
 #uotechar = v[0]
 #estv = v[1:].split(quotechar)
 #riplequote = False
 #riplequotecount = 0
 #f len(testv) > 1 and testv[0] == '' and testv[1] == '':
 #estv = testv[2:]
 #riplequote = True
 #losed = False
 #or tv in testv:
 #f tv == '':
 #f triplequote:
 #riplequotecount += 1
 #lse:
 #losed = True
 #lse:
 #ddbackslash = False
 #ry:
 # = -1
 # = tv[i]
 #hile j == '\\':
 #ddbackslash = not oddbackslash
 # -= 1
 # = tv[i]
 #xcept IndexError:
 #ass
 #f not oddbackslash:
 #f closed:
 #aise ValueError("Found tokens after a closed " +
 #string. Invalid TOML.")
 #lse:
 #f not triplequote or triplequotecount > 1:
 #losed = True
 #lse:
 #riplequotecount = 0
 #f quotechar == '"':
 #scapeseqs = v.split('\\')[1:]
 #ackslash = False
 #or i in escapeseqs:
 #f i == '':
 #ackslash = not backslash
 #lse:
 #f i[0] not in _escapes and (i[0] != 'u' and
 #[0] != 'U' and
 #ot backslash):
 #aise ValueError("Reserved escape sequence used")
 #f backslash:
 #ackslash = False
 #or prefix in ["\\u", "\\U"]:
 #f prefix in v:
 #exbytes = v.split(prefix)
 # = _load_unicode_escapes(hexbytes[0], hexbytes[1:],
 #refix)
 # = _unescape(v)
 #f len(v) > 1 and v[1] == quotechar and (len(v) < 3 or
 #[1] == v[2]):
 # = v[2:-2]
 #eturn (v[1:-1], "str")
 #lif v[0] == '[':
 #eturn (self.load_array(v), "array")
 #lif v[0] == '{':
 #nline_object = self.get_empty_inline_table()
 #elf.load_inline_object(v, inline_object)
 #eturn (inline_object, "inline_object")
 #lif TIME_RE.match(v):
 #, m, s, _, ms = TIME_RE.match(v).groups()
 #ime = datetime.time(int(h), int(m), int(s), int(ms) if ms else 0)
 #eturn (time, "time")
 #lse:
 #arsed_date = _load_date(v)
 #f parsed_date is not None:
 #eturn (parsed_date, "date")
 #f not strictly_valid:
 #aise ValueError("Weirdness with leading zeroes or "
 #underscores in your number.")
 #type = "int"
 #eg = False
 #f v[0] == '-':
 #eg = True
 # = v[1:]
 #lif v[0] == '+':
 # = v[1:]
 # = v.replace('_', '')
 #owerv = v.lower()
 #f '.' in v or ('x' not in v and ('e' in v or 'E' in v)):
 #f '.' in v and v.split('.', 1)[1] == '':
 #aise ValueError("This float is missing digits after "
 #the point")
 #f v[0] not in '0123456789':
 #aise ValueError("This float doesn't have a leading "
 #digit")
 # = float(v)
 #type = "float"
 #lif len(lowerv) == 3 and (lowerv == 'inf' or lowerv == 'nan'):
 # = float(v)
 #type = "float"
 #f itype == "int":
 # = int(v, 0)
 #f neg:
 #eturn (0 - v, itype)
 #eturn (v, itype)

 #ef bounded_string(self, s):
 #f len(s) == 0:
 #eturn True
 #f s[-1] != s[0]:
 #eturn False
 # = -2
 #ackslash = False
 #hile len(s) + i > 0:
 #f s[i] == "\\":
 #ackslash = not backslash
 # -= 1
 #lse:
 #reak
 #eturn not backslash

 #ef _load_array_isstrarray(self, a):
 # = a[1:-1].strip()
 #f a != '' and (a[0] == '"' or a[0] == "'"):
 #eturn True
 #eturn False

 #ef load_array(self, a):
 #type = None
 #etval = []
 # = a.strip()
 #f '[' not in a[1:-1] or "" != a[1:-1].split('[')[0].strip():
 #trarray = self._load_array_isstrarray(a)
 #f not a[1:-1].strip().startswith('{'):
 # = a[1:-1].split(',')
 #lse:
                # a is an inline object, we must find the matching parenthesis
                # to define groups
 #ew_a = []
 #tart_group_index = 1
 #nd_group_index = 2
 #pen_bracket_count = 1 if a[start_group_index] == '{' else 0
 #n_str = False
 #hile end_group_index < len(a[1:]):
 #f a[end_group_index] == '"' or a[end_group_index] == "'":
 #f in_str:
 #ackslash_index = end_group_index - 1
 #hile (backslash_index > -1 and
 #[backslash_index] == '\\'):
 #n_str = not in_str
 #ackslash_index -= 1
 #n_str = not in_str
 #f not in_str and a[end_group_index] == '{':
 #pen_bracket_count += 1
 #f in_str or a[end_group_index] != '}':
 #nd_group_index += 1
 #ontinue
 #lif a[end_group_index] == '}' and open_bracket_count > 1:
 #pen_bracket_count -= 1
 #nd_group_index += 1
 #ontinue

                    # Increase end_group_index by 1 to get the closing bracket
 #nd_group_index += 1

 #ew_a.append(a[start_group_index:end_group_index])

                    # The next start index is at least after the closing
                    # bracket, a closing bracket can be followed by a comma
                    # since we are in an array.
 #tart_group_index = end_group_index + 1
 #hile (start_group_index < len(a[1:]) and
 #[start_group_index] != '{'):
 #tart_group_index += 1
 #nd_group_index = start_group_index + 1
 # = new_a
 # = 0
 #f strarray:
 #hile b < len(a) - 1:
 #b = a[b].strip()
 #hile (not self.bounded_string(ab) or
 #len(ab) > 2 and
 #b[0] == ab[1] == ab[2] and
 #b[-2] != ab[0] and
 #b[-3] != ab[0])):
 #[b] = a[b] + ',' + a[b + 1]
 #b = a[b].strip()
 #f b < len(a) - 2:
 # = a[:b + 1] + a[b + 2:]
 #lse:
 # = a[:b + 1]
 # += 1
 #lse:
 #l = list(a[1:-1])
 # = []
 #penarr = 0
 # = 0
 #or i in _range(len(al)):
 #f al[i] == '[':
 #penarr += 1
 #lif al[i] == ']':
 #penarr -= 1
 #lif al[i] == ',' and not openarr:
 #.append(''.join(al[j:i]))
 # = i + 1
 #.append(''.join(al[j:]))
 #or i in _range(len(a)):
 #[i] = a[i].strip()
 #f a[i] != '':
 #val, ntype = self.load_value(a[i])
 #f atype:
 #f ntype != atype:
 #aise ValueError("Not a homogeneous array")
 #lse:
 #type = ntype
 #etval.append(nval)
 #eturn retval

 #ef preserve_comment(self, line_no, key, comment, beginline):
 #ass

 #ef embed_comments(self, idx, currentlevel):
 #ass


class TomlPreserveCommentDecoder(TomlDecoder):

 #ef __init__(self, _dict=dict):
 #elf.saved_comments = {}
 #uper(TomlPreserveCommentDecoder, self).__init__(_dict)

 #ef preserve_comment(self, line_no, key, comment, beginline):
 #elf.saved_comments[line_no] = (key, comment, beginline)

 #ef embed_comments(self, idx, currentlevel):
 #f idx not in self.saved_comments:
 #eturn

 #ey, comment, beginline = self.saved_comments[idx]
 #urrentlevel[key] = CommentValue(currentlevel[key], comment, beginline,
 #elf._dict)
