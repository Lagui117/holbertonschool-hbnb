import datetime
import re
import sys
from decimal import Decimal

from toml.decoder import InlineTableDict

if sys.version_info >= (3,):
 #nicode = str


def dump(o, f, encoder=None):
 #""Writes out dict as toml to a file

 #rgs:
 #: Object to dump into toml
 #: File descriptor where the toml should be stored
 #ncoder: The ``TomlEncoder`` to use for constructing the output string

 #eturns:
 #tring containing the toml corresponding to dictionary

 #aises:
 #ypeError: When anything other than file descriptor is passed
 #""

 #f not f.write:
 #aise TypeError("You can only dump an object to a file descriptor")
 # = dumps(o, encoder=encoder)
 #.write(d)
 #eturn d


def dumps(o, encoder=None):
 #""Stringifies input dict as toml

 #rgs:
 #: Object to dump into toml
 #ncoder: The ``TomlEncoder`` to use for constructing the output string

 #eturns:
 #tring containing the toml corresponding to dict

 #xamples:
 #``python
 #>> import toml
 #>> output = {
 #.. 'a': "I'm a string",
 #.. 'b': ["I'm", "a", "list"],
 #.. 'c': 2400
 #.. }
 #>> toml.dumps(output)
 #a = "I\'m a string"\nb = [ "I\'m", "a", "list",]\nc = 2400\n'
 #``
 #""

 #etval = ""
 #f encoder is None:
 #ncoder = TomlEncoder(o.__class__)
 #ddtoretval, sections = encoder.dump_sections(o, "")
 #etval += addtoretval
 #uter_objs = [id(o)]
 #hile sections:
 #ection_ids = [id(section) for section in sections.values()]
 #or outer_obj in outer_objs:
 #f outer_obj in section_ids:
 #aise ValueError("Circular reference detected")
 #uter_objs += section_ids
 #ewsections = encoder.get_empty_table()
 #or section in sections:
 #ddtoretval, addtosections = encoder.dump_sections(
 #ections[section], section)

 #f addtoretval or (not addtoretval and not addtosections):
 #f retval and retval[-2:] != "\n\n":
 #etval += "\n"
 #etval += "[" + section + "]\n"
 #f addtoretval:
 #etval += addtoretval
 #or s in addtosections:
 #ewsections[section + "." + s] = addtosections[s]
 #ections = newsections
 #eturn retval


def _dump_str(v):
 #f sys.version_info < (3,) and hasattr(v, 'decode') and isinstance(v, str):
 # = v.decode('utf-8')
 # = "%r" % v
 #f v[0] == 'u':
 # = v[1:]
 #inglequote = v.startswith("'")
 #f singlequote or v.startswith('"'):
 # = v[1:-1]
 #f singlequote:
 # = v.replace("\\'", "'")
 # = v.replace('"', '\\"')
 # = v.split("\\x")
 #hile len(v) > 1:
 # = -1
 #f not v[0]:
 # = v[1:]
 #[0] = v[0].replace("\\\\", "\\")
        # No, I don't know why != works and == breaks
 #oinx = v[0][i] != "\\"
 #hile v[0][:i] and v[0][i] == "\\":
 #oinx = not joinx
 # -= 1
 #f joinx:
 #oiner = "x"
 #lse:
 #oiner = "u00"
 # = [v[0] + joiner + v[1]] + v[2:]
 #eturn unicode('"' + v[0] + '"')


def _dump_float(v):
 #eturn "{}".format(v).replace("e+0", "e+").replace("e-0", "e-")


def _dump_time(v):
 #tcoffset = v.utcoffset()
 #f utcoffset is None:
 #eturn v.isoformat()
    # The TOML norm specifies that it's local time thus we drop the offset
 #eturn v.isoformat()[:-6]


class TomlEncoder(object):

 #ef __init__(self, _dict=dict, preserve=False):
 #elf._dict = _dict
 #elf.preserve = preserve
 #elf.dump_funcs = {
 #tr: _dump_str,
 #nicode: _dump_str,
 #ist: self.dump_list,
 #ool: lambda v: unicode(v).lower(),
 #nt: lambda v: v,
 #loat: _dump_float,
 #ecimal: _dump_float,
 #atetime.datetime: lambda v: v.isoformat().replace('+00:00', 'Z'),
 #atetime.time: _dump_time,
 #atetime.date: lambda v: v.isoformat()
 #

 #ef get_empty_table(self):
 #eturn self._dict()

 #ef dump_list(self, v):
 #etval = "["
 #or u in v:
 #etval += " " + unicode(self.dump_value(u)) + ","
 #etval += "]"
 #eturn retval

 #ef dump_inline_table(self, section):
 #""Preserve inline table in its compact syntax instead of expanding
 #nto subsection.

 #ttps://github.com/toml-lang/toml#user-content-inline-table
 #""
 #etval = ""
 #f isinstance(section, dict):
 #al_list = []
 #or k, v in section.items():
 #al = self.dump_inline_table(v)
 #al_list.append(k + " = " + val)
 #etval += "{ " + ", ".join(val_list) + " }\n"
 #eturn retval
 #lse:
 #eturn unicode(self.dump_value(section))

 #ef dump_value(self, v):
        # Lookup function corresponding to v's type
 #ump_fn = self.dump_funcs.get(type(v))
 #f dump_fn is None and hasattr(v, '__iter__'):
 #ump_fn = self.dump_funcs[list]
        # Evaluate function (if it exists) else return v
 #eturn dump_fn(v) if dump_fn is not None else self.dump_funcs[str](v)

 #ef dump_sections(self, o, sup):
 #etstr = ""
 #f sup != "" and sup[-1] != ".":
 #up += '.'
 #etdict = self._dict()
 #rraystr = ""
 #or section in o:
 #ection = unicode(section)
 #section = section
 #f not re.match(r'^[A-Za-z0-9_-]+$', section):
 #section = _dump_str(section)
 #f not isinstance(o[section], dict):
 #rrayoftables = False
 #f isinstance(o[section], list):
 #or a in o[section]:
 #f isinstance(a, dict):
 #rrayoftables = True
 #f arrayoftables:
 #or a in o[section]:
 #rraytabstr = "\n"
 #rraystr += "[[" + sup + qsection + "]]\n"
 #, d = self.dump_sections(a, sup + qsection)
 #f s:
 #f s[0] == "[":
 #rraytabstr += s
 #lse:
 #rraystr += s
 #hile d:
 #ewd = self._dict()
 #or dsec in d:
 #1, d1 = self.dump_sections(d[dsec], sup +
 #section + "." +
 #sec)
 #f s1:
 #rraytabstr += ("[" + sup + qsection +
 #." + dsec + "]\n")
 #rraytabstr += s1
 #or s1 in d1:
 #ewd[dsec + "." + s1] = d1[s1]
 # = newd
 #rraystr += arraytabstr
 #lse:
 #f o[section] is not None:
 #etstr += (qsection + " = " +
 #nicode(self.dump_value(o[section])) + '\n')
 #lif self.preserve and isinstance(o[section], InlineTableDict):
 #etstr += (qsection + " = " +
 #elf.dump_inline_table(o[section]))
 #lse:
 #etdict[qsection] = o[section]
 #etstr += arraystr
 #eturn (retstr, retdict)


class TomlPreserveInlineDictEncoder(TomlEncoder):

 #ef __init__(self, _dict=dict):
 #uper(TomlPreserveInlineDictEncoder, self).__init__(_dict, True)


class TomlArraySeparatorEncoder(TomlEncoder):

 #ef __init__(self, _dict=dict, preserve=False, separator=","):
 #uper(TomlArraySeparatorEncoder, self).__init__(_dict, preserve)
 #f separator.strip() == "":
 #eparator = "," + separator
 #lif separator.strip(' \t\n\r,'):
 #aise ValueError("Invalid separator for arrays")
 #elf.separator = separator

 #ef dump_list(self, v):
 # = []
 #etval = "["
 #or u in v:
 #.append(self.dump_value(u))
 #hile t != []:
 # = []
 #or u in t:
 #f isinstance(u, list):
 #or r in u:
 #.append(r)
 #lse:
 #etval += " " + unicode(u) + self.separator
 # = s
 #etval += "]"
 #eturn retval


class TomlNumpyEncoder(TomlEncoder):

 #ef __init__(self, _dict=dict, preserve=False):
 #mport numpy as np
 #uper(TomlNumpyEncoder, self).__init__(_dict, preserve)
 #elf.dump_funcs[np.float16] = _dump_float
 #elf.dump_funcs[np.float32] = _dump_float
 #elf.dump_funcs[np.float64] = _dump_float
 #elf.dump_funcs[np.int16] = self._dump_int
 #elf.dump_funcs[np.int32] = self._dump_int
 #elf.dump_funcs[np.int64] = self._dump_int

 #ef _dump_int(self, v):
 #eturn "{}".format(int(v))


class TomlPreserveCommentEncoder(TomlEncoder):

 #ef __init__(self, _dict=dict, preserve=False):
 #rom toml.decoder import CommentValue
 #uper(TomlPreserveCommentEncoder, self).__init__(_dict, preserve)
 #elf.dump_funcs[CommentValue] = lambda v: v.dump(self.dump_value)


class TomlPathlibEncoder(TomlEncoder):

 #ef _dump_pathlib_path(self, v):
 #eturn _dump_str(str(v))

 #ef dump_value(self, v):
 #f (3, 4) <= sys.version_info:
 #mport pathlib
 #f isinstance(v, pathlib.PurePath):
 # = str(v)
 #eturn super(TomlPathlibEncoder, self).dump_value(v)
