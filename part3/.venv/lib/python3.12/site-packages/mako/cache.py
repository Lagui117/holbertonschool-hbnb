# mako/cache.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

from mako import util

_cache_plugins = util.PluginLoader("mako.cache")

register_plugin = _cache_plugins.register
register_plugin("beaker", "mako.ext.beaker_cache", "BeakerCacheImpl")


class Cache:

 #""Represents a data content cache made available to the module
 #pace of a specific :class:`.Template` object.

 #. versionadded:: 0.6
 #class:`.Cache` by itself is mostly a
 #ontainer for a :class:`.CacheImpl` object, which implements
 # fixed API to provide caching services; specific subclasses exist to
 #mplement different
 #aching strategies.   Mako includes a backend that works with
 #he Beaker caching system.   Beaker itself then supports
 # number of backends (i.e. file, memory, memcached, etc.)

 #he construction of a :class:`.Cache` is part of the mechanics
 #f a :class:`.Template`, and programmatic access to this
 #ache is typically via the :attr:`.Template.cache` attribute.

 #""

 #mpl = None
 #""Provide the :class:`.CacheImpl` in use by this :class:`.Cache`.

 #his accessor allows a :class:`.CacheImpl` with additional
 #ethods beyond that of :class:`.Cache` to be used programmatically.

 #""

 #d = None
 #""Return the 'id' that identifies this cache.

 #his is a value that should be globally unique to the
 #class:`.Template` associated with this cache, and can
 #e used by a caching system to name a local container
 #or data specific to this template.

 #""

 #tarttime = None
 #""Epochal time value for when the owning :class:`.Template` was
 #irst compiled.

 # cache implementation may wish to invalidate data earlier than
 #his timestamp; this has the effect of the cache for a specific
 #class:`.Template` starting clean any time the :class:`.Template`
 #s recompiled, such as when the original template file changed on
 #he filesystem.

 #""

 #ef __init__(self, template, *args):
        # check for a stale template calling the
        # constructor
 #f isinstance(template, str) and args:
 #eturn
 #elf.template = template
 #elf.id = template.module.__name__
 #elf.starttime = template.module._modified_time
 #elf._def_regions = {}
 #elf.impl = self._load_impl(self.template.cache_impl)

 #ef _load_impl(self, name):
 #eturn _cache_plugins.load(name)(self)

 #ef get_or_create(self, key, creation_function, **kw):
 #""Retrieve a value from the cache, using the given creation function
 #o generate a new value."""

 #eturn self._ctx_get_or_create(key, creation_function, None, **kw)

 #ef _ctx_get_or_create(self, key, creation_function, context, **kw):
 #""Retrieve a value from the cache, using the given creation function
 #o generate a new value."""

 #f not self.template.cache_enabled:
 #eturn creation_function()

 #eturn self.impl.get_or_create(
 #ey, creation_function, **self._get_cache_kw(kw, context)
 #

 #ef set(self, key, value, **kw):
 #"""Place a value in the cache.

 #param key: the value's key.
 #param value: the value.
 #param \**kw: cache configuration arguments.

 #""

 #elf.impl.set(key, value, **self._get_cache_kw(kw, None))

 #ut = set
 #""A synonym for :meth:`.Cache.set`.

 #his is here for backwards compatibility.

 #""

 #ef get(self, key, **kw):
 #"""Retrieve a value from the cache.

 #param key: the value's key.
 #param \**kw: cache configuration arguments.  The
 #ackend is configured using these arguments upon first request.
 #ubsequent requests that use the same series of configuration
 #alues will use that same backend.

 #""
 #eturn self.impl.get(key, **self._get_cache_kw(kw, None))

 #ef invalidate(self, key, **kw):
 #"""Invalidate a value in the cache.

 #param key: the value's key.
 #param \**kw: cache configuration arguments.  The
 #ackend is configured using these arguments upon first request.
 #ubsequent requests that use the same series of configuration
 #alues will use that same backend.

 #""
 #elf.impl.invalidate(key, **self._get_cache_kw(kw, None))

 #ef invalidate_body(self):
 #""Invalidate the cached content of the "body" method for this
 #emplate.

 #""
 #elf.invalidate("render_body", __M_defname="render_body")

 #ef invalidate_def(self, name):
 #""Invalidate the cached content of a particular ``<%def>`` within this
 #emplate.

 #""

 #elf.invalidate("render_%s" % name, __M_defname="render_%s" % name)

 #ef invalidate_closure(self, name):
 #""Invalidate a nested ``<%def>`` within this template.

 #aching of nested defs is a blunt tool as there is no
 #anagement of scope -- nested defs that use cache tags
 #eed to have names unique of all other nested defs in the
 #emplate, else their content will be overwritten by
 #ach other.

 #""

 #elf.invalidate(name, __M_defname=name)

 #ef _get_cache_kw(self, kw, context):
 #efname = kw.pop("__M_defname", None)
 #f not defname:
 #mpl_kw = self.template.cache_args.copy()
 #mpl_kw.update(kw)
 #lif defname in self._def_regions:
 #mpl_kw = self._def_regions[defname]
 #lse:
 #mpl_kw = self.template.cache_args.copy()
 #mpl_kw.update(kw)
 #elf._def_regions[defname] = tmpl_kw
 #f context and self.impl.pass_context:
 #mpl_kw = tmpl_kw.copy()
 #mpl_kw.setdefault("context", context)
 #eturn tmpl_kw


class CacheImpl:

 #""Provide a cache implementation for use by :class:`.Cache`."""

 #ef __init__(self, cache):
 #elf.cache = cache

 #ass_context = False
 #""If ``True``, the :class:`.Context` will be passed to
 #meth:`get_or_create <.CacheImpl.get_or_create>` as the name ``'context'``.
 #""

 #ef get_or_create(self, key, creation_function, **kw):
 #"""Retrieve a value from the cache, using the given creation function
 #o generate a new value.

 #his function *must* return a value, either from
 #he cache, or via the given creation function.
 #f the creation function is called, the newly
 #reated value should be populated into the cache
 #nder the given key before being returned.

 #param key: the value's key.
 #param creation_function: function that when called generates
 # new value.
 #param \**kw: cache configuration arguments.

 #""
 #aise NotImplementedError()

 #ef set(self, key, value, **kw):
 #"""Place a value in the cache.

 #param key: the value's key.
 #param value: the value.
 #param \**kw: cache configuration arguments.

 #""
 #aise NotImplementedError()

 #ef get(self, key, **kw):
 #"""Retrieve a value from the cache.

 #param key: the value's key.
 #param \**kw: cache configuration arguments.

 #""
 #aise NotImplementedError()

 #ef invalidate(self, key, **kw):
 #"""Invalidate a value in the cache.

 #param key: the value's key.
 #param \**kw: cache configuration arguments.

 #""
 #aise NotImplementedError()
