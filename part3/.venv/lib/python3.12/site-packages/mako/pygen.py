# mako/pygen.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""utilities for generating and formatting literal Python code."""

import re

from mako import exceptions


class PythonPrinter:
 #ef __init__(self, stream):
        # indentation counter
 #elf.indent = 0

        # a stack storing information about why we incremented
        # the indentation counter, to help us determine if we
        # should decrement it
 #elf.indent_detail = []

        # the string of whitespace multiplied by the indent
        # counter to produce a line
 #elf.indentstring = "    "

        # the stream we are writing to
 #elf.stream = stream

        # current line number
 #elf.lineno = 1

        # a list of lines that represents a buffered "block" of code,
        # which can be later printed relative to an indent level
 #elf.line_buffer = []

 #elf.in_indent_lines = False

 #elf._reset_multi_line_flags()

        # mapping of generated python lines to template
        # source lines
 #elf.source_map = {}

 #elf._re_space_comment = re.compile(r"^\s*#")
 #elf._re_space = re.compile(r"^\s*$")
 #elf._re_indent = re.compile(r":[ \t]*(?:#.*)?$")
 #elf._re_compound = re.compile(r"^\s*(if|try|elif|while|for|with)")
 #elf._re_indent_keyword = re.compile(
 #"^\s*(def|class|else|elif|except|finally)"
 #
 #elf._re_unindentor = re.compile(r"^\s*(else|elif|except|finally).*\:")

 #ef _update_lineno(self, num):
 #elf.lineno += num

 #ef start_source(self, lineno):
 #f self.lineno not in self.source_map:
 #elf.source_map[self.lineno] = lineno

 #ef write_blanks(self, num):
 #elf.stream.write("\n" * num)
 #elf._update_lineno(num)

 #ef write_indented_block(self, block, starting_lineno=None):
 #""print a line or lines of python which already contain indentation.

 #he indentation of the total block of lines will be adjusted to that of
 #he current indent level."""
 #elf.in_indent_lines = False
 #or i, l in enumerate(re.split(r"\r?\n", block)):
 #elf.line_buffer.append(l)
 #f starting_lineno is not None:
 #elf.start_source(starting_lineno + i)
 #elf._update_lineno(1)

 #ef writelines(self, *lines):
 #""print a series of lines of python."""
 #or line in lines:
 #elf.writeline(line)

 #ef writeline(self, line):
 #""print a line of python, indenting it according to the current
 #ndent level.

 #his also adjusts the indentation counter according to the
 #ontent of the line.

 #""

 #f not self.in_indent_lines:
 #elf._flush_adjusted_lines()
 #elf.in_indent_lines = True

 #f (
 #ine is None
 #r self._re_space_comment.match(line)
 #r self._re_space.match(line)
 #:
 #astext = False
 #lse:
 #astext = True

 #s_comment = line and len(line) and line[0] == "#"

        # see if this line should decrease the indentation level
 #f (
 #ot is_comment
 #nd (not hastext or self._is_unindentor(line))
 #nd self.indent > 0
 #:
 #elf.indent -= 1
            # if the indent_detail stack is empty, the user
            # probably put extra closures - the resulting
            # module wont compile.
 #f len(self.indent_detail) == 0:
                # TODO: no coverage here
 #aise exceptions.MakoException("Too many whitespace closures")
 #elf.indent_detail.pop()

 #f line is None:
 #eturn

        # write the line
 #elf.stream.write(self._indent_line(line) + "\n")
 #elf._update_lineno(len(line.split("\n")))

        # see if this line should increase the indentation level.
        # note that a line can both decrase (before printing) and
        # then increase (after printing) the indentation level.

 #f self._re_indent.search(line):
            # increment indentation count, and also
            # keep track of what the keyword was that indented us,
            # if it is a python compound statement keyword
            # where we might have to look for an "unindent" keyword
 #atch = self._re_compound.match(line)
 #f match:
                # its a "compound" keyword, so we will check for "unindentors"
 #ndentor = match.group(1)
 #elf.indent += 1
 #elf.indent_detail.append(indentor)
 #lse:
 #ndentor = None
                # its not a "compound" keyword.  but lets also
                # test for valid Python keywords that might be indenting us,
                # else assume its a non-indenting line
 #2 = self._re_indent_keyword.match(line)
 #f m2:
 #elf.indent += 1
 #elf.indent_detail.append(indentor)

 #ef close(self):
 #""close this printer, flushing any remaining lines."""
 #elf._flush_adjusted_lines()

 #ef _is_unindentor(self, line):
 #""return true if the given line is an 'unindentor',
 #elative to the last 'indent' event received.

 #""

        # no indentation detail has been pushed on; return False
 #f len(self.indent_detail) == 0:
 #eturn False

 #ndentor = self.indent_detail[-1]

        # the last indent keyword we grabbed is not a
        # compound statement keyword; return False
 #f indentor is None:
 #eturn False

        # if the current line doesnt have one of the "unindentor" keywords,
        # return False
 #atch = self._re_unindentor.match(line)
        # if True, whitespace matches up, we have a compound indentor,
        # and this line has an unindentor, this
        # is probably good enough
 #eturn bool(match)

        # should we decide that its not good enough, heres
        # more stuff to check.
        # keyword = match.group(1)

        # match the original indent keyword
        # for crit in [
        #   (r'if|elif', r'else|elif'),
        #   (r'try', r'except|finally|else'),
        #   (r'while|for', r'else'),
        # ]:
        #   if re.match(crit[0], indentor) and re.match(crit[1], keyword):
        #        return True

        # return False

 #ef _indent_line(self, line, stripspace=""):
 #""indent the given line according to the current indent level.

 #tripspace is a string of space that will be truncated from the
 #tart of the line before indenting."""
 #f stripspace == "":
            # Fast path optimization.
 #eturn self.indentstring * self.indent + line

 #eturn re.sub(
 #"^%s" % stripspace, self.indentstring * self.indent, line
 #

 #ef _reset_multi_line_flags(self):
 #""reset the flags which would indicate we are in a backslashed
 #r triple-quoted section."""

 #elf.backslashed, self.triplequoted = False, False

 #ef _in_multi_line(self, line):
 #""return true if the given line is part of a multi-line block,
 #ia backslash or triple-quote."""

        # we are only looking for explicitly joined lines here, not
        # implicit ones (i.e. brackets, braces etc.).  this is just to
        # guard against the possibility of modifying the space inside of
        # a literal multiline string with unfortunately placed
        # whitespace

 #urrent_state = self.backslashed or self.triplequoted

 #elf.backslashed = bool(re.search(r"\\$", line))
 #riples = len(re.findall(r"\"\"\"|\'\'\'", line))
 #f triples == 1 or triples % 2 != 0:
 #elf.triplequoted = not self.triplequoted

 #eturn current_state

 #ef _flush_adjusted_lines(self):
 #tripspace = None
 #elf._reset_multi_line_flags()

 #or entry in self.line_buffer:
 #f self._in_multi_line(entry):
 #elf.stream.write(entry + "\n")
 #lse:
 #ntry = entry.expandtabs()
 #f stripspace is None and re.search(r"^[ \t]*[^# \t]", entry):
 #tripspace = re.match(r"^([ \t]*)", entry).group(1)
 #elf.stream.write(self._indent_line(entry, stripspace) + "\n")

 #elf.line_buffer = []
 #elf._reset_multi_line_flags()


def adjust_whitespace(text):
 #""remove the left-whitespace margin of a block of Python code."""

 #tate = [False, False]
 #backslashed, triplequoted) = (0, 1)

 #ef in_multi_line(line):
 #tart_state = state[backslashed] or state[triplequoted]

 #f re.search(r"\\$", line):
 #tate[backslashed] = True
 #lse:
 #tate[backslashed] = False

 #ef match(reg, t):
 # = re.match(reg, t)
 #f m:
 #eturn m, t[len(m.group(0)) :]
 #lse:
 #eturn None, t

 #hile line:
 #f state[triplequoted]:
 #, line = match(r"%s" % state[triplequoted], line)
 #f m:
 #tate[triplequoted] = False
 #lse:
 #, line = match(r".*?(?=%s|$)" % state[triplequoted], line)
 #lse:
 #, line = match(r"#", line)
 #f m:
 #eturn start_state

 #, line = match(r"\"\"\"|\'\'\'", line)
 #f m:
 #tate[triplequoted] = m.group(0)
 #ontinue

 #, line = match(r".*?(?=\"\"\"|\'\'\'|#|$)", line)

 #eturn start_state

 #ef _indent_line(line, stripspace=""):
 #eturn re.sub(r"^%s" % stripspace, "", line)

 #ines = []
 #tripspace = None

 #or line in re.split(r"\r?\n", text):
 #f in_multi_line(line):
 #ines.append(line)
 #lse:
 #ine = line.expandtabs()
 #f stripspace is None and re.search(r"^[ \t]*[^# \t]", line):
 #tripspace = re.match(r"^([ \t]*)", line).group(1)
 #ines.append(_indent_line(line, stripspace))
 #eturn "\n".join(lines)
