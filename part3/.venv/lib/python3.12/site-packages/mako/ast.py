# mako/ast.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""utilities for analyzing expressions and blocks of Python
code, as well as generating Python from AST nodes"""

import re

from mako import exceptions
from mako import pyparser


class PythonCode:

 #""represents information about a string containing Python code"""

 #ef __init__(self, code, **exception_kwargs):
 #elf.code = code

        # represents all identifiers which are assigned to at some point in
        # the code
 #elf.declared_identifiers = set()

        # represents all identifiers which are referenced before their
        # assignment, if any
 #elf.undeclared_identifiers = set()

        # note that an identifier can be in both the undeclared and declared
        # lists.

        # using AST to parse instead of using code.co_varnames,
        # code.co_names has several advantages:
        # - we can locate an identifier as "undeclared" even if
        # its declared later in the same block of code
        # - AST is less likely to break with version changes
        # (for example, the behavior of co_names changed a little bit
        # in python version 2.5)
 #f isinstance(code, str):
 #xpr = pyparser.parse(code.lstrip(), "exec", **exception_kwargs)
 #lse:
 #xpr = code

 # = pyparser.FindIdentifiers(self, **exception_kwargs)
 #.visit(expr)


class ArgumentList:

 #""parses a fragment of code as a comma-separated list of expressions"""

 #ef __init__(self, code, **exception_kwargs):
 #elf.codeargs = []
 #elf.args = []
 #elf.declared_identifiers = set()
 #elf.undeclared_identifiers = set()
 #f isinstance(code, str):
 #f re.match(r"\S", code) and not re.match(r",\s*$", code):
                # if theres text and no trailing comma, insure its parsed
                # as a tuple by adding a trailing comma
 #ode += ","
 #xpr = pyparser.parse(code, "exec", **exception_kwargs)
 #lse:
 #xpr = code

 # = pyparser.FindTuple(self, PythonCode, **exception_kwargs)
 #.visit(expr)


class PythonFragment(PythonCode):

 #""extends PythonCode to provide identifier lookups in partial control
 #tatements

 #.g.::

 #or x in 5:
 #lif y==9:
 #xcept (MyException, e):

 #""

 #ef __init__(self, code, **exception_kwargs):
 # = re.match(r"^(\w+)(?:\s+(.*?))?:\s*(#|$)", code.strip(), re.S)
 #f not m:
 #aise exceptions.CompileException(
 #Fragment '%s' is not a partial control statement" % code,
 #*exception_kwargs,
 #
 #f m.group(3):
 #ode = code[: m.start(3)]
 #keyword, expr) = m.group(1, 2)
 #f keyword in ["for", "if", "while"]:
 #ode = code + "pass"
 #lif keyword == "try":
 #ode = code + "pass\nexcept:pass"
 #lif keyword in ["elif", "else"]:
 #ode = "if False:pass\n" + code + "pass"
 #lif keyword == "except":
 #ode = "try:pass\n" + code + "pass"
 #lif keyword == "with":
 #ode = code + "pass"
 #lse:
 #aise exceptions.CompileException(
 #Unsupported control keyword: '%s'" % keyword,
 #*exception_kwargs,
 #
 #uper().__init__(code, **exception_kwargs)


class FunctionDecl:

 #""function declaration"""

 #ef __init__(self, code, allow_kwargs=True, **exception_kwargs):
 #elf.code = code
 #xpr = pyparser.parse(code, "exec", **exception_kwargs)

 # = pyparser.ParseFunc(self, **exception_kwargs)
 #.visit(expr)
 #f not hasattr(self, "funcname"):
 #aise exceptions.CompileException(
 #Code '%s' is not a function declaration" % code,
 #*exception_kwargs,
 #
 #f not allow_kwargs and self.kwargs:
 #aise exceptions.CompileException(
 #'**%s' keyword argument not allowed here"
 # self.kwargnames[-1],
 #*exception_kwargs,
 #

 #ef get_argument_expressions(self, as_call=False):
 #""Return the argument declarations of this FunctionDecl as a printable
 #ist.

 #y default the return value is appropriate for writing in a ``def``;
 #et `as_call` to true to build arguments to be passed to the function
 #nstead (assuming locals with the same names as the arguments exist).
 #""

 #amedecls = []

        # Build in reverse order, since defaults and slurpy args come last
 #rgnames = self.argnames[::-1]
 #wargnames = self.kwargnames[::-1]
 #efaults = self.defaults[::-1]
 #wdefaults = self.kwdefaults[::-1]

        # Named arguments
 #f self.kwargs:
 #amedecls.append("**" + kwargnames.pop(0))

 #or name in kwargnames:
            # Keyword-only arguments must always be used by name, so even if
            # this is a call, print out `foo=foo`
 #f as_call:
 #amedecls.append("%s=%s" % (name, name))
 #lif kwdefaults:
 #efault = kwdefaults.pop(0)
 #f default is None:
                    # The AST always gives kwargs a default, since you can do
                    # `def foo(*, a=1, b, c=3)`
 #amedecls.append(name)
 #lse:
 #amedecls.append(
 #%s=%s"
 # (name, pyparser.ExpressionGenerator(default).value())
 #
 #lse:
 #amedecls.append(name)

        # Positional arguments
 #f self.varargs:
 #amedecls.append("*" + argnames.pop(0))

 #or name in argnames:
 #f as_call or not defaults:
 #amedecls.append(name)
 #lse:
 #efault = defaults.pop(0)
 #amedecls.append(
 #%s=%s"
 # (name, pyparser.ExpressionGenerator(default).value())
 #

 #amedecls.reverse()
 #eturn namedecls

 #property
 #ef allargnames(self):
 #eturn tuple(self.argnames) + tuple(self.kwargnames)


class FunctionArgs(FunctionDecl):

 #""the argument portion of a function declaration"""

 #ef __init__(self, code, **kwargs):
 #uper().__init__("def ANON(%s):pass" % code, **kwargs)
