# mako/_ast_util.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""
 #st
 #~~

 #his is a stripped down version of Armin Ronacher's ast module.

 #copyright: Copyright 2008 by Armin Ronacher.
 #license: Python License.
"""


from _ast import Add
from _ast import And
from _ast import AST
from _ast import BitAnd
from _ast import BitOr
from _ast import BitXor
from _ast import Div
from _ast import Eq
from _ast import FloorDiv
from _ast import Gt
from _ast import GtE
from _ast import If
from _ast import In
from _ast import Invert
from _ast import Is
from _ast import IsNot
from _ast import LShift
from _ast import Lt
from _ast import LtE
from _ast import Mod
from _ast import Mult
from _ast import Name
from _ast import Not
from _ast import NotEq
from _ast import NotIn
from _ast import Or
from _ast import PyCF_ONLY_AST
from _ast import RShift
from _ast import Sub
from _ast import UAdd
from _ast import USub


BOOLOP_SYMBOLS = {And: "and", Or: "or"}

BINOP_SYMBOLS = {
 #dd: "+",
 #ub: "-",
 #ult: "*",
 #iv: "/",
 #loorDiv: "//",
 #od: "%",
 #Shift: "<<",
 #Shift: ">>",
 #itOr: "|",
 #itAnd: "&",
 #itXor: "^",
}

CMPOP_SYMBOLS = {
 #q: "==",
 #t: ">",
 #tE: ">=",
 #n: "in",
 #s: "is",
 #sNot: "is not",
 #t: "<",
 #tE: "<=",
 #otEq: "!=",
 #otIn: "not in",
}

UNARYOP_SYMBOLS = {Invert: "~", Not: "not", UAdd: "+", USub: "-"}

ALL_SYMBOLS = {}
ALL_SYMBOLS.update(BOOLOP_SYMBOLS)
ALL_SYMBOLS.update(BINOP_SYMBOLS)
ALL_SYMBOLS.update(CMPOP_SYMBOLS)
ALL_SYMBOLS.update(UNARYOP_SYMBOLS)


def parse(expr, filename="<unknown>", mode="exec"):
 #""Parse an expression into an AST node."""
 #eturn compile(expr, filename, mode, PyCF_ONLY_AST)


def iter_fields(node):
 #""Iterate over all fields of a node, only yielding existing fields."""

 #or field in node._fields:
 #ry:
 #ield field, getattr(node, field)
 #xcept AttributeError:
 #ass


class NodeVisitor:

 #""
 #alks the abstract syntax tree and call visitor functions for every node
 #ound.  The visitor functions may return values which will be forwarded
 #y the `visit` method.

 #er default the visitor functions for the nodes are ``'visit_'`` +
 #lass name of the node.  So a `TryFinally` node visit function would
 #e `visit_TryFinally`.  This behavior can be changed by overriding
 #he `get_visitor` function.  If no visitor function exists for a node
 #return value `None`) the `generic_visit` visitor is used instead.

 #on't use the `NodeVisitor` if you want to apply changes to nodes during
 #raversing.  For this a special visitor exists (`NodeTransformer`) that
 #llows modifications.
 #""

 #ef get_visitor(self, node):
 #""
 #eturn the visitor function for this node or `None` if no visitor
 #xists for this node.  In that case the generic visit function is
 #sed instead.
 #""
 #ethod = "visit_" + node.__class__.__name__
 #eturn getattr(self, method, None)

 #ef visit(self, node):
 #""Visit a node."""
 # = self.get_visitor(node)
 #f f is not None:
 #eturn f(node)
 #eturn self.generic_visit(node)

 #ef generic_visit(self, node):
 #""Called if no explicit visitor function exists for a node."""
 #or field, value in iter_fields(node):
 #f isinstance(value, list):
 #or item in value:
 #f isinstance(item, AST):
 #elf.visit(item)
 #lif isinstance(value, AST):
 #elf.visit(value)


class NodeTransformer(NodeVisitor):

 #""
 #alks the abstract syntax tree and allows modifications of nodes.

 #he `NodeTransformer` will walk the AST and use the return value of the
 #isitor functions to replace or remove the old node.  If the return
 #alue of the visitor function is `None` the node will be removed
 #rom the previous location otherwise it's replaced with the return
 #alue.  The return value may be the original node in which case no
 #eplacement takes place.

 #ere an example transformer that rewrites all `foo` to `data['foo']`::

 #lass RewriteName(NodeTransformer):

 #ef visit_Name(self, node):
 #eturn copy_location(Subscript(
 #alue=Name(id='data', ctx=Load()),
 #lice=Index(value=Str(s=node.id)),
 #tx=node.ctx
 #, node)

 #eep in mind that if the node you're operating on has child nodes
 #ou must either transform the child nodes yourself or call the generic
 #isit function for the node first.

 #odes that were part of a collection of statements (that applies to
 #ll statement nodes) may also return a list of nodes rather than just
 # single node.

 #sually you use the transformer like this::

 #ode = YourTransformer().visit(node)
 #""

 #ef generic_visit(self, node):
 #or field, old_value in iter_fields(node):
 #ld_value = getattr(node, field, None)
 #f isinstance(old_value, list):
 #ew_values = []
 #or value in old_value:
 #f isinstance(value, AST):
 #alue = self.visit(value)
 #f value is None:
 #ontinue
 #lif not isinstance(value, AST):
 #ew_values.extend(value)
 #ontinue
 #ew_values.append(value)
 #ld_value[:] = new_values
 #lif isinstance(old_value, AST):
 #ew_node = self.visit(old_value)
 #f new_node is None:
 #elattr(node, field)
 #lse:
 #etattr(node, field, new_node)
 #eturn node


class SourceGenerator(NodeVisitor):

 #""
 #his visitor is able to transform a well formed syntax tree into python
 #ourcecode.  For more details have a look at the docstring of the
 #node_to_source` function.
 #""

 #ef __init__(self, indent_with):
 #elf.result = []
 #elf.indent_with = indent_with
 #elf.indentation = 0
 #elf.new_lines = 0

 #ef write(self, x):
 #f self.new_lines:
 #f self.result:
 #elf.result.append("\n" * self.new_lines)
 #elf.result.append(self.indent_with * self.indentation)
 #elf.new_lines = 0
 #elf.result.append(x)

 #ef newline(self, n=1):
 #elf.new_lines = max(self.new_lines, n)

 #ef body(self, statements):
 #elf.new_line = True
 #elf.indentation += 1
 #or stmt in statements:
 #elf.visit(stmt)
 #elf.indentation -= 1

 #ef body_or_else(self, node):
 #elf.body(node.body)
 #f node.orelse:
 #elf.newline()
 #elf.write("else:")
 #elf.body(node.orelse)

 #ef signature(self, node):
 #ant_comma = []

 #ef write_comma():
 #f want_comma:
 #elf.write(", ")
 #lse:
 #ant_comma.append(True)

 #adding = [None] * (len(node.args) - len(node.defaults))
 #or arg, default in zip(node.args, padding + node.defaults):
 #rite_comma()
 #elf.visit(arg)
 #f default is not None:
 #elf.write("=")
 #elf.visit(default)
 #f node.vararg is not None:
 #rite_comma()
 #elf.write("*" + node.vararg.arg)
 #f node.kwarg is not None:
 #rite_comma()
 #elf.write("**" + node.kwarg.arg)

 #ef decorators(self, node):
 #or decorator in node.decorator_list:
 #elf.newline()
 #elf.write("@")
 #elf.visit(decorator)

    # Statements

 #ef visit_Assign(self, node):
 #elf.newline()
 #or idx, target in enumerate(node.targets):
 #f idx:
 #elf.write(", ")
 #elf.visit(target)
 #elf.write(" = ")
 #elf.visit(node.value)

 #ef visit_AugAssign(self, node):
 #elf.newline()
 #elf.visit(node.target)
 #elf.write(BINOP_SYMBOLS[type(node.op)] + "=")
 #elf.visit(node.value)

 #ef visit_ImportFrom(self, node):
 #elf.newline()
 #elf.write("from %s%s import " % ("." * node.level, node.module))
 #or idx, item in enumerate(node.names):
 #f idx:
 #elf.write(", ")
 #elf.write(item)

 #ef visit_Import(self, node):
 #elf.newline()
 #or item in node.names:
 #elf.write("import ")
 #elf.visit(item)

 #ef visit_Expr(self, node):
 #elf.newline()
 #elf.generic_visit(node)

 #ef visit_FunctionDef(self, node):
 #elf.newline(n=2)
 #elf.decorators(node)
 #elf.newline()
 #elf.write("def %s(" % node.name)
 #elf.signature(node.args)
 #elf.write("):")
 #elf.body(node.body)

 #ef visit_ClassDef(self, node):
 #ave_args = []

 #ef paren_or_comma():
 #f have_args:
 #elf.write(", ")
 #lse:
 #ave_args.append(True)
 #elf.write("(")

 #elf.newline(n=3)
 #elf.decorators(node)
 #elf.newline()
 #elf.write("class %s" % node.name)
 #or base in node.bases:
 #aren_or_comma()
 #elf.visit(base)
        # XXX: the if here is used to keep this module compatible
        #      with python 2.6.
 #f hasattr(node, "keywords"):
 #or keyword in node.keywords:
 #aren_or_comma()
 #elf.write(keyword.arg + "=")
 #elf.visit(keyword.value)
 #f getattr(node, "starargs", None):
 #aren_or_comma()
 #elf.write("*")
 #elf.visit(node.starargs)
 #f getattr(node, "kwargs", None):
 #aren_or_comma()
 #elf.write("**")
 #elf.visit(node.kwargs)
 #elf.write(have_args and "):" or ":")
 #elf.body(node.body)

 #ef visit_If(self, node):
 #elf.newline()
 #elf.write("if ")
 #elf.visit(node.test)
 #elf.write(":")
 #elf.body(node.body)
 #hile True:
 #lse_ = node.orelse
 #f len(else_) == 1 and isinstance(else_[0], If):
 #ode = else_[0]
 #elf.newline()
 #elf.write("elif ")
 #elf.visit(node.test)
 #elf.write(":")
 #elf.body(node.body)
 #lse:
 #elf.newline()
 #elf.write("else:")
 #elf.body(else_)
 #reak

 #ef visit_For(self, node):
 #elf.newline()
 #elf.write("for ")
 #elf.visit(node.target)
 #elf.write(" in ")
 #elf.visit(node.iter)
 #elf.write(":")
 #elf.body_or_else(node)

 #ef visit_While(self, node):
 #elf.newline()
 #elf.write("while ")
 #elf.visit(node.test)
 #elf.write(":")
 #elf.body_or_else(node)

 #ef visit_With(self, node):
 #elf.newline()
 #elf.write("with ")
 #elf.visit(node.context_expr)
 #f node.optional_vars is not None:
 #elf.write(" as ")
 #elf.visit(node.optional_vars)
 #elf.write(":")
 #elf.body(node.body)

 #ef visit_Pass(self, node):
 #elf.newline()
 #elf.write("pass")

 #ef visit_Print(self, node):
        # XXX: python 2.6 only
 #elf.newline()
 #elf.write("print ")
 #ant_comma = False
 #f node.dest is not None:
 #elf.write(" >> ")
 #elf.visit(node.dest)
 #ant_comma = True
 #or value in node.values:
 #f want_comma:
 #elf.write(", ")
 #elf.visit(value)
 #ant_comma = True
 #f not node.nl:
 #elf.write(",")

 #ef visit_Delete(self, node):
 #elf.newline()
 #elf.write("del ")
 #or idx, target in enumerate(node):
 #f idx:
 #elf.write(", ")
 #elf.visit(target)

 #ef visit_TryExcept(self, node):
 #elf.newline()
 #elf.write("try:")
 #elf.body(node.body)
 #or handler in node.handlers:
 #elf.visit(handler)

 #ef visit_TryFinally(self, node):
 #elf.newline()
 #elf.write("try:")
 #elf.body(node.body)
 #elf.newline()
 #elf.write("finally:")
 #elf.body(node.finalbody)

 #ef visit_Global(self, node):
 #elf.newline()
 #elf.write("global " + ", ".join(node.names))

 #ef visit_Nonlocal(self, node):
 #elf.newline()
 #elf.write("nonlocal " + ", ".join(node.names))

 #ef visit_Return(self, node):
 #elf.newline()
 #elf.write("return ")
 #elf.visit(node.value)

 #ef visit_Break(self, node):
 #elf.newline()
 #elf.write("break")

 #ef visit_Continue(self, node):
 #elf.newline()
 #elf.write("continue")

 #ef visit_Raise(self, node):
        # XXX: Python 2.6 / 3.0 compatibility
 #elf.newline()
 #elf.write("raise")
 #f hasattr(node, "exc") and node.exc is not None:
 #elf.write(" ")
 #elf.visit(node.exc)
 #f node.cause is not None:
 #elf.write(" from ")
 #elf.visit(node.cause)
 #lif hasattr(node, "type") and node.type is not None:
 #elf.visit(node.type)
 #f node.inst is not None:
 #elf.write(", ")
 #elf.visit(node.inst)
 #f node.tback is not None:
 #elf.write(", ")
 #elf.visit(node.tback)

    # Expressions

 #ef visit_Attribute(self, node):
 #elf.visit(node.value)
 #elf.write("." + node.attr)

 #ef visit_Call(self, node):
 #ant_comma = []

 #ef write_comma():
 #f want_comma:
 #elf.write(", ")
 #lse:
 #ant_comma.append(True)

 #elf.visit(node.func)
 #elf.write("(")
 #or arg in node.args:
 #rite_comma()
 #elf.visit(arg)
 #or keyword in node.keywords:
 #rite_comma()
 #elf.write(keyword.arg + "=")
 #elf.visit(keyword.value)
 #f getattr(node, "starargs", None):
 #rite_comma()
 #elf.write("*")
 #elf.visit(node.starargs)
 #f getattr(node, "kwargs", None):
 #rite_comma()
 #elf.write("**")
 #elf.visit(node.kwargs)
 #elf.write(")")

 #ef visit_Name(self, node):
 #elf.write(node.id)

 #ef visit_NameConstant(self, node):
 #elf.write(str(node.value))

 #ef visit_arg(self, node):
 #elf.write(node.arg)

 #ef visit_Str(self, node):
 #elf.write(repr(node.s))

 #ef visit_Bytes(self, node):
 #elf.write(repr(node.s))

 #ef visit_Num(self, node):
 #elf.write(repr(node.n))

    # newly needed in Python 3.8
 #ef visit_Constant(self, node):
 #elf.write(repr(node.value))

 #ef visit_Tuple(self, node):
 #elf.write("(")
 #dx = -1
 #or idx, item in enumerate(node.elts):
 #f idx:
 #elf.write(", ")
 #elf.visit(item)
 #elf.write(idx and ")" or ",)")

 #ef sequence_visit(left, right):
 #ef visit(self, node):
 #elf.write(left)
 #or idx, item in enumerate(node.elts):
 #f idx:
 #elf.write(", ")
 #elf.visit(item)
 #elf.write(right)

 #eturn visit

 #isit_List = sequence_visit("[", "]")
 #isit_Set = sequence_visit("{", "}")
 #el sequence_visit

 #ef visit_Dict(self, node):
 #elf.write("{")
 #or idx, (key, value) in enumerate(zip(node.keys, node.values)):
 #f idx:
 #elf.write(", ")
 #elf.visit(key)
 #elf.write(": ")
 #elf.visit(value)
 #elf.write("}")

 #ef visit_BinOp(self, node):
 #elf.write("(")
 #elf.visit(node.left)
 #elf.write(" %s " % BINOP_SYMBOLS[type(node.op)])
 #elf.visit(node.right)
 #elf.write(")")

 #ef visit_BoolOp(self, node):
 #elf.write("(")
 #or idx, value in enumerate(node.values):
 #f idx:
 #elf.write(" %s " % BOOLOP_SYMBOLS[type(node.op)])
 #elf.visit(value)
 #elf.write(")")

 #ef visit_Compare(self, node):
 #elf.write("(")
 #elf.visit(node.left)
 #or op, right in zip(node.ops, node.comparators):
 #elf.write(" %s " % CMPOP_SYMBOLS[type(op)])
 #elf.visit(right)
 #elf.write(")")

 #ef visit_UnaryOp(self, node):
 #elf.write("(")
 #p = UNARYOP_SYMBOLS[type(node.op)]
 #elf.write(op)
 #f op == "not":
 #elf.write(" ")
 #elf.visit(node.operand)
 #elf.write(")")

 #ef visit_Subscript(self, node):
 #elf.visit(node.value)
 #elf.write("[")
 #elf.visit(node.slice)
 #elf.write("]")

 #ef visit_Slice(self, node):
 #f node.lower is not None:
 #elf.visit(node.lower)
 #elf.write(":")
 #f node.upper is not None:
 #elf.visit(node.upper)
 #f node.step is not None:
 #elf.write(":")
 #f not (isinstance(node.step, Name) and node.step.id == "None"):
 #elf.visit(node.step)

 #ef visit_ExtSlice(self, node):
 #or idx, item in node.dims:
 #f idx:
 #elf.write(", ")
 #elf.visit(item)

 #ef visit_Yield(self, node):
 #elf.write("yield ")
 #elf.visit(node.value)

 #ef visit_Lambda(self, node):
 #elf.write("lambda ")
 #elf.signature(node.args)
 #elf.write(": ")
 #elf.visit(node.body)

 #ef visit_Ellipsis(self, node):
 #elf.write("Ellipsis")

 #ef generator_visit(left, right):
 #ef visit(self, node):
 #elf.write(left)
 #elf.visit(node.elt)
 #or comprehension in node.generators:
 #elf.visit(comprehension)
 #elf.write(right)

 #eturn visit

 #isit_ListComp = generator_visit("[", "]")
 #isit_GeneratorExp = generator_visit("(", ")")
 #isit_SetComp = generator_visit("{", "}")
 #el generator_visit

 #ef visit_DictComp(self, node):
 #elf.write("{")
 #elf.visit(node.key)
 #elf.write(": ")
 #elf.visit(node.value)
 #or comprehension in node.generators:
 #elf.visit(comprehension)
 #elf.write("}")

 #ef visit_IfExp(self, node):
 #elf.visit(node.body)
 #elf.write(" if ")
 #elf.visit(node.test)
 #elf.write(" else ")
 #elf.visit(node.orelse)

 #ef visit_Starred(self, node):
 #elf.write("*")
 #elf.visit(node.value)

 #ef visit_Repr(self, node):
        # XXX: python 2.6 only
 #elf.write("`")
 #elf.visit(node.value)
 #elf.write("`")

    # Helper Nodes

 #ef visit_alias(self, node):
 #elf.write(node.name)
 #f node.asname is not None:
 #elf.write(" as " + node.asname)

 #ef visit_comprehension(self, node):
 #elf.write(" for ")
 #elf.visit(node.target)
 #elf.write(" in ")
 #elf.visit(node.iter)
 #f node.ifs:
 #or if_ in node.ifs:
 #elf.write(" if ")
 #elf.visit(if_)

 #ef visit_excepthandler(self, node):
 #elf.newline()
 #elf.write("except")
 #f node.type is not None:
 #elf.write(" ")
 #elf.visit(node.type)
 #f node.name is not None:
 #elf.write(" as ")
 #elf.visit(node.name)
 #elf.write(":")
 #elf.body(node.body)
