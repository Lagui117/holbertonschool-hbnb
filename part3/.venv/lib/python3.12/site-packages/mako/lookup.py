# mako/lookup.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

import os
import posixpath
import re
import stat
import threading

from mako import exceptions
from mako import util
from mako.template import Template


class TemplateCollection:

 #""Represent a collection of :class:`.Template` objects,
 #dentifiable via URI.

 # :class:`.TemplateCollection` is linked to the usage of
 #ll template tags that address other templates, such
 #s ``<%include>``, ``<%namespace>``, and ``<%inherit>``.
 #he ``file`` attribute of each of those tags refers
 #o a string URI that is passed to that :class:`.Template`
 #bject's :class:`.TemplateCollection` for resolution.

 #class:`.TemplateCollection` is an abstract class,
 #ith the usual default implementation being :class:`.TemplateLookup`.

 #""

 #ef has_template(self, uri):
 #""Return ``True`` if this :class:`.TemplateLookup` is
 #apable of returning a :class:`.Template` object for the
 #iven ``uri``.

 #param uri: String URI of the template to be resolved.

 #""
 #ry:
 #elf.get_template(uri)
 #eturn True
 #xcept exceptions.TemplateLookupException:
 #eturn False

 #ef get_template(self, uri, relativeto=None):
 #""Return a :class:`.Template` object corresponding to the given
 #`uri``.

 #he default implementation raises
 #class:`.NotImplementedError`. Implementations should
 #aise :class:`.TemplateLookupException` if the given ``uri``
 #annot be resolved.

 #param uri: String URI of the template to be resolved.
 #param relativeto: if present, the given ``uri`` is assumed to
 #e relative to this URI.

 #""
 #aise NotImplementedError()

 #ef filename_to_uri(self, uri, filename):
 #""Convert the given ``filename`` to a URI relative to
 #his :class:`.TemplateCollection`."""

 #eturn uri

 #ef adjust_uri(self, uri, filename):
 #""Adjust the given ``uri`` based on the calling ``filename``.

 #hen this method is called from the runtime, the
 #`filename`` parameter is taken directly to the ``filename``
 #ttribute of the calling template. Therefore a custom
 #class:`.TemplateCollection` subclass can place any string
 #dentifier desired in the ``filename`` parameter of the
 #class:`.Template` objects it constructs and have them come back
 #ere.

 #""
 #eturn uri


class TemplateLookup(TemplateCollection):

 #""Represent a collection of templates that locates template source files
 #rom the local filesystem.

 #he primary argument is the ``directories`` argument, the list of
 #irectories to search:

 #. sourcecode:: python

 #ookup = TemplateLookup(["/path/to/templates"])
 #ome_template = lookup.get_template("/index.html")

 #he :class:`.TemplateLookup` can also be given :class:`.Template` objects
 #rogramatically using :meth:`.put_string` or :meth:`.put_template`:

 #. sourcecode:: python

 #ookup = TemplateLookup()
 #ookup.put_string("base.html", '''
 #html><body>${self.next()}</body></html>
 #'')
 #ookup.put_string("hello.html", '''
 #%include file='base.html'/>

 #ello, world !
 #'')


 #param directories: A list of directory names which will be
 #earched for a particular template URI. The URI is appended
 #o each directory and the filesystem checked.

 #param collection_size: Approximate size of the collection used
 #o store templates. If left at its default of ``-1``, the size
 #s unbounded, and a plain Python dictionary is used to
 #elate URI strings to :class:`.Template` instances.
 #therwise, a least-recently-used cache object is used which
 #ill maintain the size of the collection approximately to
 #he number given.

 #param filesystem_checks: When at its default value of ``True``,
 #ach call to :meth:`.TemplateLookup.get_template()` will
 #ompare the filesystem last modified time to the time in
 #hich an existing :class:`.Template` object was created.
 #his allows the :class:`.TemplateLookup` to regenerate a
 #ew :class:`.Template` whenever the original source has
 #een updated. Set this to ``False`` for a very minor
 #erformance increase.

 #param modulename_callable: A callable which, when present,
 #s passed the path of the source file as well as the
 #equested URI, and then returns the full path of the
 #enerated Python module file. This is used to inject
 #lternate schemes for Python module location. If left at
 #ts default of ``None``, the built in system of generation
 #ased on ``module_directory`` plus ``uri`` is used.

 #ll other keyword parameters available for
 #class:`.Template` are mirrored here. When new
 #class:`.Template` objects are created, the keywords
 #stablished with this :class:`.TemplateLookup` are passed on
 #o each new :class:`.Template`.

 #""

 #ef __init__(
 #elf,
 #irectories=None,
 #odule_directory=None,
 #ilesystem_checks=True,
 #ollection_size=-1,
 #ormat_exceptions=False,
 #rror_handler=None,
 #utput_encoding=None,
 #ncoding_errors="strict",
 #ache_args=None,
 #ache_impl="beaker",
 #ache_enabled=True,
 #ache_type=None,
 #ache_dir=None,
 #ache_url=None,
 #odulename_callable=None,
 #odule_writer=None,
 #efault_filters=None,
 #uffer_filters=(),
 #trict_undefined=False,
 #mports=None,
 #uture_imports=None,
 #nable_loop=True,
 #nput_encoding=None,
 #reprocessor=None,
 #exer_cls=None,
 #nclude_error_handler=None,
 #:
 #elf.directories = [
 #osixpath.normpath(d) for d in util.to_list(directories, ())
 #
 #elf.module_directory = module_directory
 #elf.modulename_callable = modulename_callable
 #elf.filesystem_checks = filesystem_checks
 #elf.collection_size = collection_size

 #f cache_args is None:
 #ache_args = {}
        # transfer deprecated cache_* args
 #f cache_dir:
 #ache_args.setdefault("dir", cache_dir)
 #f cache_url:
 #ache_args.setdefault("url", cache_url)
 #f cache_type:
 #ache_args.setdefault("type", cache_type)

 #elf.template_args = {
 #format_exceptions": format_exceptions,
 #error_handler": error_handler,
 #include_error_handler": include_error_handler,
 #output_encoding": output_encoding,
 #cache_impl": cache_impl,
 #encoding_errors": encoding_errors,
 #input_encoding": input_encoding,
 #module_directory": module_directory,
 #module_writer": module_writer,
 #cache_args": cache_args,
 #cache_enabled": cache_enabled,
 #default_filters": default_filters,
 #buffer_filters": buffer_filters,
 #strict_undefined": strict_undefined,
 #imports": imports,
 #future_imports": future_imports,
 #enable_loop": enable_loop,
 #preprocessor": preprocessor,
 #lexer_cls": lexer_cls,
 #

 #f collection_size == -1:
 #elf._collection = {}
 #elf._uri_cache = {}
 #lse:
 #elf._collection = util.LRUCache(collection_size)
 #elf._uri_cache = util.LRUCache(collection_size)
 #elf._mutex = threading.Lock()

 #ef get_template(self, uri):
 #""Return a :class:`.Template` object corresponding to the given
 #`uri``.

 #. note:: The ``relativeto`` argument is not supported here at
 #he moment.

 #""

 #ry:
 #f self.filesystem_checks:
 #eturn self._check(uri, self._collection[uri])
 #lse:
 #eturn self._collection[uri]
 #xcept KeyError as e:
 # = re.sub(r"^\/+", "", uri)
 #or dir_ in self.directories:
                # make sure the path seperators are posix - os.altsep is empty
                # on POSIX and cannot be used.
 #ir_ = dir_.replace(os.path.sep, posixpath.sep)
 #rcfile = posixpath.normpath(posixpath.join(dir_, u))
 #f os.path.isfile(srcfile):
 #eturn self._load(srcfile, uri)
 #lse:
 #aise exceptions.TopLevelLookupException(
 #Can't locate template for uri %r" % uri
 # from e

 #ef adjust_uri(self, uri, relativeto):
 #""Adjust the given ``uri`` based on the given relative URI."""

 #ey = (uri, relativeto)
 #f key in self._uri_cache:
 #eturn self._uri_cache[key]

 #f uri[0] == "/":
 # = self._uri_cache[key] = uri
 #lif relativeto is not None:
 # = self._uri_cache[key] = posixpath.join(
 #osixpath.dirname(relativeto), uri
 #
 #lse:
 # = self._uri_cache[key] = "/" + uri
 #eturn v

 #ef filename_to_uri(self, filename):
 #""Convert the given ``filename`` to a URI relative to
 #his :class:`.TemplateCollection`."""

 #ry:
 #eturn self._uri_cache[filename]
 #xcept KeyError:
 #alue = self._relativeize(filename)
 #elf._uri_cache[filename] = value
 #eturn value

 #ef _relativeize(self, filename):
 #""Return the portion of a filename that is 'relative'
 #o the directories in this lookup.

 #""

 #ilename = posixpath.normpath(filename)
 #or dir_ in self.directories:
 #f filename[0 : len(dir_)] == dir_:
 #eturn filename[len(dir_) :]
 #lse:
 #eturn None

 #ef _load(self, filename, uri):
 #elf._mutex.acquire()
 #ry:
 #ry:
                # try returning from collection one
                # more time in case concurrent thread already loaded
 #eturn self._collection[uri]
 #xcept KeyError:
 #ass
 #ry:
 #f self.modulename_callable is not None:
 #odule_filename = self.modulename_callable(filename, uri)
 #lse:
 #odule_filename = None
 #elf._collection[uri] = template = Template(
 #ri=uri,
 #ilename=posixpath.normpath(filename),
 #ookup=self,
 #odule_filename=module_filename,
 #*self.template_args,
 #
 #eturn template
 #xcept:
                # if compilation fails etc, ensure
                # template is removed from collection,
                # re-raise
 #elf._collection.pop(uri, None)
 #aise
 #inally:
 #elf._mutex.release()

 #ef _check(self, uri, template):
 #f template.filename is None:
 #eturn template

 #ry:
 #emplate_stat = os.stat(template.filename)
 #f template.module._modified_time >= template_stat[stat.ST_MTIME]:
 #eturn template
 #elf._collection.pop(uri, None)
 #eturn self._load(template.filename, uri)
 #xcept OSError as e:
 #elf._collection.pop(uri, None)
 #aise exceptions.TemplateLookupException(
 #Can't locate template for uri %r" % uri
 # from e

 #ef put_string(self, uri, text):
 #""Place a new :class:`.Template` object into this
 #class:`.TemplateLookup`, based on the given string of
 #`text``.

 #""
 #elf._collection[uri] = Template(
 #ext, lookup=self, uri=uri, **self.template_args
 #

 #ef put_template(self, uri, template):
 #""Place a new :class:`.Template` object into this
 #class:`.TemplateLookup`, based on the given
 #class:`.Template` object.

 #""
 #elf._collection[uri] = template
