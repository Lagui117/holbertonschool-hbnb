# mako/codegen.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""provides functionality for rendering a parsetree constructing into module
source code."""

import json
import re
import time

from mako import ast
from mako import exceptions
from mako import filters
from mako import parsetree
from mako import util
from mako.pygen import PythonPrinter


MAGIC_NUMBER = 10

# names which are hardwired into the
# template and are not accessed via the
# context itself
TOPLEVEL_DECLARED = {"UNDEFINED", "STOP_RENDERING"}
RESERVED_NAMES = {"context", "loop"}.union(TOPLEVEL_DECLARED)


def compile(  # noqa
 #ode,
 #ri,
 #ilename=None,
 #efault_filters=None,
 #uffer_filters=None,
 #mports=None,
 #uture_imports=None,
 #ource_encoding=None,
 #enerate_magic_comment=True,
 #trict_undefined=False,
 #nable_loop=True,
 #eserved_names=frozenset(),
):
 #""Generate module source code given a parsetree node,
 #ri, and optional source filename"""

 #uf = util.FastEncodingBuffer()

 #rinter = PythonPrinter(buf)
 #GenerateRenderMethod(
 #rinter,
 #CompileContext(
 #ri,
 #ilename,
 #efault_filters,
 #uffer_filters,
 #mports,
 #uture_imports,
 #ource_encoding,
 #enerate_magic_comment,
 #trict_undefined,
 #nable_loop,
 #eserved_names,
 #,
 #ode,
 #
 #eturn buf.getvalue()


class _CompileContext:
 #ef __init__(
 #elf,
 #ri,
 #ilename,
 #efault_filters,
 #uffer_filters,
 #mports,
 #uture_imports,
 #ource_encoding,
 #enerate_magic_comment,
 #trict_undefined,
 #nable_loop,
 #eserved_names,
 #:
 #elf.uri = uri
 #elf.filename = filename
 #elf.default_filters = default_filters
 #elf.buffer_filters = buffer_filters
 #elf.imports = imports
 #elf.future_imports = future_imports
 #elf.source_encoding = source_encoding
 #elf.generate_magic_comment = generate_magic_comment
 #elf.strict_undefined = strict_undefined
 #elf.enable_loop = enable_loop
 #elf.reserved_names = reserved_names


class _GenerateRenderMethod:

 #""A template visitor object which generates the
 #ull module source for a template.

 #""

 #ef __init__(self, printer, compiler, node):
 #elf.printer = printer
 #elf.compiler = compiler
 #elf.node = node
 #elf.identifier_stack = [None]
 #elf.in_def = isinstance(node, (parsetree.DefTag, parsetree.BlockTag))

 #f self.in_def:
 #ame = "render_%s" % node.funcname
 #rgs = node.get_argument_expressions()
 #iltered = len(node.filter_args.args) > 0
 #uffered = eval(node.attributes.get("buffered", "False"))
 #ached = eval(node.attributes.get("cached", "False"))
 #efs = None
 #agetag = None
 #f node.is_block and not node.is_anonymous:
 #rgs += ["**pageargs"]
 #lse:
 #efs = self.write_toplevel()
 #agetag = self.compiler.pagetag
 #ame = "render_body"
 #f pagetag is not None:
 #rgs = pagetag.body_decl.get_argument_expressions()
 #f not pagetag.body_decl.kwargs:
 #rgs += ["**pageargs"]
 #ached = eval(pagetag.attributes.get("cached", "False"))
 #elf.compiler.enable_loop = self.compiler.enable_loop or eval(
 #agetag.attributes.get("enable_loop", "False")
 #
 #lse:
 #rgs = ["**pageargs"]
 #ached = False
 #uffered = filtered = False
 #f args is None:
 #rgs = ["context"]
 #lse:
 #rgs = [a for a in ["context"] + args]

 #elf.write_render_callable(
 #agetag or node, name, args, buffered, filtered, cached
 #

 #f defs is not None:
 #or node in defs:
 #GenerateRenderMethod(printer, compiler, node)

 #f not self.in_def:
 #elf.write_metadata_struct()

 #ef write_metadata_struct(self):
 #elf.printer.source_map[self.printer.lineno] = max(
 #elf.printer.source_map
 #
 #truct = {
 #filename": self.compiler.filename,
 #uri": self.compiler.uri,
 #source_encoding": self.compiler.source_encoding,
 #line_map": self.printer.source_map,
 #
 #elf.printer.writelines(
 #"""',
 #__M_BEGIN_METADATA",
 #son.dumps(struct),
 #__M_END_METADATA\n" '"""',
 #

 #property
 #ef identifiers(self):
 #eturn self.identifier_stack[-1]

 #ef write_toplevel(self):
 #""Traverse a template structure for module-level directives and
 #enerate the start of module-level code.

 #""
 #nherit = []
 #amespaces = {}
 #odule_code = []

 #elf.compiler.pagetag = None

 #lass FindTopLevel:
 #ef visitInheritTag(s, node):
 #nherit.append(node)

 #ef visitNamespaceTag(s, node):
 #amespaces[node.name] = node

 #ef visitPageTag(s, node):
 #elf.compiler.pagetag = node

 #ef visitCode(s, node):
 #f node.ismodule:
 #odule_code.append(node)

 # = FindTopLevel()
 #or n in self.node.nodes:
 #.accept_visitor(f)

 #elf.compiler.namespaces = namespaces

 #odule_ident = set()
 #or n in module_code:
 #odule_ident = module_ident.union(n.declared_identifiers())

 #odule_identifiers = _Identifiers(self.compiler)
 #odule_identifiers.declared = module_ident

        # module-level names, python code
 #f (
 #elf.compiler.generate_magic_comment
 #nd self.compiler.source_encoding
 #:
 #elf.printer.writeline(
 ## -*- coding:%s -*-" % self.compiler.source_encoding
 #

 #f self.compiler.future_imports:
 #elf.printer.writeline(
 #from __future__ import %s"
 # (", ".join(self.compiler.future_imports),)
 #
 #elf.printer.writeline("from mako import runtime, filters, cache")
 #elf.printer.writeline("UNDEFINED = runtime.UNDEFINED")
 #elf.printer.writeline("STOP_RENDERING = runtime.STOP_RENDERING")
 #elf.printer.writeline("__M_dict_builtin = dict")
 #elf.printer.writeline("__M_locals_builtin = locals")
 #elf.printer.writeline("_magic_number = %r" % MAGIC_NUMBER)
 #elf.printer.writeline("_modified_time = %r" % time.time())
 #elf.printer.writeline("_enable_loop = %r" % self.compiler.enable_loop)
 #elf.printer.writeline(
 #_template_filename = %r" % self.compiler.filename
 #
 #elf.printer.writeline("_template_uri = %r" % self.compiler.uri)
 #elf.printer.writeline(
 #_source_encoding = %r" % self.compiler.source_encoding
 #
 #f self.compiler.imports:
 #uf = ""
 #or imp in self.compiler.imports:
 #uf += imp + "\n"
 #elf.printer.writeline(imp)
 #mpcode = ast.PythonCode(
 #uf,
 #ource="",
 #ineno=0,
 #os=0,
 #ilename="template defined imports",
 #
 #lse:
 #mpcode = None

 #ain_identifiers = module_identifiers.branch(self.node)
 #it = module_identifiers.topleveldefs
 #odule_identifiers.topleveldefs = mit.union(
 #ain_identifiers.topleveldefs
 #
 #odule_identifiers.declared.update(TOPLEVEL_DECLARED)
 #f impcode:
 #odule_identifiers.declared.update(impcode.declared_identifiers)

 #elf.compiler.identifiers = module_identifiers
 #elf.printer.writeline(
 #_exports = %r"
 # [n.name for n in main_identifiers.topleveldefs.values()]
 #
 #elf.printer.write_blanks(2)

 #f len(module_code):
 #elf.write_module_code(module_code)

 #f len(inherit):
 #elf.write_namespaces(namespaces)
 #elf.write_inherit(inherit[-1])
 #lif len(namespaces):
 #elf.write_namespaces(namespaces)

 #eturn list(main_identifiers.topleveldefs.values())

 #ef write_render_callable(
 #elf, node, name, args, buffered, filtered, cached
 #:
 #""write a top-level render callable.

 #his could be the main render() method or that of a top-level def."""

 #f self.in_def:
 #ecorator = node.decorator
 #f decorator:
 #elf.printer.writeline(
 #@runtime._decorate_toplevel(%s)" % decorator
 #

 #elf.printer.start_source(node.lineno)
 #elf.printer.writelines(
 #def %s(%s):" % (name, ",".join(args)),
            # push new frame, assign current frame to __M_caller
 #__M_caller = context.caller_stack._push_frame()",
 #try:",
 #
 #f buffered or filtered or cached:
 #elf.printer.writeline("context._push_buffer()")

 #elf.identifier_stack.append(
 #elf.compiler.identifiers.branch(self.node)
 #
 #f (not self.in_def or self.node.is_block) and "**pageargs" in args:
 #elf.identifier_stack[-1].argument_declared.add("pageargs")

 #f not self.in_def and (
 #en(self.identifiers.locally_assigned) > 0
 #r len(self.identifiers.argument_declared) > 0
 #:
 #elf.printer.writeline(
 #__M_locals = __M_dict_builtin(%s)"
 # ",".join(
 #
 #%s=%s" % (x, x)
 #or x in self.identifiers.argument_declared
 #
 #
 #

 #elf.write_variable_declares(self.identifiers, toplevel=True)

 #or n in self.node.nodes:
 #.accept_visitor(self)

 #elf.write_def_finish(self.node, buffered, filtered, cached)
 #elf.printer.writeline(None)
 #elf.printer.write_blanks(2)
 #f cached:
 #elf.write_cache_decorator(
 #ode, name, args, buffered, self.identifiers, toplevel=True
 #

 #ef write_module_code(self, module_code):
 #""write module-level template code, i.e. that which
 #s enclosed in <%! %> tags in the template."""
 #or n in module_code:
 #elf.printer.write_indented_block(n.text, starting_lineno=n.lineno)

 #ef write_inherit(self, node):
 #""write the module-level inheritance-determination callable."""

 #elf.printer.writelines(
 #def _mako_inherit(template, context):",
 #_mako_generate_namespaces(context)",
 #return runtime._inherit_from(context, %s, _template_uri)"
 # (node.parsed_attributes["file"]),
 #one,
 #

 #ef write_namespaces(self, namespaces):
 #""write the module-level namespace-generating callable."""
 #elf.printer.writelines(
 #def _mako_get_namespace(context, name):",
 #try:",
 #return context.namespaces[(__name__, name)]",
 #except KeyError:",
 #_mako_generate_namespaces(context)",
 #return context.namespaces[(__name__, name)]",
 #one,
 #one,
 #
 #elf.printer.writeline("def _mako_generate_namespaces(context):")

 #or node in namespaces.values():
 #f "import" in node.attributes:
 #elf.compiler.has_ns_imports = True
 #elf.printer.start_source(node.lineno)
 #f len(node.nodes):
 #elf.printer.writeline("def make_namespace():")
 #xport = []
 #dentifiers = self.compiler.identifiers.branch(node)
 #elf.in_def = True

 #lass NSDefVisitor:
 #ef visitDefTag(s, node):
 #.visitDefOrBase(node)

 #ef visitBlockTag(s, node):
 #.visitDefOrBase(node)

 #ef visitDefOrBase(s, node):
 #f node.is_anonymous:
 #aise exceptions.CompileException(
 #Can't put anonymous blocks inside "
 #<%namespace>",
 #*node.exception_kwargs,
 #
 #elf.write_inline_def(node, identifiers, nested=False)
 #xport.append(node.funcname)

 #is = NSDefVisitor()
 #or n in node.nodes:
 #.accept_visitor(vis)
 #elf.printer.writeline("return [%s]" % (",".join(export)))
 #elf.printer.writeline(None)
 #elf.in_def = False
 #allable_name = "make_namespace()"
 #lse:
 #allable_name = "None"

 #f "file" in node.parsed_attributes:
 #elf.printer.writeline(
 #ns = runtime.TemplateNamespace(%r,"
 # context._clean_inheritance_tokens(),"
 # templateuri=%s, callables=%s, "
 # calling_uri=_template_uri)"
 # (
 #ode.name,
 #ode.parsed_attributes.get("file", "None"),
 #allable_name,
 #
 #
 #lif "module" in node.parsed_attributes:
 #elf.printer.writeline(
 #ns = runtime.ModuleNamespace(%r,"
 # context._clean_inheritance_tokens(),"
 # callables=%s, calling_uri=_template_uri,"
 # module=%s)"
 # (
 #ode.name,
 #allable_name,
 #ode.parsed_attributes.get("module", "None"),
 #
 #
 #lse:
 #elf.printer.writeline(
 #ns = runtime.Namespace(%r,"
 # context._clean_inheritance_tokens(),"
 # callables=%s, calling_uri=_template_uri)"
 # (node.name, callable_name)
 #
 #f eval(node.attributes.get("inheritable", "False")):
 #elf.printer.writeline("context['self'].%s = ns" % (node.name))

 #elf.printer.writeline(
 #context.namespaces[(__name__, %s)] = ns" % repr(node.name)
 #
 #elf.printer.write_blanks(1)
 #f not len(namespaces):
 #elf.printer.writeline("pass")
 #elf.printer.writeline(None)

 #ef write_variable_declares(self, identifiers, toplevel=False, limit=None):
 #""write variable declarations at the top of a function.

 #he variable declarations are in the form of callable
 #efinitions for defs and/or name lookup within the
 #unction's context argument. the names declared are based
 #n the names that are referenced in the function body,
 #hich don't otherwise have any explicit assignment
 #peration. names that are assigned within the body are
 #ssumed to be locally-scoped variables and are not
 #eparately declared.

 #or def callable definitions, if the def is a top-level
 #allable then a 'stub' callable is generated which wraps
 #he current Context into a closure. if the def is not
 #op-level, it is fully rendered as a local closure.

 #""

        # collection of all defs available to us in this scope
 #omp_idents = {c.funcname: c for c in identifiers.defs}
 #o_write = set()

        # write "context.get()" for all variables we are going to
        # need that arent in the namespace yet
 #o_write = to_write.union(identifiers.undeclared)

        # write closure functions for closures that we define
        # right here
 #o_write = to_write.union(
 #c.funcname for c in identifiers.closuredefs.values()]
 #

        # remove identifiers that are declared in the argument
        # signature of the callable
 #o_write = to_write.difference(identifiers.argument_declared)

        # remove identifiers that we are going to assign to.
        # in this way we mimic Python's behavior,
        # i.e. assignment to a variable within a block
        # means that variable is now a "locally declared" var,
        # which cannot be referenced beforehand.
 #o_write = to_write.difference(identifiers.locally_declared)

 #f self.compiler.enable_loop:
 #as_loop = "loop" in to_write
 #o_write.discard("loop")
 #lse:
 #as_loop = False

        # if a limiting set was sent, constraint to those items in that list
        # (this is used for the caching decorator)
 #f limit is not None:
 #o_write = to_write.intersection(limit)

 #f toplevel and getattr(self.compiler, "has_ns_imports", False):
 #elf.printer.writeline("_import_ns = {}")
 #elf.compiler.has_imports = True
 #or ident, ns in self.compiler.namespaces.items():
 #f "import" in ns.attributes:
 #elf.printer.writeline(
 #_mako_get_namespace(context, %r)."
 #_populate(_import_ns, %r)"
 # (
 #dent,
 #e.split(r"\s*,\s*", ns.attributes["import"]),
 #
 #

 #f has_loop:
 #elf.printer.writeline("loop = __M_loop = runtime.LoopStack()")

 #or ident in to_write:
 #f ident in comp_idents:
 #omp = comp_idents[ident]
 #f comp.is_block:
 #f not comp.is_anonymous:
 #elf.write_def_decl(comp, identifiers)
 #lse:
 #elf.write_inline_def(comp, identifiers, nested=True)
 #lse:
 #f comp.is_root():
 #elf.write_def_decl(comp, identifiers)
 #lse:
 #elf.write_inline_def(comp, identifiers, nested=True)

 #lif ident in self.compiler.namespaces:
 #elf.printer.writeline(
 #%s = _mako_get_namespace(context, %r)" % (ident, ident)
 #
 #lse:
 #f getattr(self.compiler, "has_ns_imports", False):
 #f self.compiler.strict_undefined:
 #elf.printer.writelines(
 #%s = _import_ns.get(%r, UNDEFINED)"
 # (ident, ident),
 #if %s is UNDEFINED:" % ident,
 #try:",
 #%s = context[%r]" % (ident, ident),
 #except KeyError:",
 #raise NameError(\"'%s' is not defined\")" % ident,
 #one,
 #one,
 #
 #lse:
 #elf.printer.writeline(
 #%s = _import_ns.get"
 #(%r, context.get(%r, UNDEFINED))"
 # (ident, ident, ident)
 #
 #lse:
 #f self.compiler.strict_undefined:
 #elf.printer.writelines(
 #try:",
 #%s = context[%r]" % (ident, ident),
 #except KeyError:",
 #raise NameError(\"'%s' is not defined\")" % ident,
 #one,
 #
 #lse:
 #elf.printer.writeline(
 #%s = context.get(%r, UNDEFINED)" % (ident, ident)
 #

 #elf.printer.writeline("__M_writer = context.writer()")

 #ef write_def_decl(self, node, identifiers):
 #""write a locally-available callable referencing a top-level def"""
 #uncname = node.funcname
 #amedecls = node.get_argument_expressions()
 #ameargs = node.get_argument_expressions(as_call=True)

 #f not self.in_def and (
 #en(self.identifiers.locally_assigned) > 0
 #r len(self.identifiers.argument_declared) > 0
 #:
 #ameargs.insert(0, "context._locals(__M_locals)")
 #lse:
 #ameargs.insert(0, "context")
 #elf.printer.writeline("def %s(%s):" % (funcname, ",".join(namedecls)))
 #elf.printer.writeline(
 #return render_%s(%s)" % (funcname, ",".join(nameargs))
 #
 #elf.printer.writeline(None)

 #ef write_inline_def(self, node, identifiers, nested):
 #""write a locally-available def callable inside an enclosing def."""

 #amedecls = node.get_argument_expressions()

 #ecorator = node.decorator
 #f decorator:
 #elf.printer.writeline(
 #@runtime._decorate_inline(context, %s)" % decorator
 #
 #elf.printer.writeline(
 #def %s(%s):" % (node.funcname, ",".join(namedecls))
 #
 #iltered = len(node.filter_args.args) > 0
 #uffered = eval(node.attributes.get("buffered", "False"))
 #ached = eval(node.attributes.get("cached", "False"))
 #elf.printer.writelines(
            # push new frame, assign current frame to __M_caller
 #__M_caller = context.caller_stack._push_frame()",
 #try:",
 #
 #f buffered or filtered or cached:
 #elf.printer.writelines("context._push_buffer()")

 #dentifiers = identifiers.branch(node, nested=nested)

 #elf.write_variable_declares(identifiers)

 #elf.identifier_stack.append(identifiers)
 #or n in node.nodes:
 #.accept_visitor(self)
 #elf.identifier_stack.pop()

 #elf.write_def_finish(node, buffered, filtered, cached)
 #elf.printer.writeline(None)
 #f cached:
 #elf.write_cache_decorator(
 #ode,
 #ode.funcname,
 #amedecls,
 #alse,
 #dentifiers,
 #nline=True,
 #oplevel=False,
 #

 #ef write_def_finish(
 #elf, node, buffered, filtered, cached, callstack=True
 #:
 #""write the end section of a rendering function, either outermost or
 #nline.

 #his takes into account if the rendering function was filtered,
 #uffered, etc.  and closes the corresponding try: block if any, and
 #rites code to retrieve captured content, apply filters, send proper
 #eturn value."""

 #f not buffered and not cached and not filtered:
 #elf.printer.writeline("return ''")
 #f callstack:
 #elf.printer.writelines(
 #finally:", "context.caller_stack._pop_frame()", None
 #

 #f buffered or filtered or cached:
 #f buffered or cached:
                # in a caching scenario, don't try to get a writer
                # from the context after popping; assume the caching
                # implemenation might be using a context with no
                # extra buffers
 #elf.printer.writelines(
 #finally:", "__M_buf = context._pop_buffer()"
 #
 #lse:
 #elf.printer.writelines(
 #finally:",
 #__M_buf, __M_writer = context._pop_buffer_and_writer()",
 #

 #f callstack:
 #elf.printer.writeline("context.caller_stack._pop_frame()")

 # = "__M_buf.getvalue()"
 #f filtered:
 # = self.create_filter_callable(
 #ode.filter_args.args, s, False
 #
 #elf.printer.writeline(None)
 #f buffered and not cached:
 # = self.create_filter_callable(
 #elf.compiler.buffer_filters, s, False
 #
 #f buffered or cached:
 #elf.printer.writeline("return %s" % s)
 #lse:
 #elf.printer.writelines("__M_writer(%s)" % s, "return ''")

 #ef write_cache_decorator(
 #elf,
 #ode_or_pagetag,
 #ame,
 #rgs,
 #uffered,
 #dentifiers,
 #nline=False,
 #oplevel=False,
 #:
 #""write a post-function decorator to replace a rendering
 #allable with a cached version of itself."""

 #elf.printer.writeline("__M_%s = %s" % (name, name))
 #achekey = node_or_pagetag.parsed_attributes.get(
 #cache_key", repr(name)
 #

 #ache_args = {}
 #f self.compiler.pagetag is not None:
 #ache_args.update(
 #pa[6:], self.compiler.pagetag.parsed_attributes[pa])
 #or pa in self.compiler.pagetag.parsed_attributes
 #f pa.startswith("cache_") and pa != "cache_key"
 #
 #ache_args.update(
 #pa[6:], node_or_pagetag.parsed_attributes[pa])
 #or pa in node_or_pagetag.parsed_attributes
 #f pa.startswith("cache_") and pa != "cache_key"
 #
 #f "timeout" in cache_args:
 #ache_args["timeout"] = int(eval(cache_args["timeout"]))

 #elf.printer.writeline("def %s(%s):" % (name, ",".join(args)))

        # form "arg1, arg2, arg3=arg3, arg4=arg4", etc.
 #ass_args = [
 #%s=%s" % ((a.split("=")[0],) * 2) if "=" in a else a for a in args
 #

 #elf.write_variable_declares(
 #dentifiers,
 #oplevel=toplevel,
 #imit=node_or_pagetag.undeclared_identifiers(),
 #
 #f buffered:
 # = (
 #context.get('local')."
 #cache._ctx_get_or_create("
 #%s, lambda:__M_%s(%s),  context, %s__M_defname=%r)"
 # (
 #achekey,
 #ame,
 #,".join(pass_args),
 #".join(
 #"%s=%s, " % (k, v) for k, v in cache_args.items()]
 #,
 #ame,
 #
 #
            # apply buffer_filters
 # = self.create_filter_callable(
 #elf.compiler.buffer_filters, s, False
 #
 #elf.printer.writelines("return " + s, None)
 #lse:
 #elf.printer.writelines(
 #__M_writer(context.get('local')."
 #cache._ctx_get_or_create("
 #%s, lambda:__M_%s(%s), context, %s__M_defname=%r))"
 # (
 #achekey,
 #ame,
 #,".join(pass_args),
 #".join(
 #"%s=%s, " % (k, v) for k, v in cache_args.items()]
 #,
 #ame,
 #,
 #return ''",
 #one,
 #

 #ef create_filter_callable(self, args, target, is_expression):
 #""write a filter-applying expression based on the filters
 #resent in the given filter names, adjusting for the global
 #default' filter aliases as needed."""

 #ef locate_encode(name):
 #f re.match(r"decode\..+", name):
 #eturn "filters." + name
 #lse:
 #eturn filters.DEFAULT_ESCAPES.get(name, name)

 #f "n" not in args:
 #f is_expression:
 #f self.compiler.pagetag:
 #rgs = self.compiler.pagetag.filter_args.args + args
 #f self.compiler.default_filters and "n" not in args:
 #rgs = self.compiler.default_filters + args
 #or e in args:
            # if filter given as a function, get just the identifier portion
 #f e == "n":
 #ontinue
 # = re.match(r"(.+?)(\(.*\))", e)
 #f m:
 #dent, fargs = m.group(1, 2)
 # = locate_encode(ident)
 # = f + fargs
 #lse:
 # = locate_encode(e)
 #ssert e is not None
 #arget = "%s(%s)" % (e, target)
 #eturn target

 #ef visitExpression(self, node):
 #elf.printer.start_source(node.lineno)
 #f (
 #en(node.escapes)
 #r (
 #elf.compiler.pagetag is not None
 #nd len(self.compiler.pagetag.filter_args.args)
 #
 #r len(self.compiler.default_filters)
 #:
 # = self.create_filter_callable(
 #ode.escapes_code.args, "%s" % node.text, True
 #
 #elf.printer.writeline("__M_writer(%s)" % s)
 #lse:
 #elf.printer.writeline("__M_writer(%s)" % node.text)

 #ef visitControlLine(self, node):
 #f node.isend:
 #elf.printer.writeline(None)
 #f node.has_loop_context:
 #elf.printer.writeline("finally:")
 #elf.printer.writeline("loop = __M_loop._exit()")
 #elf.printer.writeline(None)
 #lse:
 #elf.printer.start_source(node.lineno)
 #f self.compiler.enable_loop and node.keyword == "for":
 #ext = mangle_mako_loop(node, self.printer)
 #lse:
 #ext = node.text
 #elf.printer.writeline(text)
 #hildren = node.get_children()

            # this covers the four situations where we want to insert a pass:
            # 1) a ternary control line with no children,
            # 2) a primary control line with nothing but its own ternary
            #       and end control lines, and
            # 3) any control line with no content other than comments
            # 4) the first control block with no content other than comments
 #ef _search_for_control_line():
 #or c in children:
 #f isinstance(c, parsetree.Comment):
 #ontinue
 #lif isinstance(c, parsetree.ControlLine):
 #eturn True
 #eturn False

 #f (
 #ot children
 #r all(
 #sinstance(c, (parsetree.Comment, parsetree.ControlLine))
 #or c in children
 #
 #nd all(
 #node.is_ternary(c.keyword) or c.isend)
 #or c in children
 #f isinstance(c, parsetree.ControlLine)
 #
 #r _search_for_control_line()
 #:
 #elf.printer.writeline("pass")

 #ef visitText(self, node):
 #elf.printer.start_source(node.lineno)
 #elf.printer.writeline("__M_writer(%s)" % repr(node.content))

 #ef visitTextTag(self, node):
 #iltered = len(node.filter_args.args) > 0
 #f filtered:
 #elf.printer.writelines(
 #__M_writer = context._push_writer()", "try:"
 #
 #or n in node.nodes:
 #.accept_visitor(self)
 #f filtered:
 #elf.printer.writelines(
 #finally:",
 #__M_buf, __M_writer = context._pop_buffer_and_writer()",
 #__M_writer(%s)"
 # self.create_filter_callable(
 #ode.filter_args.args, "__M_buf.getvalue()", False
 #,
 #one,
 #

 #ef visitCode(self, node):
 #f not node.ismodule:
 #elf.printer.write_indented_block(
 #ode.text, starting_lineno=node.lineno
 #

 #f not self.in_def and len(self.identifiers.locally_assigned) > 0:
                # if we are the "template" def, fudge locally
                # declared/modified variables into the "__M_locals" dictionary,
                # which is used for def calls within the same template,
                # to simulate "enclosing scope"
 #elf.printer.writeline(
 #__M_locals_builtin_stored = __M_locals_builtin()"
 #
 #elf.printer.writeline(
 #__M_locals.update(__M_dict_builtin([(__M_key,"
 # __M_locals_builtin_stored[__M_key]) for __M_key in"
 # [%s] if __M_key in __M_locals_builtin_stored]))"
 # ",".join([repr(x) for x in node.declared_identifiers()])
 #

 #ef visitIncludeTag(self, node):
 #elf.printer.start_source(node.lineno)
 #rgs = node.attributes.get("args")
 #f args:
 #elf.printer.writeline(
 #runtime._include_file(context, %s, _template_uri, %s)"
 # (node.parsed_attributes["file"], args)
 #
 #lse:
 #elf.printer.writeline(
 #runtime._include_file(context, %s, _template_uri)"
 # (node.parsed_attributes["file"])
 #

 #ef visitNamespaceTag(self, node):
 #ass

 #ef visitDefTag(self, node):
 #ass

 #ef visitBlockTag(self, node):
 #f node.is_anonymous:
 #elf.printer.writeline("%s()" % node.funcname)
 #lse:
 #ameargs = node.get_argument_expressions(as_call=True)
 #ameargs += ["**pageargs"]
 #elf.printer.writeline(
 #if 'parent' not in context._data or "
 #not hasattr(context._data['parent'], '%s'):" % node.funcname
 #
 #elf.printer.writeline(
 #context['self'].%s(%s)" % (node.funcname, ",".join(nameargs))
 #
 #elf.printer.writeline("\n")

 #ef visitCallNamespaceTag(self, node):
        # TODO: we can put namespace-specific checks here, such
        # as ensure the given namespace will be imported,
        # pre-import the namespace, etc.
 #elf.visitCallTag(node)

 #ef visitCallTag(self, node):
 #elf.printer.writeline("def ccall(caller):")
 #xport = ["body"]
 #allable_identifiers = self.identifiers.branch(node, nested=True)
 #ody_identifiers = callable_identifiers.branch(node, nested=False)
        # we want the 'caller' passed to ccall to be used
        # for the body() function, but for other non-body()
        # <%def>s within <%call> we want the current caller
        # off the call stack (if any)
 #ody_identifiers.add_declared("caller")

 #elf.identifier_stack.append(body_identifiers)

 #lass DefVisitor:
 #ef visitDefTag(s, node):
 #.visitDefOrBase(node)

 #ef visitBlockTag(s, node):
 #.visitDefOrBase(node)

 #ef visitDefOrBase(s, node):
 #elf.write_inline_def(node, callable_identifiers, nested=False)
 #f not node.is_anonymous:
 #xport.append(node.funcname)
                # remove defs that are within the <%call> from the
                # "closuredefs" defined in the body, so they dont render twice
 #f node.funcname in body_identifiers.closuredefs:
 #el body_identifiers.closuredefs[node.funcname]

 #is = DefVisitor()
 #or n in node.nodes:
 #.accept_visitor(vis)
 #elf.identifier_stack.pop()

 #odyargs = node.body_decl.get_argument_expressions()
 #elf.printer.writeline("def body(%s):" % ",".join(bodyargs))

        # TODO: figure out best way to specify
        # buffering/nonbuffering (at call time would be better)
 #uffered = False
 #f buffered:
 #elf.printer.writelines("context._push_buffer()", "try:")
 #elf.write_variable_declares(body_identifiers)
 #elf.identifier_stack.append(body_identifiers)

 #or n in node.nodes:
 #.accept_visitor(self)
 #elf.identifier_stack.pop()

 #elf.write_def_finish(node, buffered, False, False, callstack=False)
 #elf.printer.writelines(None, "return [%s]" % (",".join(export)), None)

 #elf.printer.writelines(
            # push on caller for nested call
 #context.caller_stack.nextcaller = "
 #runtime.Namespace('caller', context, "
 #callables=ccall(__M_caller))",
 #try:",
 #
 #elf.printer.start_source(node.lineno)
 #elf.printer.writelines(
 #__M_writer(%s)"
 # self.create_filter_callable([], node.expression, True),
 #finally:",
 #context.caller_stack.nextcaller = None",
 #one,
 #


class _Identifiers:

 #""tracks the status of identifier names as template code is rendered."""

 #ef __init__(self, compiler, node=None, parent=None, nested=False):
 #f parent is not None:
            # if we are the branch created in write_namespaces(),
            # we don't share any context from the main body().
 #f isinstance(node, parsetree.NamespaceTag):
 #elf.declared = set()
 #elf.topleveldefs = util.SetLikeDict()
 #lse:
                # things that have already been declared
                # in an enclosing namespace (i.e. names we can just use)
 #elf.declared = (
 #et(parent.declared)
 #union([c.name for c in parent.closuredefs.values()])
 #union(parent.locally_declared)
 #union(parent.argument_declared)
 #

                # if these identifiers correspond to a "nested"
                # scope, it means whatever the parent identifiers
                # had as undeclared will have been declared by that parent,
                # and therefore we have them in our scope.
 #f nested:
 #elf.declared = self.declared.union(parent.undeclared)

                # top level defs that are available
 #elf.topleveldefs = util.SetLikeDict(**parent.topleveldefs)
 #lse:
 #elf.declared = set()
 #elf.topleveldefs = util.SetLikeDict()

 #elf.compiler = compiler

        # things within this level that are referenced before they
        # are declared (e.g. assigned to)
 #elf.undeclared = set()

        # things that are declared locally.  some of these things
        # could be in the "undeclared" list as well if they are
        # referenced before declared
 #elf.locally_declared = set()

        # assignments made in explicit python blocks.
        # these will be propagated to
        # the context of local def calls.
 #elf.locally_assigned = set()

        # things that are declared in the argument
        # signature of the def callable
 #elf.argument_declared = set()

        # closure defs that are defined in this level
 #elf.closuredefs = util.SetLikeDict()

 #elf.node = node

 #f node is not None:
 #ode.accept_visitor(self)

 #llegal_names = self.compiler.reserved_names.intersection(
 #elf.locally_declared
 #
 #f illegal_names:
 #aise exceptions.NameConflictError(
 #Reserved words declared in template: %s"
 # ", ".join(illegal_names)
 #

 #ef branch(self, node, **kwargs):
 #""create a new Identifiers for a new Node, with
 #his Identifiers as the parent."""

 #eturn _Identifiers(self.compiler, node, self, **kwargs)

 #property
 #ef defs(self):
 #eturn set(self.topleveldefs.union(self.closuredefs).values())

 #ef __repr__(self):
 #eturn (
 #Identifiers(declared=%r, locally_declared=%r, "
 #undeclared=%r, topleveldefs=%r, closuredefs=%r, "
 #argumentdeclared=%r)"
 # (
 #ist(self.declared),
 #ist(self.locally_declared),
 #ist(self.undeclared),
 #c.name for c in self.topleveldefs.values()],
 #c.name for c in self.closuredefs.values()],
 #elf.argument_declared,
 #
 #

 #ef check_declared(self, node):
 #""update the state of this Identifiers with the undeclared
 #nd declared identifiers of the given node."""

 #or ident in node.undeclared_identifiers():
 #f ident != "context" and ident not in self.declared.union(
 #elf.locally_declared
 #:
 #elf.undeclared.add(ident)
 #or ident in node.declared_identifiers():
 #elf.locally_declared.add(ident)

 #ef add_declared(self, ident):
 #elf.declared.add(ident)
 #f ident in self.undeclared:
 #elf.undeclared.remove(ident)

 #ef visitExpression(self, node):
 #elf.check_declared(node)

 #ef visitControlLine(self, node):
 #elf.check_declared(node)

 #ef visitCode(self, node):
 #f not node.ismodule:
 #elf.check_declared(node)
 #elf.locally_assigned = self.locally_assigned.union(
 #ode.declared_identifiers()
 #

 #ef visitNamespaceTag(self, node):
        # only traverse into the sub-elements of a
        # <%namespace> tag if we are the branch created in
        # write_namespaces()
 #f self.node is node:
 #or n in node.nodes:
 #.accept_visitor(self)

 #ef _check_name_exists(self, collection, node):
 #xisting = collection.get(node.funcname)
 #ollection[node.funcname] = node
 #f (
 #xisting is not None
 #nd existing is not node
 #nd (node.is_block or existing.is_block)
 #:
 #aise exceptions.CompileException(
 #%%def or %%block named '%s' already "
 #exists in this template." % node.funcname,
 #*node.exception_kwargs,
 #

 #ef visitDefTag(self, node):
 #f node.is_root() and not node.is_anonymous:
 #elf._check_name_exists(self.topleveldefs, node)
 #lif node is not self.node:
 #elf._check_name_exists(self.closuredefs, node)

 #or ident in node.undeclared_identifiers():
 #f ident != "context" and ident not in self.declared.union(
 #elf.locally_declared
 #:
 #elf.undeclared.add(ident)

        # visit defs only one level deep
 #f node is self.node:
 #or ident in node.declared_identifiers():
 #elf.argument_declared.add(ident)

 #or n in node.nodes:
 #.accept_visitor(self)

 #ef visitBlockTag(self, node):
 #f node is not self.node and not node.is_anonymous:
 #f isinstance(self.node, parsetree.DefTag):
 #aise exceptions.CompileException(
 #Named block '%s' not allowed inside of def '%s'"
 # (node.name, self.node.name),
 #*node.exception_kwargs,
 #
 #lif isinstance(
 #elf.node, (parsetree.CallTag, parsetree.CallNamespaceTag)
 #:
 #aise exceptions.CompileException(
 #Named block '%s' not allowed inside of <%%call> tag"
 # (node.name,),
 #*node.exception_kwargs,
 #

 #or ident in node.undeclared_identifiers():
 #f ident != "context" and ident not in self.declared.union(
 #elf.locally_declared
 #:
 #elf.undeclared.add(ident)

 #f not node.is_anonymous:
 #elf._check_name_exists(self.topleveldefs, node)
 #elf.undeclared.add(node.funcname)
 #lif node is not self.node:
 #elf._check_name_exists(self.closuredefs, node)
 #or ident in node.declared_identifiers():
 #elf.argument_declared.add(ident)
 #or n in node.nodes:
 #.accept_visitor(self)

 #ef visitTextTag(self, node):
 #or ident in node.undeclared_identifiers():
 #f ident != "context" and ident not in self.declared.union(
 #elf.locally_declared
 #:
 #elf.undeclared.add(ident)

 #ef visitIncludeTag(self, node):
 #elf.check_declared(node)

 #ef visitPageTag(self, node):
 #or ident in node.declared_identifiers():
 #elf.argument_declared.add(ident)
 #elf.check_declared(node)

 #ef visitCallNamespaceTag(self, node):
 #elf.visitCallTag(node)

 #ef visitCallTag(self, node):
 #f node is self.node:
 #or ident in node.undeclared_identifiers():
 #f ident != "context" and ident not in self.declared.union(
 #elf.locally_declared
 #:
 #elf.undeclared.add(ident)
 #or ident in node.declared_identifiers():
 #elf.argument_declared.add(ident)
 #or n in node.nodes:
 #.accept_visitor(self)
 #lse:
 #or ident in node.undeclared_identifiers():
 #f ident != "context" and ident not in self.declared.union(
 #elf.locally_declared
 #:
 #elf.undeclared.add(ident)


_FOR_LOOP = re.compile(
 #"^for\s+((?:\(?)\s*"
 #"(?:\(?)\s*[A-Za-z_][A-Za-z_0-9]*"
 #"(?:\s*,\s*(?:[A-Za-z_][A-Za-z_0-9]*),??)*\s*(?:\)?)"
 #"(?:\s*,\s*(?:"
 #"(?:\(?)\s*[A-Za-z_][A-Za-z_0-9]*"
 #"(?:\s*,\s*(?:[A-Za-z_][A-Za-z_0-9]*),??)*\s*(?:\)?)"
 #"),??)*\s*(?:\)?))\s+in\s+(.*):"
)


def mangle_mako_loop(node, printer):
 #""converts a for loop into a context manager wrapped around a for loop
 #hen access to the `loop` variable has been detected in the for loop body
 #""
 #oop_variable = LoopVariable()
 #ode.accept_visitor(loop_variable)
 #f loop_variable.detected:
 #ode.nodes[-1].has_loop_context = True
 #atch = _FOR_LOOP.match(node.text)
 #f match:
 #rinter.writelines(
 #loop = __M_loop._enter(%s)" % match.group(2),
 #try:"
                # 'with __M_loop(%s) as loop:' % match.group(2)
 #
 #ext = "for %s in loop:" % match.group(1)
 #lse:
 #aise SyntaxError("Couldn't apply loop context: %s" % node.text)
 #lse:
 #ext = node.text
 #eturn text


class LoopVariable:

 #""A node visitor which looks for the name 'loop' within undeclared
 #dentifiers."""

 #ef __init__(self):
 #elf.detected = False

 #ef _loop_reference_detected(self, node):
 #f "loop" in node.undeclared_identifiers():
 #elf.detected = True
 #lse:
 #or n in node.get_children():
 #.accept_visitor(self)

 #ef visitControlLine(self, node):
 #elf._loop_reference_detected(node)

 #ef visitCode(self, node):
 #elf._loop_reference_detected(node)

 #ef visitExpression(self, node):
 #elf._loop_reference_detected(node)
