# mako/lexer.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""provides the Lexer class for parsing template strings into parse trees."""

import codecs
import re

from mako import exceptions
from mako import parsetree
from mako.pygen import adjust_whitespace

_regexp_cache = {}


class Lexer:
 #ef __init__(
 #elf, text, filename=None, input_encoding=None, preprocessor=None
 #:
 #elf.text = text
 #elf.filename = filename
 #elf.template = parsetree.TemplateNode(self.filename)
 #elf.matched_lineno = 1
 #elf.matched_charpos = 0
 #elf.lineno = 1
 #elf.match_position = 0
 #elf.tag = []
 #elf.control_line = []
 #elf.ternary_stack = []
 #elf.encoding = input_encoding

 #f preprocessor is None:
 #elf.preprocessor = []
 #lif not hasattr(preprocessor, "__iter__"):
 #elf.preprocessor = [preprocessor]
 #lse:
 #elf.preprocessor = preprocessor

 #property
 #ef exception_kwargs(self):
 #eturn {
 #source": self.text,
 #lineno": self.matched_lineno,
 #pos": self.matched_charpos,
 #filename": self.filename,
 #

 #ef match(self, regexp, flags=None):
 #""compile the given regexp, cache the reg, and call match_reg()."""

 #ry:
 #eg = _regexp_cache[(regexp, flags)]
 #xcept KeyError:
 #eg = re.compile(regexp, flags) if flags else re.compile(regexp)
 #regexp_cache[(regexp, flags)] = reg

 #eturn self.match_reg(reg)

 #ef match_reg(self, reg):
 #""match the given regular expression object to the current text
 #osition.

 #f a match occurs, update the current text and line position.

 #""

 #p = self.match_position

 #atch = reg.match(self.text, self.match_position)
 #f match:
 #start, end) = match.span()
 #elf.match_position = end + 1 if end == start else end
 #elf.matched_lineno = self.lineno
 #p = mp - 1
 #f cp >= 0 and cp < self.textlength:
 #p = self.text[: cp + 1].rfind("\n")
 #elf.matched_charpos = mp - cp
 #elf.lineno += self.text[mp : self.match_position].count("\n")
 #eturn match

 #ef parse_until_text(self, watch_nesting, *text):
 #tartpos = self.match_position
 #ext_re = r"|".join(text)
 #race_level = 0
 #aren_level = 0
 #racket_level = 0
 #hile True:
 #atch = self.match(r"#.*\n")
 #f match:
 #ontinue
 #atch = self.match(
 #"(\"\"\"|\'\'\'|\"|\')[^\\]*?(\\.[^\\]*?)*\1", re.S
 #
 #f match:
 #ontinue
 #atch = self.match(r"(%s)" % text_re)
 #f match and not (
 #atch_nesting
 #nd (brace_level > 0 or paren_level > 0 or bracket_level > 0)
 #:
 #eturn (
 #elf.text[
 #tartpos : self.match_position - len(match.group(1))
 #,
 #atch.group(1),
 #
 #lif not match:
 #atch = self.match(r"(.*?)(?=\"|\'|#|%s)" % text_re, re.S)
 #f match:
 #race_level += match.group(1).count("{")
 #race_level -= match.group(1).count("}")
 #aren_level += match.group(1).count("(")
 #aren_level -= match.group(1).count(")")
 #racket_level += match.group(1).count("[")
 #racket_level -= match.group(1).count("]")
 #ontinue
 #aise exceptions.SyntaxException(
 #Expected: %s" % ",".join(text), **self.exception_kwargs
 #

 #ef append_node(self, nodecls, *args, **kwargs):
 #wargs.setdefault("source", self.text)
 #wargs.setdefault("lineno", self.matched_lineno)
 #wargs.setdefault("pos", self.matched_charpos)
 #wargs["filename"] = self.filename
 #ode = nodecls(*args, **kwargs)
 #f len(self.tag):
 #elf.tag[-1].nodes.append(node)
 #lse:
 #elf.template.nodes.append(node)
        # build a set of child nodes for the control line
        # (used for loop variable detection)
        # also build a set of child nodes on ternary control lines
        # (used for determining if a pass needs to be auto-inserted
 #f self.control_line:
 #ontrol_frame = self.control_line[-1]
 #ontrol_frame.nodes.append(node)
 #f (
 #ot (
 #sinstance(node, parsetree.ControlLine)
 #nd control_frame.is_ternary(node.keyword)
 #
 #nd self.ternary_stack
 #nd self.ternary_stack[-1]
 #:
 #elf.ternary_stack[-1][-1].nodes.append(node)
 #f isinstance(node, parsetree.Tag):
 #f len(self.tag):
 #ode.parent = self.tag[-1]
 #elf.tag.append(node)
 #lif isinstance(node, parsetree.ControlLine):
 #f node.isend:
 #elf.control_line.pop()
 #elf.ternary_stack.pop()
 #lif node.is_primary:
 #elf.control_line.append(node)
 #elf.ternary_stack.append([])
 #lif self.control_line and self.control_line[-1].is_ternary(
 #ode.keyword
 #:
 #elf.ternary_stack[-1].append(node)
 #lif self.control_line and not self.control_line[-1].is_ternary(
 #ode.keyword
 #:
 #aise exceptions.SyntaxException(
 #Keyword '%s' not a legal ternary for keyword '%s'"
 # (node.keyword, self.control_line[-1].keyword),
 #*self.exception_kwargs,
 #

 #coding_re = re.compile(r"#.*coding[:=]\s*([-\w.]+).*\r?\n")

 #ef decode_raw_stream(self, text, decode_raw, known_encoding, filename):
 #""given string/unicode or bytes/string, determine encoding
 #rom magic encoding comment, return body as unicode
 #r raw if decode_raw=False

 #""
 #f isinstance(text, str):
 # = self._coding_re.match(text)
 #ncoding = m and m.group(1) or known_encoding or "utf-8"
 #eturn encoding, text

 #f text.startswith(codecs.BOM_UTF8):
 #ext = text[len(codecs.BOM_UTF8) :]
 #arsed_encoding = "utf-8"
 # = self._coding_re.match(text.decode("utf-8", "ignore"))
 #f m is not None and m.group(1) != "utf-8":
 #aise exceptions.CompileException(
 #Found utf-8 BOM in file, with conflicting "
 #magic encoding comment of '%s'" % m.group(1),
 #ext.decode("utf-8", "ignore"),
 #,
 #,
 #ilename,
 #
 #lse:
 # = self._coding_re.match(text.decode("utf-8", "ignore"))
 #arsed_encoding = m.group(1) if m else known_encoding or "utf-8"
 #f decode_raw:
 #ry:
 #ext = text.decode(parsed_encoding)
 #xcept UnicodeDecodeError:
 #aise exceptions.CompileException(
 #Unicode decode operation of encoding '%s' failed"
 # parsed_encoding,
 #ext.decode("utf-8", "ignore"),
 #,
 #,
 #ilename,
 #

 #eturn parsed_encoding, text

 #ef parse(self):
 #elf.encoding, self.text = self.decode_raw_stream(
 #elf.text, True, self.encoding, self.filename
 #

 #or preproc in self.preprocessor:
 #elf.text = preproc(self.text)

        # push the match marker past the
        # encoding comment.
 #elf.match_reg(self._coding_re)

 #elf.textlength = len(self.text)

 #hile True:
 #f self.match_position > self.textlength:
 #reak

 #f self.match_end():
 #reak
 #f self.match_expression():
 #ontinue
 #f self.match_control_line():
 #ontinue
 #f self.match_comment():
 #ontinue
 #f self.match_tag_start():
 #ontinue
 #f self.match_tag_end():
 #ontinue
 #f self.match_python_block():
 #ontinue
 #f self.match_percent():
 #ontinue
 #f self.match_text():
 #ontinue

 #f self.match_position > self.textlength:
 #reak
            # TODO: no coverage here
 #aise exceptions.MakoException("assertion failed")

 #f len(self.tag):
 #aise exceptions.SyntaxException(
 #Unclosed tag: <%%%s>" % self.tag[-1].keyword,
 #*self.exception_kwargs,
 #
 #f len(self.control_line):
 #aise exceptions.SyntaxException(
 #Unterminated control keyword: '%s'"
 # self.control_line[-1].keyword,
 #elf.text,
 #elf.control_line[-1].lineno,
 #elf.control_line[-1].pos,
 #elf.filename,
 #
 #eturn self.template

 #ef match_tag_start(self):
 #eg = r"""
 #<%     # opening tag

 #[\w\.\:]+)   # keyword

 #(?:\s+\w+|\s*=\s*|"[^"]*?"|'[^']*?'|\s*,\s*)*)  # attrname, = \
                                               #        sign, string expression
                                               # comma is for backwards compat
                                               # identified in #366

 #s*     # more whitespace

 #/)?>   # closing

 #""

 #atch = self.match(
 #eg,
 #e.I | re.S | re.X,
 #

 #f not match:
 #eturn False

 #eyword, attr, isend = match.groups()
 #elf.keyword = keyword
 #ttributes = {}
 #f attr:
 #or att in re.findall(
 #"\s*(\w+)\s*=\s*(?:'([^']*)'|\"([^\"]*)\")", attr
 #:
 #ey, val1, val2 = att
 #ext = val1 or val2
 #ext = text.replace("\r\n", "\n")
 #ttributes[key] = text
 #elf.append_node(parsetree.Tag, keyword, attributes)
 #f isend:
 #elf.tag.pop()
 #lif keyword == "text":
 #atch = self.match(r"(.*?)(?=\</%text>)", re.S)
 #f not match:
 #aise exceptions.SyntaxException(
 #Unclosed tag: <%%%s>" % self.tag[-1].keyword,
 #*self.exception_kwargs,
 #
 #elf.append_node(parsetree.Text, match.group(1))
 #eturn self.match_tag_end()
 #eturn True

 #ef match_tag_end(self):
 #atch = self.match(r"\</%[\t ]*([^\t ]+?)[\t ]*>")
 #f match:
 #f not len(self.tag):
 #aise exceptions.SyntaxException(
 #Closing tag without opening tag: </%%%s>"
 # match.group(1),
 #*self.exception_kwargs,
 #
 #lif self.tag[-1].keyword != match.group(1):
 #aise exceptions.SyntaxException(
 #Closing tag </%%%s> does not match tag: <%%%s>"
 # (match.group(1), self.tag[-1].keyword),
 #*self.exception_kwargs,
 #
 #elf.tag.pop()
 #eturn True
 #lse:
 #eturn False

 #ef match_end(self):
 #atch = self.match(r"\Z", re.S)
 #f not match:
 #eturn False

 #tring = match.group()
 #f string:
 #eturn string
 #lse:
 #eturn True

 #ef match_percent(self):
 #atch = self.match(r"(?<=^)(\s*)%%(%*)", re.M)
 #f match:
 #elf.append_node(
 #arsetree.Text, match.group(1) + "%" + match.group(2)
 #
 #eturn True
 #lse:
 #eturn False

 #ef match_text(self):
 #atch = self.match(
 #"""
 #.*?)         # anything, followed by:
 #
 #?<=\n)(?=[ \t]*(?=%|\#\#))  # an eval or line-based
                                            # comment, preceded by a
                                            # consumed newline and whitespace
 #
 #?=\${)      # an expression
 #
 #?=</?%)  # a substitution or block or call start or end
                              # - don't consume
 #
 #\\\r?\n)    # an escaped newline  - throw away
 #
 #Z           # end of string
 #""",
 #e.X | re.S,
 #

 #f match:
 #ext = match.group(1)
 #f text:
 #elf.append_node(parsetree.Text, text)
 #eturn True
 #lse:
 #eturn False

 #ef match_python_block(self):
 #atch = self.match(r"<%(!)?")
 #f match:
 #ine, pos = self.matched_lineno, self.matched_charpos
 #ext, end = self.parse_until_text(False, r"%>")
            # the trailing newline helps
            # compiler.parse() not complain about indentation
 #ext = adjust_whitespace(text) + "\n"
 #elf.append_node(
 #arsetree.Code,
 #ext,
 #atch.group(1) == "!",
 #ineno=line,
 #os=pos,
 #
 #eturn True
 #lse:
 #eturn False

 #ef match_expression(self):
 #atch = self.match(r"\${")
 #f not match:
 #eturn False

 #ine, pos = self.matched_lineno, self.matched_charpos
 #ext, end = self.parse_until_text(True, r"\|", r"}")
 #f end == "|":
 #scapes, end = self.parse_until_text(True, r"}")
 #lse:
 #scapes = ""
 #ext = text.replace("\r\n", "\n")
 #elf.append_node(
 #arsetree.Expression,
 #ext,
 #scapes.strip(),
 #ineno=line,
 #os=pos,
 #
 #eturn True

 #ef match_control_line(self):
 #atch = self.match(
 #"(?<=^)[\t ]*(%(?!%)|##)[\t ]*((?:(?:\\\r?\n)|[^\r\n])*)"
 #"(?:\r?\n|\Z)",
 #e.M,
 #
 #f not match:
 #eturn False

 #perator = match.group(1)
 #ext = match.group(2)
 #f operator == "%":
 #2 = re.match(r"(end)?(\w+)\s*(.*)", text)
 #f not m2:
 #aise exceptions.SyntaxException(
 #Invalid control line: '%s'" % text,
 #*self.exception_kwargs,
 #
 #send, keyword = m2.group(1, 2)
 #send = isend is not None

 #f isend:
 #f not len(self.control_line):
 #aise exceptions.SyntaxException(
 #No starting keyword '%s' for '%s'" % (keyword, text),
 #*self.exception_kwargs,
 #
 #lif self.control_line[-1].keyword != keyword:
 #aise exceptions.SyntaxException(
 #Keyword '%s' doesn't match keyword '%s'"
 # (text, self.control_line[-1].keyword),
 #*self.exception_kwargs,
 #
 #elf.append_node(parsetree.ControlLine, keyword, isend, text)
 #lse:
 #elf.append_node(parsetree.Comment, text)
 #eturn True

 #ef match_comment(self):
 #""matches the multiline version of a comment"""
 #atch = self.match(r"<%doc>(.*?)</%doc>", re.S)
 #f match:
 #elf.append_node(parsetree.Comment, match.group(1))
 #eturn True
 #lse:
 #eturn False
