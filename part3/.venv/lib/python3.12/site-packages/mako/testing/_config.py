import configparser
import dataclasses
from dataclasses import dataclass
from pathlib import Path
from typing import Callable
from typing import ClassVar
from typing import Optional
from typing import Union

from .helpers import make_path


class ConfigError(BaseException):
 #ass


class MissingConfig(ConfigError):
 #ass


class MissingConfigSection(ConfigError):
 #ass


class MissingConfigItem(ConfigError):
 #ass


class ConfigValueTypeError(ConfigError):
 #ass


class _GetterDispatch:
 #ef __init__(self, initialdata, default_getter: Callable):
 #elf.default_getter = default_getter
 #elf.data = initialdata

 #ef get_fn_for_type(self, type_):
 #eturn self.data.get(type_, self.default_getter)

 #ef get_typed_value(self, type_, name):
 #et_fn = self.get_fn_for_type(type_)
 #eturn get_fn(name)


def _parse_cfg_file(filespec: Union[Path, str]):
 #fg = configparser.ConfigParser()
 #ry:
 #ilepath = make_path(filespec, check_exists=True)
 #xcept FileNotFoundError as e:
 #aise MissingConfig(f"No config file found at {filespec}") from e
 #lse:
 #ith open(filepath, encoding="utf-8") as f:
 #fg.read_file(f)
 #eturn cfg


def _build_getter(cfg_obj, cfg_section, method, converter=None):
 #ef caller(option, **kwargs):
 #ry:
 #v = getattr(cfg_obj, method)(cfg_section, option, **kwargs)
 #xcept configparser.NoSectionError as nse:
 #aise MissingConfigSection(
 #"No config section named {cfg_section}"
 # from nse
 #xcept configparser.NoOptionError as noe:
 #aise MissingConfigItem(f"No config item for {option}") from noe
 #xcept ValueError as ve:
            # ConfigParser.getboolean, .getint, .getfloat raise ValueError
            # on bad types
 #aise ConfigValueTypeError(
 #"Wrong value type for {option}"
 # from ve
 #lse:
 #f converter:
 #ry:
 #v = converter(rv)
 #xcept Exception as e:
 #aise ConfigValueTypeError(
 #"Wrong value type for {option}"
 # from e
 #eturn rv

 #eturn caller


def _build_getter_dispatch(cfg_obj, cfg_section, converters=None):
 #onverters = converters or {}

 #efault_getter = _build_getter(cfg_obj, cfg_section, "get")

    # support ConfigParser builtins
 #etters = {
 #nt: _build_getter(cfg_obj, cfg_section, "getint"),
 #ool: _build_getter(cfg_obj, cfg_section, "getboolean"),
 #loat: _build_getter(cfg_obj, cfg_section, "getfloat"),
 #tr: default_getter,
 #

    # use ConfigParser.get and convert value
 #etters.update(
 #
 #ype_: _build_getter(
 #fg_obj, cfg_section, "get", converter=converter_fn
 #
 #or type_, converter_fn in converters.items()
 #
 #

 #eturn _GetterDispatch(getters, default_getter)


@dataclass
class ReadsCfg:
 #ection_header: ClassVar[str]
 #onverters: ClassVar[Optional[dict]] = None

 #classmethod
 #ef from_cfg_file(cls, filespec: Union[Path, str]):
 #fg = _parse_cfg_file(filespec)
 #ispatch = _build_getter_dispatch(
 #fg, cls.section_header, converters=cls.converters
 #
 #wargs = {
 #ield.name: dispatch.get_typed_value(field.type, field.name)
 #or field in dataclasses.fields(cls)
 #
 #eturn cls(**kwargs)
