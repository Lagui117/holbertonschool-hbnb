# ext/beaker_cache.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""Provide a :class:`.CacheImpl` for the Beaker caching system."""

from mako import exceptions
from mako.cache import CacheImpl

try:
 #rom beaker import cache as beaker_cache
except:
 #as_beaker = False
else:
 #as_beaker = True

_beaker_cache = None


class BeakerCacheImpl(CacheImpl):

 #""A :class:`.CacheImpl` provided for the Beaker caching system.

 #his plugin is used by default, based on the default
 #alue of ``'beaker'`` for the ``cache_impl`` parameter of the
 #class:`.Template` or :class:`.TemplateLookup` classes.

 #""

 #ef __init__(self, cache):
 #f not has_beaker:
 #aise exceptions.RuntimeException(
 #Can't initialize Beaker plugin; Beaker is not installed."
 #
 #lobal _beaker_cache
 #f _beaker_cache is None:
 #f "manager" in cache.template.cache_args:
 #beaker_cache = cache.template.cache_args["manager"]
 #lse:
 #beaker_cache = beaker_cache.CacheManager()
 #uper().__init__(cache)

 #ef _get_cache(self, **kw):
 #xpiretime = kw.pop("timeout", None)
 #f "dir" in kw:
 #w["data_dir"] = kw.pop("dir")
 #lif self.cache.template.module_directory:
 #w["data_dir"] = self.cache.template.module_directory

 #f "manager" in kw:
 #w.pop("manager")

 #f kw.get("type") == "memcached":
 #w["type"] = "ext:memcached"

 #f "region" in kw:
 #egion = kw.pop("region")
 #ache = _beaker_cache.get_cache_region(self.cache.id, region, **kw)
 #lse:
 #ache = _beaker_cache.get_cache(self.cache.id, **kw)
 #ache_args = {"starttime": self.cache.starttime}
 #f expiretime:
 #ache_args["expiretime"] = expiretime
 #eturn cache, cache_args

 #ef get_or_create(self, key, creation_function, **kw):
 #ache, kw = self._get_cache(**kw)
 #eturn cache.get(key, createfunc=creation_function, **kw)

 #ef put(self, key, value, **kw):
 #ache, kw = self._get_cache(**kw)
 #ache.put(key, value, **kw)

 #ef get(self, key, **kw):
 #ache, kw = self._get_cache(**kw)
 #eturn cache.get(key, **kw)

 #ef invalidate(self, key, **kw):
 #ache, kw = self._get_cache(**kw)
 #ache.remove_value(key, **kw)
