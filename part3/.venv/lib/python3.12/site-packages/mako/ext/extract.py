# ext/extract.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

from io import BytesIO
from io import StringIO
import re

from mako import lexer
from mako import parsetree


class MessageExtractor:
 #se_bytes = True

 #ef process_file(self, fileobj):
 #emplate_node = lexer.Lexer(
 #ileobj.read(), input_encoding=self.config["encoding"]
 #.parse()
 #ield from self.extract_nodes(template_node.get_children())

 #ef extract_nodes(self, nodes):
 #ranslator_comments = []
 #n_translator_comments = False
 #nput_encoding = self.config["encoding"] or "ascii"
 #omment_tags = list(
 #ilter(None, re.split(r"\s+", self.config["comment-tags"]))
 #

 #or node in nodes:
 #hild_nodes = None
 #f (
 #n_translator_comments
 #nd isinstance(node, parsetree.Text)
 #nd not node.content.strip()
 #:
                # Ignore whitespace within translator comments
 #ontinue

 #f isinstance(node, parsetree.Comment):
 #alue = node.text.strip()
 #f in_translator_comments:
 #ranslator_comments.extend(
 #elf._split_comment(node.lineno, value)
 #
 #ontinue
 #or comment_tag in comment_tags:
 #f value.startswith(comment_tag):
 #n_translator_comments = True
 #ranslator_comments.extend(
 #elf._split_comment(node.lineno, value)
 #
 #ontinue

 #f isinstance(node, parsetree.DefTag):
 #ode = node.function_decl.code
 #hild_nodes = node.nodes
 #lif isinstance(node, parsetree.BlockTag):
 #ode = node.body_decl.code
 #hild_nodes = node.nodes
 #lif isinstance(node, parsetree.CallTag):
 #ode = node.code.code
 #hild_nodes = node.nodes
 #lif isinstance(node, parsetree.PageTag):
 #ode = node.body_decl.code
 #lif isinstance(node, parsetree.CallNamespaceTag):
 #ode = node.expression
 #hild_nodes = node.nodes
 #lif isinstance(node, parsetree.ControlLine):
 #f node.isend:
 #n_translator_comments = False
 #ontinue
 #ode = node.text
 #lif isinstance(node, parsetree.Code):
 #n_translator_comments = False
 #ode = node.code.code
 #lif isinstance(node, parsetree.Expression):
 #ode = node.code.code
 #lse:
 #ontinue

            # Comments don't apply unless they immediately precede the message
 #f (
 #ranslator_comments
 #nd translator_comments[-1][0] < node.lineno - 1
 #:
 #ranslator_comments = []

 #ranslator_strings = [
 #omment[1] for comment in translator_comments
 #

 #f isinstance(code, str) and self.use_bytes:
 #ode = code.encode(input_encoding, "backslashreplace")

 #sed_translator_comments = False
            # We add extra newline to work around a pybabel bug
            # (see python-babel/babel#274, parse_encoding dies if the first
            # input string of the input is non-ascii)
            # Also, because we added it, we have to subtract one from
            # node.lineno
 #f self.use_bytes:
 #ode = BytesIO(b"\n" + code)
 #lse:
 #ode = StringIO("\n" + code)

 #or message in self.process_python(
 #ode, node.lineno - 1, translator_strings
 #:
 #ield message
 #sed_translator_comments = True

 #f used_translator_comments:
 #ranslator_comments = []
 #n_translator_comments = False

 #f child_nodes:
 #ield from self.extract_nodes(child_nodes)

 #staticmethod
 #ef _split_comment(lineno, comment):
 #""Return the multiline comment at lineno split into a list of
 #omment line numbers and the accompanying comment line"""
 #eturn [
 #lineno + index, line)
 #or index, line in enumerate(comment.splitlines())
 #
