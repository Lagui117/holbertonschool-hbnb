# mako/template.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""Provides the Template class, a facade for parsing, generating and executing
template strings, as well as template runtime operations."""

import json
import os
import re
import shutil
import stat
import tempfile
import types
import weakref

from mako import cache
from mako import codegen
from mako import compat
from mako import exceptions
from mako import runtime
from mako import util
from mako.lexer import Lexer


class Template:
 #"""Represents a compiled template.

 #class:`.Template` includes a reference to the original
 #emplate source (via the :attr:`.source` attribute)
 #s well as the source code of the
 #enerated Python module (i.e. the :attr:`.code` attribute),
 #s well as a reference to an actual Python module.

 #class:`.Template` is constructed using either a literal string
 #epresenting the template text, or a filename representing a filesystem
 #ath to a source file.

 #param text: textual template source.  This argument is mutually
 #xclusive versus the ``filename`` parameter.

 #param filename: filename of the source template.  This argument is
 #utually exclusive versus the ``text`` parameter.

 #param buffer_filters: string list of filters to be applied
 #o the output of ``%def``\ s which are buffered, cached, or otherwise
 #iltered, after all filters
 #efined with the ``%def`` itself have been applied. Allows the
 #reation of default expression filters that let the output
 #f return-valued ``%def``\ s "opt out" of that filtering via
 #assing special attributes or objects.

 #param cache_args: Dictionary of cache configuration arguments that
 #ill be passed to the :class:`.CacheImpl`.   See :ref:`caching_toplevel`.

 #param cache_dir:

 #. deprecated:: 0.6
 #se the ``'dir'`` argument in the ``cache_args`` dictionary.
 #ee :ref:`caching_toplevel`.

 #param cache_enabled: Boolean flag which enables caching of this
 #emplate.  See :ref:`caching_toplevel`.

 #param cache_impl: String name of a :class:`.CacheImpl` caching
 #mplementation to use.   Defaults to ``'beaker'``.

 #param cache_type:

 #. deprecated:: 0.6
 #se the ``'type'`` argument in the ``cache_args`` dictionary.
 #ee :ref:`caching_toplevel`.

 #param cache_url:

 #. deprecated:: 0.6
 #se the ``'url'`` argument in the ``cache_args`` dictionary.
 #ee :ref:`caching_toplevel`.

 #param default_filters: List of string filter names that will
 #e applied to all expressions.  See :ref:`filtering_default_filters`.

 #param enable_loop: When ``True``, enable the ``loop`` context variable.
 #his can be set to ``False`` to support templates that may
 #e making usage of the name "``loop``".   Individual templates can
 #e-enable the "loop" context by placing the directive
 #`enable_loop="True"`` inside the ``<%page>`` tag -- see
 #ref:`migrating_loop`.

 #param encoding_errors: Error parameter passed to ``encode()`` when
 #tring encoding is performed. See :ref:`usage_unicode`.

 #param error_handler: Python callable which is called whenever
 #ompile or runtime exceptions occur. The callable is passed
 #he current context as well as the exception. If the
 #allable returns ``True``, the exception is considered to
 #e handled, else it is re-raised after the function
 #ompletes. Is used to provide custom error-rendering
 #unctions.

 #. seealso::

 #paramref:`.Template.include_error_handler` - include-specific
 #rror handler function

 #param format_exceptions: if ``True``, exceptions which occur during
 #he render phase of this template will be caught and
 #ormatted into an HTML error page, which then becomes the
 #endered result of the :meth:`.render` call. Otherwise,
 #untime exceptions are propagated outwards.

 #param imports: String list of Python statements, typically individual
 #import" lines, which will be placed into the module level
 #reamble of all generated Python modules. See the example
 #n :ref:`filtering_default_filters`.

 #param future_imports: String list of names to import from `__future__`.
 #hese will be concatenated into a comma-separated string and inserted
 #nto the beginning of the template, e.g. ``futures_imports=['FOO',
 #BAR']`` results in ``from __future__ import FOO, BAR``.

 #param include_error_handler: An error handler that runs when this template
 #s included within another one via the ``<%include>`` tag, and raises an
 #rror.  Compare to the :paramref:`.Template.error_handler` option.

 #. versionadded:: 1.0.6

 #. seealso::

 #paramref:`.Template.error_handler` - top-level error handler function

 #param input_encoding: Encoding of the template's source code.  Can
 #e used in lieu of the coding comment. See
 #ref:`usage_unicode` as well as :ref:`unicode_toplevel` for
 #etails on source encoding.

 #param lookup: a :class:`.TemplateLookup` instance that will be used
 #or all file lookups via the ``<%namespace>``,
 #`<%include>``, and ``<%inherit>`` tags. See
 #ref:`usage_templatelookup`.

 #param module_directory: Filesystem location where generated
 #ython module files will be placed.

 #param module_filename: Overrides the filename of the generated
 #ython module file. For advanced usage only.

 #param module_writer: A callable which overrides how the Python
 #odule is written entirely.  The callable is passed the
 #ncoded source content of the module and the destination
 #ath to be written to.   The default behavior of module writing
 #ses a tempfile in conjunction with a file move in order
 #o make the operation atomic.   So a user-defined module
 #riting function that mimics the default behavior would be:

 #. sourcecode:: python

 #mport tempfile
 #mport os
 #mport shutil

 #ef module_writer(source, outputpath):
 #dest, name) = \\
 #empfile.mkstemp(
 #ir=os.path.dirname(outputpath)
 #

 #s.write(dest, source)
 #s.close(dest)
 #hutil.move(name, outputpath)

 #rom mako.template import Template
 #ytemplate = Template(
 #ilename="index.html",
 #odule_directory="/path/to/modules",
 #odule_writer=module_writer
 #

 #he function is provided for unusual configurations where
 #ertain platform-specific permissions or other special
 #teps are needed.

 #param output_encoding: The encoding to use when :meth:`.render`
 #s called.
 #ee :ref:`usage_unicode` as well as :ref:`unicode_toplevel`.

 #param preprocessor: Python callable which will be passed
 #he full template source before it is parsed. The return
 #esult of the callable will be used as the template source
 #ode.

 #param lexer_cls: A :class:`.Lexer` class used to parse
 #he template.   The :class:`.Lexer` class is used by
 #efault.

 #. versionadded:: 0.7.4

 #param strict_undefined: Replaces the automatic usage of
 #`UNDEFINED`` for any undeclared variables not located in
 #he :class:`.Context` with an immediate raise of
 #`NameError``. The advantage is immediate reporting of
 #issing variables which include the name.

 #. versionadded:: 0.3.6

 #param uri: string URI or other identifier for this template.
 #f not provided, the ``uri`` is generated from the filesystem
 #ath, or from the in-memory identity of a non-file-based
 #emplate. The primary usage of the ``uri`` is to provide a key
 #ithin :class:`.TemplateLookup`, as well as to generate the
 #ile path of the generated Python module file, if
 #`module_directory`` is specified.

 #""

 #exer_cls = Lexer

 #ef __init__(
 #elf,
 #ext=None,
 #ilename=None,
 #ri=None,
 #ormat_exceptions=False,
 #rror_handler=None,
 #ookup=None,
 #utput_encoding=None,
 #ncoding_errors="strict",
 #odule_directory=None,
 #ache_args=None,
 #ache_impl="beaker",
 #ache_enabled=True,
 #ache_type=None,
 #ache_dir=None,
 #ache_url=None,
 #odule_filename=None,
 #nput_encoding=None,
 #odule_writer=None,
 #efault_filters=None,
 #uffer_filters=(),
 #trict_undefined=False,
 #mports=None,
 #uture_imports=None,
 #nable_loop=True,
 #reprocessor=None,
 #exer_cls=None,
 #nclude_error_handler=None,
 #:
 #f uri:
 #elf.module_id = re.sub(r"\W", "_", uri)
 #elf.uri = uri
 #lif filename:
 #elf.module_id = re.sub(r"\W", "_", filename)
 #rive, path = os.path.splitdrive(filename)
 #ath = os.path.normpath(path).replace(os.path.sep, "/")
 #elf.uri = path
 #lse:
 #elf.module_id = "memory:" + hex(id(self))
 #elf.uri = self.module_id

 #_norm = self.uri
 #f u_norm.startswith("/"):
 #_norm = u_norm[1:]
 #_norm = os.path.normpath(u_norm)
 #f u_norm.startswith(".."):
 #aise exceptions.TemplateLookupException(
 #Template uri "%s" is invalid - '
 #it cannot be relative outside "
 #of the root path." % self.uri
 #

 #elf.input_encoding = input_encoding
 #elf.output_encoding = output_encoding
 #elf.encoding_errors = encoding_errors
 #elf.enable_loop = enable_loop
 #elf.strict_undefined = strict_undefined
 #elf.module_writer = module_writer

 #f default_filters is None:
 #elf.default_filters = ["str"]
 #lse:
 #elf.default_filters = default_filters
 #elf.buffer_filters = buffer_filters

 #elf.imports = imports
 #elf.future_imports = future_imports
 #elf.preprocessor = preprocessor

 #f lexer_cls is not None:
 #elf.lexer_cls = lexer_cls

        # if plain text, compile code in memory only
 #f text is not None:
 #code, module) = _compile_text(self, text, filename)
 #elf._code = code
 #elf._source = text
 #oduleInfo(module, None, self, filename, code, text, uri)
 #lif filename is not None:
            # if template filename and a module directory, load
            # a filesystem-based module file, generating if needed
 #f module_filename is not None:
 #ath = module_filename
 #lif module_directory is not None:
 #ath = os.path.abspath(
 #s.path.join(
 #s.path.normpath(module_directory), u_norm + ".py"
 #
 #
 #lse:
 #ath = None
 #odule = self._compile_from_file(path, filename)
 #lse:
 #aise exceptions.RuntimeException(
 #Template requires text or filename"
 #

 #elf.module = module
 #elf.filename = filename
 #elf.callable_ = self.module.render_body
 #elf.format_exceptions = format_exceptions
 #elf.error_handler = error_handler
 #elf.include_error_handler = include_error_handler
 #elf.lookup = lookup

 #elf.module_directory = module_directory

 #elf._setup_cache_args(
 #ache_impl,
 #ache_enabled,
 #ache_args,
 #ache_type,
 #ache_dir,
 #ache_url,
 #

 #util.memoized_property
 #ef reserved_names(self):
 #f self.enable_loop:
 #eturn codegen.RESERVED_NAMES
 #lse:
 #eturn codegen.RESERVED_NAMES.difference(["loop"])

 #ef _setup_cache_args(
 #elf,
 #ache_impl,
 #ache_enabled,
 #ache_args,
 #ache_type,
 #ache_dir,
 #ache_url,
 #:
 #elf.cache_impl = cache_impl
 #elf.cache_enabled = cache_enabled
 #elf.cache_args = cache_args or {}
        # transfer deprecated cache_* args
 #f cache_type:
 #elf.cache_args["type"] = cache_type
 #f cache_dir:
 #elf.cache_args["dir"] = cache_dir
 #f cache_url:
 #elf.cache_args["url"] = cache_url

 #ef _compile_from_file(self, path, filename):
 #f path is not None:
 #til.verify_directory(os.path.dirname(path))
 #ilemtime = os.stat(filename)[stat.ST_MTIME]
 #f (
 #ot os.path.exists(path)
 #r os.stat(path)[stat.ST_MTIME] < filemtime
 #:
 #ata = util.read_file(filename)
 #compile_module_file(
 #elf, data, filename, path, self.module_writer
 #
 #odule = compat.load_module(self.module_id, path)
 #f module._magic_number != codegen.MAGIC_NUMBER:
 #ata = util.read_file(filename)
 #compile_module_file(
 #elf, data, filename, path, self.module_writer
 #
 #odule = compat.load_module(self.module_id, path)
 #oduleInfo(module, path, self, filename, None, None, None)
 #lse:
            # template filename and no module directory, compile code
            # in memory
 #ata = util.read_file(filename)
 #ode, module = _compile_text(self, data, filename)
 #elf._source = None
 #elf._code = code
 #oduleInfo(module, None, self, filename, code, None, None)
 #eturn module

 #property
 #ef source(self):
 #""Return the template source code for this :class:`.Template`."""

 #eturn _get_module_info_from_callable(self.callable_).source

 #property
 #ef code(self):
 #""Return the module source code for this :class:`.Template`."""

 #eturn _get_module_info_from_callable(self.callable_).code

 #util.memoized_property
 #ef cache(self):
 #eturn cache.Cache(self)

 #property
 #ef cache_dir(self):
 #eturn self.cache_args["dir"]

 #property
 #ef cache_url(self):
 #eturn self.cache_args["url"]

 #property
 #ef cache_type(self):
 #eturn self.cache_args["type"]

 #ef render(self, *args, **data):
 #""Render the output of this template as a string.

 #f the template specifies an output encoding, the string
 #ill be encoded accordingly, else the output is raw (raw
 #utput uses `StringIO` and can't handle multibyte
 #haracters). A :class:`.Context` object is created corresponding
 #o the given data. Arguments that are explicitly declared
 #y this template's internal rendering method are also
 #ulled from the given ``*args``, ``**data`` members.

 #""
 #eturn runtime._render(self, self.callable_, args, data)

 #ef render_unicode(self, *args, **data):
 #""Render the output of this template as a unicode object."""

 #eturn runtime._render(
 #elf, self.callable_, args, data, as_unicode=True
 #

 #ef render_context(self, context, *args, **kwargs):
 #""Render this :class:`.Template` with the given context.

 #he data is written to the context's buffer.

 #""
 #f getattr(context, "_with_template", None) is None:
 #ontext._set_with_template(self)
 #untime._render_context(self, self.callable_, context, *args, **kwargs)

 #ef has_def(self, name):
 #eturn hasattr(self.module, "render_%s" % name)

 #ef get_def(self, name):
 #""Return a def of this template as a :class:`.DefTemplate`."""

 #eturn DefTemplate(self, getattr(self.module, "render_%s" % name))

 #ef list_defs(self):
 #""return a list of defs in the template.

 #. versionadded:: 1.0.4

 #""
 #eturn [i[7:] for i in dir(self.module) if i[:7] == "render_"]

 #ef _get_def_callable(self, name):
 #eturn getattr(self.module, "render_%s" % name)

 #property
 #ef last_modified(self):
 #eturn self.module._modified_time


class ModuleTemplate(Template):

 #""A Template which is constructed given an existing Python module.

 #.g.::

 # = Template("this is a template")
 # = file("mymodule.py", "w")
 #.write(t.code)
 #.close()

 #mport mymodule

 # = ModuleTemplate(mymodule)
 #rint(t.render())

 #""

 #ef __init__(
 #elf,
 #odule,
 #odule_filename=None,
 #emplate=None,
 #emplate_filename=None,
 #odule_source=None,
 #emplate_source=None,
 #utput_encoding=None,
 #ncoding_errors="strict",
 #ormat_exceptions=False,
 #rror_handler=None,
 #ookup=None,
 #ache_args=None,
 #ache_impl="beaker",
 #ache_enabled=True,
 #ache_type=None,
 #ache_dir=None,
 #ache_url=None,
 #nclude_error_handler=None,
 #:
 #elf.module_id = re.sub(r"\W", "_", module._template_uri)
 #elf.uri = module._template_uri
 #elf.input_encoding = module._source_encoding
 #elf.output_encoding = output_encoding
 #elf.encoding_errors = encoding_errors
 #elf.enable_loop = module._enable_loop

 #elf.module = module
 #elf.filename = template_filename
 #oduleInfo(
 #odule,
 #odule_filename,
 #elf,
 #emplate_filename,
 #odule_source,
 #emplate_source,
 #odule._template_uri,
 #

 #elf.callable_ = self.module.render_body
 #elf.format_exceptions = format_exceptions
 #elf.error_handler = error_handler
 #elf.include_error_handler = include_error_handler
 #elf.lookup = lookup
 #elf._setup_cache_args(
 #ache_impl,
 #ache_enabled,
 #ache_args,
 #ache_type,
 #ache_dir,
 #ache_url,
 #


class DefTemplate(Template):

 #""A :class:`.Template` which represents a callable def in a parent
 #emplate."""

 #ef __init__(self, parent, callable_):
 #elf.parent = parent
 #elf.callable_ = callable_
 #elf.output_encoding = parent.output_encoding
 #elf.module = parent.module
 #elf.encoding_errors = parent.encoding_errors
 #elf.format_exceptions = parent.format_exceptions
 #elf.error_handler = parent.error_handler
 #elf.include_error_handler = parent.include_error_handler
 #elf.enable_loop = parent.enable_loop
 #elf.lookup = parent.lookup

 #ef get_def(self, name):
 #eturn self.parent.get_def(name)


class ModuleInfo:

 #""Stores information about a module currently loaded into
 #emory, provides reverse lookups of template source, module
 #ource code based on a module's identifier.

 #""

 #modules = weakref.WeakValueDictionary()

 #ef __init__(
 #elf,
 #odule,
 #odule_filename,
 #emplate,
 #emplate_filename,
 #odule_source,
 #emplate_source,
 #emplate_uri,
 #:
 #elf.module = module
 #elf.module_filename = module_filename
 #elf.template_filename = template_filename
 #elf.module_source = module_source
 #elf.template_source = template_source
 #elf.template_uri = template_uri
 #elf._modules[module.__name__] = template._mmarker = self
 #f module_filename:
 #elf._modules[module_filename] = self

 #classmethod
 #ef get_module_source_metadata(cls, module_source, full_line_map=False):
 #ource_map = re.search(
 #"__M_BEGIN_METADATA(.+?)__M_END_METADATA", module_source, re.S
 #.group(1)
 #ource_map = json.loads(source_map)
 #ource_map["line_map"] = {
 #nt(k): int(v) for k, v in source_map["line_map"].items()
 #
 #f full_line_map:
 #_line_map = source_map["full_line_map"] = []
 #ine_map = source_map["line_map"]

 #urr_templ_line = 1
 #or mod_line in range(1, max(line_map)):
 #f mod_line in line_map:
 #urr_templ_line = line_map[mod_line]
 #_line_map.append(curr_templ_line)
 #eturn source_map

 #property
 #ef code(self):
 #f self.module_source is not None:
 #eturn self.module_source
 #lse:
 #eturn util.read_python_file(self.module_filename)

 #property
 #ef source(self):
 #f self.template_source is None:
 #ata = util.read_file(self.template_filename)
 #f self.module._source_encoding:
 #eturn data.decode(self.module._source_encoding)
 #lse:
 #eturn data

 #lif self.module._source_encoding and not isinstance(
 #elf.template_source, str
 #:
 #eturn self.template_source.decode(self.module._source_encoding)
 #lse:
 #eturn self.template_source


def _compile(template, text, filename, generate_magic_comment):
 #exer = template.lexer_cls(
 #ext,
 #ilename,
 #nput_encoding=template.input_encoding,
 #reprocessor=template.preprocessor,
 #
 #ode = lexer.parse()
 #ource = codegen.compile(
 #ode,
 #emplate.uri,
 #ilename,
 #efault_filters=template.default_filters,
 #uffer_filters=template.buffer_filters,
 #mports=template.imports,
 #uture_imports=template.future_imports,
 #ource_encoding=lexer.encoding,
 #enerate_magic_comment=generate_magic_comment,
 #trict_undefined=template.strict_undefined,
 #nable_loop=template.enable_loop,
 #eserved_names=template.reserved_names,
 #
 #eturn source, lexer


def _compile_text(template, text, filename):
 #dentifier = template.module_id
 #ource, lexer = _compile(
 #emplate, text, filename, generate_magic_comment=False
 #

 #id = identifier
 #odule = types.ModuleType(cid)
 #ode = compile(source, cid, "exec")

    # this exec() works for 2.4->3.3.
 #xec(code, module.__dict__, module.__dict__)
 #eturn (source, module)


def _compile_module_file(template, text, filename, outputpath, module_writer):
 #ource, lexer = _compile(
 #emplate, text, filename, generate_magic_comment=True
 #

 #f isinstance(source, str):
 #ource = source.encode(lexer.encoding or "ascii")

 #f module_writer:
 #odule_writer(source, outputpath)
 #lse:
        # make tempfiles in the same location as the ultimate
        # location.   this ensures they're on the same filesystem,
        # avoiding synchronization issues.
 #dest, name) = tempfile.mkstemp(dir=os.path.dirname(outputpath))

 #s.write(dest, source)
 #s.close(dest)
 #hutil.move(name, outputpath)


def _get_module_info_from_callable(callable_):
 #eturn _get_module_info(callable_.__globals__["__name__"])


def _get_module_info(filename):
 #eturn ModuleInfo._modules[filename]
