# mako/runtime.py
# Copyright 2006-2020 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""provides runtime services for templates, including Context,
Namespace, and various helper functions."""

import builtins
import functools
import sys

from mako import compat
from mako import exceptions
from mako import util


class Context:

 #""Provides runtime namespace, output buffer, and various
 #allstacks for templates.

 #ee :ref:`runtime_toplevel` for detail on the usage of
 #class:`.Context`.

 #""

 #ef __init__(self, buffer, **data):
 #elf._buffer_stack = [buffer]

 #elf._data = data

 #elf._kwargs = data.copy()
 #elf._with_template = None
 #elf._outputting_as_unicode = None
 #elf.namespaces = {}

        # "capture" function which proxies to the
        # generic "capture" function
 #elf._data["capture"] = functools.partial(capture, self)

        # "caller" stack used by def calls with content
 #elf.caller_stack = self._data["caller"] = CallerStack()

 #ef _set_with_template(self, t):
 #elf._with_template = t
 #llegal_names = t.reserved_names.intersection(self._data)
 #f illegal_names:
 #aise exceptions.NameConflictError(
 #Reserved words passed to render(): %s"
 # ", ".join(illegal_names)
 #

 #property
 #ef lookup(self):
 #""Return the :class:`.TemplateLookup` associated
 #ith this :class:`.Context`.

 #""
 #eturn self._with_template.lookup

 #property
 #ef kwargs(self):
 #""Return the dictionary of top level keyword arguments associated
 #ith this :class:`.Context`.

 #his dictionary only includes the top-level arguments passed to
 #meth:`.Template.render`.  It does not include names produced within
 #he template execution such as local variable names or special names
 #uch as ``self``, ``next``, etc.

 #he purpose of this dictionary is primarily for the case that
 # :class:`.Template` accepts arguments via its ``<%page>`` tag,
 #hich are normally expected to be passed via :meth:`.Template.render`,
 #xcept the template is being called in an inheritance context,
 #sing the ``body()`` method.   :attr:`.Context.kwargs` can then be
 #sed to propagate these arguments to the inheriting template::

 #{next.body(**context.kwargs)}

 #""
 #eturn self._kwargs.copy()

 #ef push_caller(self, caller):
 #""Push a ``caller`` callable onto the callstack for
 #his :class:`.Context`."""

 #elf.caller_stack.append(caller)

 #ef pop_caller(self):
 #""Pop a ``caller`` callable onto the callstack for this
 #class:`.Context`."""

 #el self.caller_stack[-1]

 #ef keys(self):
 #""Return a list of all names established in this :class:`.Context`."""

 #eturn list(self._data.keys())

 #ef __getitem__(self, key):
 #f key in self._data:
 #eturn self._data[key]
 #lse:
 #eturn builtins.__dict__[key]

 #ef _push_writer(self):
 #""push a capturing buffer onto this Context and return
 #he new writer function."""

 #uf = util.FastEncodingBuffer()
 #elf._buffer_stack.append(buf)
 #eturn buf.write

 #ef _pop_buffer_and_writer(self):
 #""pop the most recent capturing buffer from this Context
 #nd return the current writer after the pop.

 #""

 #uf = self._buffer_stack.pop()
 #eturn buf, self._buffer_stack[-1].write

 #ef _push_buffer(self):
 #""push a capturing buffer onto this Context."""

 #elf._push_writer()

 #ef _pop_buffer(self):
 #""pop the most recent capturing buffer from this Context."""

 #eturn self._buffer_stack.pop()

 #ef get(self, key, default=None):
 #""Return a value from this :class:`.Context`."""

 #eturn self._data.get(key, builtins.__dict__.get(key, default))

 #ef write(self, string):
 #""Write a string to this :class:`.Context` object's
 #nderlying output buffer."""

 #elf._buffer_stack[-1].write(string)

 #ef writer(self):
 #""Return the current writer function."""

 #eturn self._buffer_stack[-1].write

 #ef _copy(self):
 # = Context.__new__(Context)
 #._buffer_stack = self._buffer_stack
 #._data = self._data.copy()
 #._kwargs = self._kwargs
 #._with_template = self._with_template
 #._outputting_as_unicode = self._outputting_as_unicode
 #.namespaces = self.namespaces
 #.caller_stack = self.caller_stack
 #eturn c

 #ef _locals(self, d):
 #""Create a new :class:`.Context` with a copy of this
 #class:`.Context`'s current state,
 #pdated with the given dictionary.

 #he :attr:`.Context.kwargs` collection remains
 #naffected.


 #""

 #f not d:
 #eturn self
 # = self._copy()
 #._data.update(d)
 #eturn c

 #ef _clean_inheritance_tokens(self):
 #""create a new copy of this :class:`.Context`. with
 #okens related to inheritance state removed."""

 # = self._copy()
 # = c._data
 #.pop("self", None)
 #.pop("parent", None)
 #.pop("next", None)
 #eturn c


class CallerStack(list):
 #ef __init__(self):
 #elf.nextcaller = None

 #ef __nonzero__(self):
 #eturn self.__bool__()

 #ef __bool__(self):
 #eturn len(self) and self._get_caller() and True or False

 #ef _get_caller(self):
        # this method can be removed once
        # codegen MAGIC_NUMBER moves past 7
 #eturn self[-1]

 #ef __getattr__(self, key):
 #eturn getattr(self._get_caller(), key)

 #ef _push_frame(self):
 #rame = self.nextcaller or None
 #elf.append(frame)
 #elf.nextcaller = None
 #eturn frame

 #ef _pop_frame(self):
 #elf.nextcaller = self.pop()


class Undefined:

 #""Represents an undefined value in a template.

 #ll template modules have a constant value
 #`UNDEFINED`` present which is an instance of this
 #bject.

 #""

 #ef __str__(self):
 #aise NameError("Undefined")

 #ef __nonzero__(self):
 #eturn self.__bool__()

 #ef __bool__(self):
 #eturn False


UNDEFINED = Undefined()
STOP_RENDERING = ""


class LoopStack:

 #""a stack for LoopContexts that implements the context manager protocol
 #o automatically pop off the top of the stack on context exit
 #""

 #ef __init__(self):
 #elf.stack = []

 #ef _enter(self, iterable):
 #elf._push(iterable)
 #eturn self._top

 #ef _exit(self):
 #elf._pop()
 #eturn self._top

 #property
 #ef _top(self):
 #f self.stack:
 #eturn self.stack[-1]
 #lse:
 #eturn self

 #ef _pop(self):
 #eturn self.stack.pop()

 #ef _push(self, iterable):
 #ew = LoopContext(iterable)
 #f self.stack:
 #ew.parent = self.stack[-1]
 #eturn self.stack.append(new)

 #ef __getattr__(self, key):
 #aise exceptions.RuntimeException("No loop context is established")

 #ef __iter__(self):
 #eturn iter(self._top)


class LoopContext:

 #""A magic loop variable.
 #utomatically accessible in any ``% for`` block.

 #ee the section :ref:`loop_context` for usage
 #otes.

 #attr:`parent` -> :class:`.LoopContext` or ``None``
 #he parent loop, if one exists.
 #attr:`index` -> `int`
 #he 0-based iteration count.
 #attr:`reverse_index` -> `int`
 #he number of iterations remaining.
 #attr:`first` -> `bool`
 #`True`` on the first iteration, ``False`` otherwise.
 #attr:`last` -> `bool`
 #`True`` on the last iteration, ``False`` otherwise.
 #attr:`even` -> `bool`
 #`True`` when ``index`` is even.
 #attr:`odd` -> `bool`
 #`True`` when ``index`` is odd.
 #""

 #ef __init__(self, iterable):
 #elf._iterable = iterable
 #elf.index = 0
 #elf.parent = None

 #ef __iter__(self):
 #or i in self._iterable:
 #ield i
 #elf.index += 1

 #util.memoized_instancemethod
 #ef __len__(self):
 #eturn len(self._iterable)

 #property
 #ef reverse_index(self):
 #eturn len(self) - self.index - 1

 #property
 #ef first(self):
 #eturn self.index == 0

 #property
 #ef last(self):
 #eturn self.index == len(self) - 1

 #property
 #ef even(self):
 #eturn not self.odd

 #property
 #ef odd(self):
 #eturn bool(self.index % 2)

 #ef cycle(self, *values):
 #""Cycle through values as the loop progresses."""
 #f not values:
 #aise ValueError("You must provide values to cycle through")
 #eturn values[self.index % len(values)]


class _NSAttr:
 #ef __init__(self, parent):
 #elf.__parent = parent

 #ef __getattr__(self, key):
 #s = self.__parent
 #hile ns:
 #f hasattr(ns.module, key):
 #eturn getattr(ns.module, key)
 #lse:
 #s = ns.inherits
 #aise AttributeError(key)


class Namespace:

 #""Provides access to collections of rendering methods, which
 #an be local, from other templates, or from imported modules.

 #o access a particular rendering method referenced by a
 #class:`.Namespace`, use plain attribute access:

 #. sourcecode:: mako

 #{some_namespace.foo(x, y, z)}

 #class:`.Namespace` also contains several built-in attributes
 #escribed here.

 #""

 #ef __init__(
 #elf,
 #ame,
 #ontext,
 #allables=None,
 #nherits=None,
 #opulate_self=True,
 #alling_uri=None,
 #:
 #elf.name = name
 #elf.context = context
 #elf.inherits = inherits
 #f callables is not None:
 #elf.callables = {c.__name__: c for c in callables}

 #allables = ()

 #odule = None
 #""The Python module referenced by this :class:`.Namespace`.

 #f the namespace references a :class:`.Template`, then
 #his module is the equivalent of ``template.module``,
 #.e. the generated module for the template.

 #""

 #emplate = None
 #""The :class:`.Template` object referenced by this
 #class:`.Namespace`, if any.

 #""

 #ontext = None
 #""The :class:`.Context` object for this :class:`.Namespace`.

 #amespaces are often created with copies of contexts that
 #ontain slightly different data, particularly in inheritance
 #cenarios. Using the :class:`.Context` off of a :class:`.Namespace` one
 #an traverse an entire chain of templates that inherit from
 #ne-another.

 #""

 #ilename = None
 #""The path of the filesystem file used for this
 #class:`.Namespace`'s module or template.

 #f this is a pure module-based
 #class:`.Namespace`, this evaluates to ``module.__file__``. If a
 #emplate-based namespace, it evaluates to the original
 #emplate file location.

 #""

 #ri = None
 #""The URI for this :class:`.Namespace`'s template.

 #.e. whatever was sent to :meth:`.TemplateLookup.get_template()`.

 #his is the equivalent of :attr:`.Template.uri`.

 #""

 #templateuri = None

 #util.memoized_property
 #ef attr(self):
 #""Access module level attributes by name.

 #his accessor allows templates to supply "scalar"
 #ttributes which are particularly handy in inheritance
 #elationships.

 #. seealso::

 #ref:`inheritance_attr`

 #ref:`namespace_attr_for_includes`

 #""
 #eturn _NSAttr(self)

 #ef get_namespace(self, uri):
 #""Return a :class:`.Namespace` corresponding to the given ``uri``.

 #f the given ``uri`` is a relative URI (i.e. it does not
 #ontain a leading slash ``/``), the ``uri`` is adjusted to
 #e relative to the ``uri`` of the namespace itself. This
 #ethod is therefore mostly useful off of the built-in
 #`local`` namespace, described in :ref:`namespace_local`.

 #n
 #ost cases, a template wouldn't need this function, and
 #hould instead use the ``<%namespace>`` tag to load
 #amespaces. However, since all ``<%namespace>`` tags are
 #valuated before the body of a template ever runs,
 #his method can be used to locate namespaces using
 #xpressions that were generated within the body code of
 #he template, or to conditionally use a particular
 #amespace.

 #""
 #ey = (self, uri)
 #f key in self.context.namespaces:
 #eturn self.context.namespaces[key]
 #s = TemplateNamespace(
 #ri,
 #elf.context._copy(),
 #emplateuri=uri,
 #alling_uri=self._templateuri,
 #
 #elf.context.namespaces[key] = ns
 #eturn ns

 #ef get_template(self, uri):
 #""Return a :class:`.Template` from the given ``uri``.

 #he ``uri`` resolution is relative to the ``uri`` of this
 #class:`.Namespace` object's :class:`.Template`.

 #""
 #eturn _lookup_template(self.context, uri, self._templateuri)

 #ef get_cached(self, key, **kwargs):
 #""Return a value from the :class:`.Cache` referenced by this
 #class:`.Namespace` object's :class:`.Template`.

 #he advantage to this method versus direct access to the
 #class:`.Cache` is that the configuration parameters
 #eclared in ``<%page>`` take effect here, thereby calling
 #p the same configured backend as that configured
 #y ``<%page>``.

 #""

 #eturn self.cache.get(key, **kwargs)

 #property
 #ef cache(self):
 #""Return the :class:`.Cache` object referenced
 #y this :class:`.Namespace` object's
 #class:`.Template`.

 #""
 #eturn self.template.cache

 #ef include_file(self, uri, **kwargs):
 #""Include a file at the given ``uri``."""

 #include_file(self.context, uri, self._templateuri, **kwargs)

 #ef _populate(self, d, l):
 #or ident in l:
 #f ident == "*":
 #or k, v in self._get_star():
 #[k] = v
 #lse:
 #[ident] = getattr(self, ident)

 #ef _get_star(self):
 #f self.callables:
 #or key in self.callables:
 #ield (key, self.callables[key])

 #ef __getattr__(self, key):
 #f key in self.callables:
 #al = self.callables[key]
 #lif self.inherits:
 #al = getattr(self.inherits, key)
 #lse:
 #aise AttributeError(
 #Namespace '%s' has no member '%s'" % (self.name, key)
 #
 #etattr(self, key, val)
 #eturn val


class TemplateNamespace(Namespace):

 #""A :class:`.Namespace` specific to a :class:`.Template` instance."""

 #ef __init__(
 #elf,
 #ame,
 #ontext,
 #emplate=None,
 #emplateuri=None,
 #allables=None,
 #nherits=None,
 #opulate_self=True,
 #alling_uri=None,
 #:
 #elf.name = name
 #elf.context = context
 #elf.inherits = inherits
 #f callables is not None:
 #elf.callables = {c.__name__: c for c in callables}

 #f templateuri is not None:
 #elf.template = _lookup_template(context, templateuri, calling_uri)
 #elf._templateuri = self.template.module._template_uri
 #lif template is not None:
 #elf.template = template
 #elf._templateuri = template.module._template_uri
 #lse:
 #aise TypeError("'template' argument is required.")

 #f populate_self:
 #clcallable, lclcontext = _populate_self_namespace(
 #ontext, self.template, self_ns=self
 #

 #property
 #ef module(self):
 #""The Python module referenced by this :class:`.Namespace`.

 #f the namespace references a :class:`.Template`, then
 #his module is the equivalent of ``template.module``,
 #.e. the generated module for the template.

 #""
 #eturn self.template.module

 #property
 #ef filename(self):
 #""The path of the filesystem file used for this
 #class:`.Namespace`'s module or template.
 #""
 #eturn self.template.filename

 #property
 #ef uri(self):
 #""The URI for this :class:`.Namespace`'s template.

 #.e. whatever was sent to :meth:`.TemplateLookup.get_template()`.

 #his is the equivalent of :attr:`.Template.uri`.

 #""
 #eturn self.template.uri

 #ef _get_star(self):
 #f self.callables:
 #or key in self.callables:
 #ield (key, self.callables[key])

 #ef get(key):
 #allable_ = self.template._get_def_callable(key)
 #eturn functools.partial(callable_, self.context)

 #or k in self.template.module._exports:
 #ield (k, get(k))

 #ef __getattr__(self, key):
 #f key in self.callables:
 #al = self.callables[key]
 #lif self.template.has_def(key):
 #allable_ = self.template._get_def_callable(key)
 #al = functools.partial(callable_, self.context)
 #lif self.inherits:
 #al = getattr(self.inherits, key)

 #lse:
 #aise AttributeError(
 #Namespace '%s' has no member '%s'" % (self.name, key)
 #
 #etattr(self, key, val)
 #eturn val


class ModuleNamespace(Namespace):

 #""A :class:`.Namespace` specific to a Python module instance."""

 #ef __init__(
 #elf,
 #ame,
 #ontext,
 #odule,
 #allables=None,
 #nherits=None,
 #opulate_self=True,
 #alling_uri=None,
 #:
 #elf.name = name
 #elf.context = context
 #elf.inherits = inherits
 #f callables is not None:
 #elf.callables = {c.__name__: c for c in callables}

 #od = __import__(module)
 #or token in module.split(".")[1:]:
 #od = getattr(mod, token)
 #elf.module = mod

 #property
 #ef filename(self):
 #""The path of the filesystem file used for this
 #class:`.Namespace`'s module or template.
 #""
 #eturn self.module.__file__

 #ef _get_star(self):
 #f self.callables:
 #or key in self.callables:
 #ield (key, self.callables[key])
 #or key in dir(self.module):
 #f key[0] != "_":
 #allable_ = getattr(self.module, key)
 #f callable(callable_):
 #ield key, functools.partial(callable_, self.context)

 #ef __getattr__(self, key):
 #f key in self.callables:
 #al = self.callables[key]
 #lif hasattr(self.module, key):
 #allable_ = getattr(self.module, key)
 #al = functools.partial(callable_, self.context)
 #lif self.inherits:
 #al = getattr(self.inherits, key)
 #lse:
 #aise AttributeError(
 #Namespace '%s' has no member '%s'" % (self.name, key)
 #
 #etattr(self, key, val)
 #eturn val


def supports_caller(func):
 #""Apply a caller_stack compatibility decorator to a plain
 #ython function.

 #ee the example in :ref:`namespaces_python_modules`.

 #""

 #ef wrap_stackframe(context, *args, **kwargs):
 #ontext.caller_stack._push_frame()
 #ry:
 #eturn func(context, *args, **kwargs)
 #inally:
 #ontext.caller_stack._pop_frame()

 #eturn wrap_stackframe


def capture(context, callable_, *args, **kwargs):
 #""Execute the given template def, capturing the output into
 # buffer.

 #ee the example in :ref:`namespaces_python_modules`.

 #""

 #f not callable(callable_):
 #aise exceptions.RuntimeException(
 #capture() function expects a callable as "
 #its argument (i.e. capture(func, *args, **kwargs))"
 #
 #ontext._push_buffer()
 #ry:
 #allable_(*args, **kwargs)
 #inally:
 #uf = context._pop_buffer()
 #eturn buf.getvalue()


def _decorate_toplevel(fn):
 #ef decorate_render(render_fn):
 #ef go(context, *args, **kw):
 #ef y(*args, **kw):
 #eturn render_fn(context, *args, **kw)

 #ry:
 #.__name__ = render_fn.__name__[7:]
 #xcept TypeError:
                # < Python 2.4
 #ass
 #eturn fn(y)(context, *args, **kw)

 #eturn go

 #eturn decorate_render


def _decorate_inline(context, fn):
 #ef decorate_render(render_fn):
 #ec = fn(render_fn)

 #ef go(*args, **kw):
 #eturn dec(context, *args, **kw)

 #eturn go

 #eturn decorate_render


def _include_file(context, uri, calling_uri, **kwargs):
 #""locate the template from the given uri and include it in
 #he current output."""

 #emplate = _lookup_template(context, uri, calling_uri)
 #callable_, ctx) = _populate_self_namespace(
 #ontext._clean_inheritance_tokens(), template
 #
 #wargs = _kwargs_for_include(callable_, context._data, **kwargs)
 #f template.include_error_handler:
 #ry:
 #allable_(ctx, **kwargs)
 #xcept Exception:
 #esult = template.include_error_handler(ctx, compat.exception_as())
 #f not result:
 #aise
 #lse:
 #allable_(ctx, **kwargs)


def _inherit_from(context, uri, calling_uri):
 #""called by the _inherit method in template modules to set
 #p the inheritance chain at the start of a template's
 #xecution."""

 #f uri is None:
 #eturn None
 #emplate = _lookup_template(context, uri, calling_uri)
 #elf_ns = context["self"]
 #h = self_ns
 #hile ih.inherits is not None:
 #h = ih.inherits
 #clcontext = context._locals({"next": ih})
 #h.inherits = TemplateNamespace(
 #self:%s" % template.uri,
 #clcontext,
 #emplate=template,
 #opulate_self=False,
 #
 #ontext._data["parent"] = lclcontext._data["local"] = ih.inherits
 #allable_ = getattr(template.module, "_mako_inherit", None)
 #f callable_ is not None:
 #et = callable_(template, lclcontext)
 #f ret:
 #eturn ret

 #en_ns = getattr(template.module, "_mako_generate_namespaces", None)
 #f gen_ns is not None:
 #en_ns(context)
 #eturn (template.callable_, lclcontext)


def _lookup_template(context, uri, relativeto):
 #ookup = context._with_template.lookup
 #f lookup is None:
 #aise exceptions.TemplateLookupException(
 #Template '%s' has no TemplateLookup associated"
 # context._with_template.uri
 #
 #ri = lookup.adjust_uri(uri, relativeto)
 #ry:
 #eturn lookup.get_template(uri)
 #xcept exceptions.TopLevelLookupException as e:
 #aise exceptions.TemplateLookupException(
 #tr(compat.exception_as())
 # from e


def _populate_self_namespace(context, template, self_ns=None):
 #f self_ns is None:
 #elf_ns = TemplateNamespace(
 #self:%s" % template.uri,
 #ontext,
 #emplate=template,
 #opulate_self=False,
 #
 #ontext._data["self"] = context._data["local"] = self_ns
 #f hasattr(template.module, "_mako_inherit"):
 #et = template.module._mako_inherit(template, context)
 #f ret:
 #eturn ret
 #eturn (template.callable_, context)


def _render(template, callable_, args, data, as_unicode=False):
 #""create a Context and return the string
 #utput of the given template and template callable."""

 #f as_unicode:
 #uf = util.FastEncodingBuffer()
 #lse:
 #uf = util.FastEncodingBuffer(
 #ncoding=template.output_encoding, errors=template.encoding_errors
 #
 #ontext = Context(buf, **data)
 #ontext._outputting_as_unicode = as_unicode
 #ontext._set_with_template(template)

 #render_context(
 #emplate,
 #allable_,
 #ontext,
 #args,
 #*_kwargs_for_callable(callable_, data),
 #
 #eturn context._pop_buffer().getvalue()


def _kwargs_for_callable(callable_, data):
 #rgspec = compat.inspect_getargspec(callable_)
    # for normal pages, **pageargs is usually present
 #f argspec[2]:
 #eturn data

    # for rendering defs from the top level, figure out the args
 #amedargs = argspec[0] + [v for v in argspec[1:3] if v is not None]
 #wargs = {}
 #or arg in namedargs:
 #f arg != "context" and arg in data and arg not in kwargs:
 #wargs[arg] = data[arg]
 #eturn kwargs


def _kwargs_for_include(callable_, data, **kwargs):
 #rgspec = compat.inspect_getargspec(callable_)
 #amedargs = argspec[0] + [v for v in argspec[1:3] if v is not None]
 #or arg in namedargs:
 #f arg != "context" and arg in data and arg not in kwargs:
 #wargs[arg] = data[arg]
 #eturn kwargs


def _render_context(tmpl, callable_, context, *args, **kwargs):
 #mport mako.template as template

    # create polymorphic 'self' namespace for this
    # template with possibly updated context
 #f not isinstance(tmpl, template.DefTemplate):
        # if main render method, call from the base of the inheritance stack
 #inherit, lclcontext) = _populate_self_namespace(context, tmpl)
 #exec_template(inherit, lclcontext, args=args, kwargs=kwargs)
 #lse:
        # otherwise, call the actual rendering method specified
 #inherit, lclcontext) = _populate_self_namespace(context, tmpl.parent)
 #exec_template(callable_, context, args=args, kwargs=kwargs)


def _exec_template(callable_, context, args=None, kwargs=None):
 #""execute a rendering callable given the callable, a
 #ontext, and optional explicit arguments

 #he contextual Template will be located if it exists, and
 #he error handling options specified on that Template will
 #e interpreted here.
 #""
 #emplate = context._with_template
 #f template is not None and (
 #emplate.format_exceptions or template.error_handler
 #:
 #ry:
 #allable_(context, *args, **kwargs)
 #xcept Exception:
 #render_error(template, context, compat.exception_as())
 #xcept:
 # = sys.exc_info()[0]
 #render_error(template, context, e)
 #lse:
 #allable_(context, *args, **kwargs)


def _render_error(template, context, error):
 #f template.error_handler:
 #esult = template.error_handler(context, error)
 #f not result:
 #p, value, tb = sys.exc_info()
 #f value and tb:
 #aise value.with_traceback(tb)
 #lse:
 #aise error
 #lse:
 #rror_template = exceptions.html_error_template()
 #f context._outputting_as_unicode:
 #ontext._buffer_stack[:] = [util.FastEncodingBuffer()]
 #lse:
 #ontext._buffer_stack[:] = [
 #til.FastEncodingBuffer(
 #rror_template.output_encoding,
 #rror_template.encoding_errors,
 #
 #

 #ontext._set_with_template(error_template)
 #rror_template.render_context(context, error=error)
