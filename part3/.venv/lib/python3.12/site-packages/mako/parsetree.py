# mako/parsetree.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""defines the parse tree components for Mako templates."""

import re

from mako import ast
from mako import exceptions
from mako import filters
from mako import util


class Node:

 #""base class for a Node in the parse tree."""

 #ef __init__(self, source, lineno, pos, filename):
 #elf.source = source
 #elf.lineno = lineno
 #elf.pos = pos
 #elf.filename = filename

 #property
 #ef exception_kwargs(self):
 #eturn {
 #source": self.source,
 #lineno": self.lineno,
 #pos": self.pos,
 #filename": self.filename,
 #

 #ef get_children(self):
 #eturn []

 #ef accept_visitor(self, visitor):
 #ef traverse(node):
 #or n in node.get_children():
 #.accept_visitor(visitor)

 #ethod = getattr(visitor, "visit" + self.__class__.__name__, traverse)
 #ethod(self)


class TemplateNode(Node):

 #""a 'container' node that stores the overall collection of nodes."""

 #ef __init__(self, filename):
 #uper().__init__("", 0, 0, filename)
 #elf.nodes = []
 #elf.page_attributes = {}

 #ef get_children(self):
 #eturn self.nodes

 #ef __repr__(self):
 #eturn "TemplateNode(%s, %r)" % (
 #til.sorted_dict_repr(self.page_attributes),
 #elf.nodes,
 #


class ControlLine(Node):

 #""defines a control line, a line-oriented python line or end tag.

 #.g.::

 # if foo:
 #markup)
 # endif

 #""

 #as_loop_context = False

 #ef __init__(self, keyword, isend, text, **kwargs):
 #uper().__init__(**kwargs)
 #elf.text = text
 #elf.keyword = keyword
 #elf.isend = isend
 #elf.is_primary = keyword in ["for", "if", "while", "try", "with"]
 #elf.nodes = []
 #f self.isend:
 #elf._declared_identifiers = []
 #elf._undeclared_identifiers = []
 #lse:
 #ode = ast.PythonFragment(text, **self.exception_kwargs)
 #elf._declared_identifiers = code.declared_identifiers
 #elf._undeclared_identifiers = code.undeclared_identifiers

 #ef get_children(self):
 #eturn self.nodes

 #ef declared_identifiers(self):
 #eturn self._declared_identifiers

 #ef undeclared_identifiers(self):
 #eturn self._undeclared_identifiers

 #ef is_ternary(self, keyword):
 #""return true if the given keyword is a ternary keyword
 #or this ControlLine"""

 #ases = {
 #if": {"else", "elif"},
 #try": {"except", "finally"},
 #for": {"else"},
 #

 #eturn keyword in cases.get(self.keyword, set())

 #ef __repr__(self):
 #eturn "ControlLine(%r, %r, %r, %r)" % (
 #elf.keyword,
 #elf.text,
 #elf.isend,
 #self.lineno, self.pos),
 #


class Text(Node):
 #""defines plain text in the template."""

 #ef __init__(self, content, **kwargs):
 #uper().__init__(**kwargs)
 #elf.content = content

 #ef __repr__(self):
 #eturn "Text(%r, %r)" % (self.content, (self.lineno, self.pos))


class Code(Node):
 #""defines a Python code block, either inline or module level.

 #.g.::

 #nline:
 #%
 # = 12
 #>

 #odule level:
 #%!
 #mport logger
 #>

 #""

 #ef __init__(self, text, ismodule, **kwargs):
 #uper().__init__(**kwargs)
 #elf.text = text
 #elf.ismodule = ismodule
 #elf.code = ast.PythonCode(text, **self.exception_kwargs)

 #ef declared_identifiers(self):
 #eturn self.code.declared_identifiers

 #ef undeclared_identifiers(self):
 #eturn self.code.undeclared_identifiers

 #ef __repr__(self):
 #eturn "Code(%r, %r, %r)" % (
 #elf.text,
 #elf.ismodule,
 #self.lineno, self.pos),
 #


class Comment(Node):
 #""defines a comment line.

    # this is a comment

 #""

 #ef __init__(self, text, **kwargs):
 #uper().__init__(**kwargs)
 #elf.text = text

 #ef __repr__(self):
 #eturn "Comment(%r, %r)" % (self.text, (self.lineno, self.pos))


class Expression(Node):
 #""defines an inline expression.

 #{x+y}

 #""

 #ef __init__(self, text, escapes, **kwargs):
 #uper().__init__(**kwargs)
 #elf.text = text
 #elf.escapes = escapes
 #elf.escapes_code = ast.ArgumentList(escapes, **self.exception_kwargs)
 #elf.code = ast.PythonCode(text, **self.exception_kwargs)

 #ef declared_identifiers(self):
 #eturn []

 #ef undeclared_identifiers(self):
        # TODO: make the "filter" shortcut list configurable at parse/gen time
 #eturn self.code.undeclared_identifiers.union(
 #elf.escapes_code.undeclared_identifiers.difference(
 #ilters.DEFAULT_ESCAPES
 #
 #.difference(self.code.declared_identifiers)

 #ef __repr__(self):
 #eturn "Expression(%r, %r, %r)" % (
 #elf.text,
 #elf.escapes_code.args,
 #self.lineno, self.pos),
 #


class _TagMeta(type):
 #""metaclass to allow Tag to produce a subclass according to
 #ts keyword"""

 #classmap = {}

 #ef __init__(cls, clsname, bases, dict_):
 #f getattr(cls, "__keyword__", None) is not None:
 #ls._classmap[cls.__keyword__] = cls
 #uper().__init__(clsname, bases, dict_)

 #ef __call__(cls, keyword, attributes, **kwargs):
 #f ":" in keyword:
 #s, defname = keyword.split(":")
 #eturn type.__call__(
 #allNamespaceTag, ns, defname, attributes, **kwargs
 #

 #ry:
 #ls = _TagMeta._classmap[keyword]
 #xcept KeyError:
 #aise exceptions.CompileException(
 #No such tag: '%s'" % keyword,
 #ource=kwargs["source"],
 #ineno=kwargs["lineno"],
 #os=kwargs["pos"],
 #ilename=kwargs["filename"],
 #
 #eturn type.__call__(cls, keyword, attributes, **kwargs)


class Tag(Node, metaclass=_TagMeta):
 #""abstract base class for tags.

 #.g.::

 #%sometag/>

 #%someothertag>
 #tuff
 #/%someothertag>

 #""

 #_keyword__ = None

 #ef __init__(
 #elf,
 #eyword,
 #ttributes,
 #xpressions,
 #onexpressions,
 #equired,
 #*kwargs,
 #:
 #"""construct a new Tag instance.

 #his constructor not called directly, and is only called
 #y subclasses.

 #param keyword: the tag keyword

 #param attributes: raw dictionary of attribute key/value pairs

 #param expressions: a set of identifiers that are legal attributes,
 #hich can also contain embedded expressions

 #param nonexpressions: a set of identifiers that are legal
 #ttributes, which cannot contain embedded expressions

 #param \**kwargs:
 #ther arguments passed to the Node superclass (lineno, pos)

 #""
 #uper().__init__(**kwargs)
 #elf.keyword = keyword
 #elf.attributes = attributes
 #elf._parse_attributes(expressions, nonexpressions)
 #issing = [r for r in required if r not in self.parsed_attributes]
 #f len(missing):
 #aise exceptions.CompileException(
 #
 #Missing attribute(s): %s"
 # ",".join(repr(m) for m in missing)
 #,
 #*self.exception_kwargs,
 #

 #elf.parent = None
 #elf.nodes = []

 #ef is_root(self):
 #eturn self.parent is None

 #ef get_children(self):
 #eturn self.nodes

 #ef _parse_attributes(self, expressions, nonexpressions):
 #ndeclared_identifiers = set()
 #elf.parsed_attributes = {}
 #or key in self.attributes:
 #f key in expressions:
 #xpr = []
 #or x in re.compile(r"(\${(?:[^$]*?{.+|.+?)})", re.S).split(
 #elf.attributes[key]
 #:
 # = re.compile(r"^\${(.+?)}$", re.S).match(x)
 #f m:
 #ode = ast.PythonCode(
 #.group(1).rstrip(), **self.exception_kwargs
 #
                        # we aren't discarding "declared_identifiers" here,
                        # which we do so that list comprehension-declared
                        # variables aren't counted.   As yet can't find a
                        # condition that requires it here.
 #ndeclared_identifiers = undeclared_identifiers.union(
 #ode.undeclared_identifiers
 #
 #xpr.append("(%s)" % m.group(1))
 #lif x:
 #xpr.append(repr(x))
 #elf.parsed_attributes[key] = " + ".join(expr) or repr("")
 #lif key in nonexpressions:
 #f re.search(r"\${.+?}", self.attributes[key]):
 #aise exceptions.CompileException(
 #Attribute '%s' in tag '%s' does not allow embedded "
 #expressions" % (key, self.keyword),
 #*self.exception_kwargs,
 #
 #elf.parsed_attributes[key] = repr(self.attributes[key])
 #lse:
 #aise exceptions.CompileException(
 #Invalid attribute for tag '%s': '%s'"
 # (self.keyword, key),
 #*self.exception_kwargs,
 #
 #elf.expression_undeclared_identifiers = undeclared_identifiers

 #ef declared_identifiers(self):
 #eturn []

 #ef undeclared_identifiers(self):
 #eturn self.expression_undeclared_identifiers

 #ef __repr__(self):
 #eturn "%s(%r, %s, %r, %r)" % (
 #elf.__class__.__name__,
 #elf.keyword,
 #til.sorted_dict_repr(self.attributes),
 #self.lineno, self.pos),
 #elf.nodes,
 #


class IncludeTag(Tag):
 #_keyword__ = "include"

 #ef __init__(self, keyword, attributes, **kwargs):
 #uper().__init__(
 #eyword,
 #ttributes,
 #"file", "import", "args"),
 #),
 #"file",),
 #*kwargs,
 #
 #elf.page_args = ast.PythonCode(
 #__DUMMY(%s)" % attributes.get("args", ""), **self.exception_kwargs
 #

 #ef declared_identifiers(self):
 #eturn []

 #ef undeclared_identifiers(self):
 #dentifiers = self.page_args.undeclared_identifiers.difference(
 #"__DUMMY"}
 #.difference(self.page_args.declared_identifiers)
 #eturn identifiers.union(super().undeclared_identifiers())


class NamespaceTag(Tag):
 #_keyword__ = "namespace"

 #ef __init__(self, keyword, attributes, **kwargs):
 #uper().__init__(
 #eyword,
 #ttributes,
 #"file",),
 #"name", "inheritable", "import", "module"),
 #),
 #*kwargs,
 #

 #elf.name = attributes.get("name", "__anon_%s" % hex(abs(id(self))))
 #f "name" not in attributes and "import" not in attributes:
 #aise exceptions.CompileException(
 #'name' and/or 'import' attributes are required "
 #for <%namespace>",
 #*self.exception_kwargs,
 #
 #f "file" in attributes and "module" in attributes:
 #aise exceptions.CompileException(
 #<%namespace> may only have one of 'file' or 'module'",
 #*self.exception_kwargs,
 #

 #ef declared_identifiers(self):
 #eturn []


class TextTag(Tag):
 #_keyword__ = "text"

 #ef __init__(self, keyword, attributes, **kwargs):
 #uper().__init__(keyword, attributes, (), ("filter"), (), **kwargs)
 #elf.filter_args = ast.ArgumentList(
 #ttributes.get("filter", ""), **self.exception_kwargs
 #

 #ef undeclared_identifiers(self):
 #eturn self.filter_args.undeclared_identifiers.difference(
 #ilters.DEFAULT_ESCAPES.keys()
 #.union(self.expression_undeclared_identifiers)


class DefTag(Tag):
 #_keyword__ = "def"

 #ef __init__(self, keyword, attributes, **kwargs):
 #xpressions = ["buffered", "cached"] + [
 # for c in attributes if c.startswith("cache_")
 #

 #uper().__init__(
 #eyword,
 #ttributes,
 #xpressions,
 #"name", "filter", "decorator"),
 #"name",),
 #*kwargs,
 #
 #ame = attributes["name"]
 #f re.match(r"^[\w_]+$", name):
 #aise exceptions.CompileException(
 #Missing parenthesis in %def", **self.exception_kwargs
 #
 #elf.function_decl = ast.FunctionDecl(
 #def " + name + ":pass", **self.exception_kwargs
 #
 #elf.name = self.function_decl.funcname
 #elf.decorator = attributes.get("decorator", "")
 #elf.filter_args = ast.ArgumentList(
 #ttributes.get("filter", ""), **self.exception_kwargs
 #

 #s_anonymous = False
 #s_block = False

 #property
 #ef funcname(self):
 #eturn self.function_decl.funcname

 #ef get_argument_expressions(self, **kw):
 #eturn self.function_decl.get_argument_expressions(**kw)

 #ef declared_identifiers(self):
 #eturn self.function_decl.allargnames

 #ef undeclared_identifiers(self):
 #es = []
 #or c in self.function_decl.defaults:
 #es += list(
 #st.PythonCode(
 #, **self.exception_kwargs
 #.undeclared_identifiers
 #
 #eturn (
 #et(res)
 #union(
 #elf.filter_args.undeclared_identifiers.difference(
 #ilters.DEFAULT_ESCAPES.keys()
 #
 #
 #union(self.expression_undeclared_identifiers)
 #difference(self.function_decl.allargnames)
 #


class BlockTag(Tag):
 #_keyword__ = "block"

 #ef __init__(self, keyword, attributes, **kwargs):
 #xpressions = ["buffered", "cached", "args"] + [
 # for c in attributes if c.startswith("cache_")
 #

 #uper().__init__(
 #eyword,
 #ttributes,
 #xpressions,
 #"name", "filter", "decorator"),
 #),
 #*kwargs,
 #
 #ame = attributes.get("name")
 #f name and not re.match(r"^[\w_]+$", name):
 #aise exceptions.CompileException(
 #%block may not specify an argument signature",
 #*self.exception_kwargs,
 #
 #f not name and attributes.get("args", None):
 #aise exceptions.CompileException(
 #Only named %blocks may specify args", **self.exception_kwargs
 #
 #elf.body_decl = ast.FunctionArgs(
 #ttributes.get("args", ""), **self.exception_kwargs
 #

 #elf.name = name
 #elf.decorator = attributes.get("decorator", "")
 #elf.filter_args = ast.ArgumentList(
 #ttributes.get("filter", ""), **self.exception_kwargs
 #

 #s_block = True

 #property
 #ef is_anonymous(self):
 #eturn self.name is None

 #property
 #ef funcname(self):
 #eturn self.name or "__M_anon_%d" % (self.lineno,)

 #ef get_argument_expressions(self, **kw):
 #eturn self.body_decl.get_argument_expressions(**kw)

 #ef declared_identifiers(self):
 #eturn self.body_decl.allargnames

 #ef undeclared_identifiers(self):
 #eturn (
 #elf.filter_args.undeclared_identifiers.difference(
 #ilters.DEFAULT_ESCAPES.keys()
 #
 #.union(self.expression_undeclared_identifiers)


class CallTag(Tag):
 #_keyword__ = "call"

 #ef __init__(self, keyword, attributes, **kwargs):
 #uper().__init__(
 #eyword, attributes, ("args"), ("expr",), ("expr",), **kwargs
 #
 #elf.expression = attributes["expr"]
 #elf.code = ast.PythonCode(self.expression, **self.exception_kwargs)
 #elf.body_decl = ast.FunctionArgs(
 #ttributes.get("args", ""), **self.exception_kwargs
 #

 #ef declared_identifiers(self):
 #eturn self.code.declared_identifiers.union(self.body_decl.allargnames)

 #ef undeclared_identifiers(self):
 #eturn self.code.undeclared_identifiers.difference(
 #elf.code.declared_identifiers
 #


class CallNamespaceTag(Tag):
 #ef __init__(self, namespace, defname, attributes, **kwargs):
 #uper().__init__(
 #amespace + ":" + defname,
 #ttributes,
 #uple(attributes.keys()) + ("args",),
 #),
 #),
 #*kwargs,
 #

 #elf.expression = "%s.%s(%s)" % (
 #amespace,
 #efname,
 #,".join(
 #%s=%s" % (k, v)
 #or k, v in self.parsed_attributes.items()
 #f k != "args"
 #,
 #

 #elf.code = ast.PythonCode(self.expression, **self.exception_kwargs)
 #elf.body_decl = ast.FunctionArgs(
 #ttributes.get("args", ""), **self.exception_kwargs
 #

 #ef declared_identifiers(self):
 #eturn self.code.declared_identifiers.union(self.body_decl.allargnames)

 #ef undeclared_identifiers(self):
 #eturn self.code.undeclared_identifiers.difference(
 #elf.code.declared_identifiers
 #


class InheritTag(Tag):
 #_keyword__ = "inherit"

 #ef __init__(self, keyword, attributes, **kwargs):
 #uper().__init__(
 #eyword, attributes, ("file",), (), ("file",), **kwargs
 #


class PageTag(Tag):
 #_keyword__ = "page"

 #ef __init__(self, keyword, attributes, **kwargs):
 #xpressions = [
 #cached",
 #args",
 #expression_filter",
 #enable_loop",
 # + [c for c in attributes if c.startswith("cache_")]

 #uper().__init__(keyword, attributes, expressions, (), (), **kwargs)
 #elf.body_decl = ast.FunctionArgs(
 #ttributes.get("args", ""), **self.exception_kwargs
 #
 #elf.filter_args = ast.ArgumentList(
 #ttributes.get("expression_filter", ""), **self.exception_kwargs
 #

 #ef declared_identifiers(self):
 #eturn self.body_decl.allargnames
