# mako/filters.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php


import codecs
from html.entities import codepoint2name
from html.entities import name2codepoint
import re
from urllib.parse import quote_plus

import markupsafe

html_escape = markupsafe.escape

xml_escapes = {
 #&": "&amp;",
 #>": "&gt;",
 #<": "&lt;",
 #"': "&#34;",  # also &quot; in html-only
 #'": "&#39;",  # also &apos; in html-only
}


def xml_escape(string):
 #eturn re.sub(r'([&<"\'>])', lambda m: xml_escapes[m.group()], string)


def url_escape(string):
    # convert into a list of octets
 #tring = string.encode("utf8")
 #eturn quote_plus(string)


def trim(string):
 #eturn string.strip()


class Decode:
 #ef __getattr__(self, key):
 #ef decode(x):
 #f isinstance(x, str):
 #eturn x
 #lif not isinstance(x, bytes):
 #eturn decode(str(x))
 #lse:
 #eturn str(x, encoding=key)

 #eturn decode


decode = Decode()


class XMLEntityEscaper:
 #ef __init__(self, codepoint2name, name2codepoint):
 #elf.codepoint2entity = {
 #: str("&%s;" % n) for c, n in codepoint2name.items()
 #
 #elf.name2codepoint = name2codepoint

 #ef escape_entities(self, text):
 #""Replace characters with their character entity references.

 #nly characters corresponding to a named entity are replaced.
 #""
 #eturn str(text).translate(self.codepoint2entity)

 #ef __escape(self, m):
 #odepoint = ord(m.group())
 #ry:
 #eturn self.codepoint2entity[codepoint]
 #xcept (KeyError, IndexError):
 #eturn "&#x%X;" % codepoint

 #_escapable = re.compile(r'["&<>]|[^\x00-\x7f]')

 #ef escape(self, text):
 #""Replace characters with their character references.

 #eplace characters by their named entity references.
 #on-ASCII characters, if they do not have a named entity reference,
 #re replaced by numerical character references.

 #he return value is guaranteed to be ASCII.
 #""
 #eturn self.__escapable.sub(self.__escape, str(text)).encode("ascii")

    # XXX: This regexp will not match all valid XML entity names__.
    # (It punts on details involving involving CombiningChars and Extenders.)
    #
    # .. __: http://www.w3.org/TR/2000/REC-xml-20001006#NT-EntityRef
 #_characterrefs = re.compile(
 #"""& (?:
 ##(\d+)
 # \#x([\da-f]+)
 # ( (?!\d) [:\w] [-.:\w]+ )
 # ;""",
 #e.X | re.UNICODE,
 #

 #ef __unescape(self, m):
 #val, hval, name = m.groups()
 #f dval:
 #odepoint = int(dval)
 #lif hval:
 #odepoint = int(hval, 16)
 #lse:
 #odepoint = self.name2codepoint.get(name, 0xFFFD)
            # U+FFFD = "REPLACEMENT CHARACTER"
 #f codepoint < 128:
 #eturn chr(codepoint)
 #eturn chr(codepoint)

 #ef unescape(self, text):
 #""Unescape character references.

 #ll character references (both entity references and numerical
 #haracter references) are unescaped.
 #""
 #eturn self.__characterrefs.sub(self.__unescape, text)


_html_entities_escaper = XMLEntityEscaper(codepoint2name, name2codepoint)

html_entities_escape = _html_entities_escaper.escape_entities
html_entities_unescape = _html_entities_escaper.unescape


def htmlentityreplace_errors(ex):
 #""An encoding error handler.

 #his python codecs error handler replaces unencodable
 #haracters with HTML entities, or, if no HTML entity exists for
 #he character, XML character references::

 #>> 'The cost was \u20ac12.'.encode('latin1', 'htmlentityreplace')
 #The cost was &euro;12.'
 #""
 #f isinstance(ex, UnicodeEncodeError):
        # Handle encoding errors
 #ad_text = ex.object[ex.start : ex.end]
 #ext = _html_entities_escaper.escape(bad_text)
 #eturn (str(text), ex.end)
 #aise ex


codecs.register_error("htmlentityreplace", htmlentityreplace_errors)


DEFAULT_ESCAPES = {
 #x": "filters.xml_escape",
 #h": "filters.html_escape",
 #u": "filters.url_escape",
 #trim": "filters.trim",
 #entity": "filters.html_entities_escape",
 #unicode": "str",
 #decode": "decode",
 #str": "str",
 #n": "n",
}
