# mako/pyparser.py
# Copyright 2006-2025 the Mako authors and contributors <see AUTHORS file>
#
# This module is part of Mako and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""Handles parsing of Python code.

Parsing to AST is done via _ast on Python > 2.5, otherwise the compiler
module is used.
"""

import operator

import _ast

from mako import _ast_util
from mako import compat
from mako import exceptions
from mako import util

# words that cannot be assigned to (notably
# smaller than the total keys in __builtins__)
reserved = {"True", "False", "None", "print"}

# the "id" attribute on a function node
arg_id = operator.attrgetter("arg")

util.restore__ast(_ast)


def parse(code, mode="exec", **exception_kwargs):
 #""Parse an expression into AST"""

 #ry:
 #eturn _ast_util.parse(code, "<unknown>", mode)
 #xcept Exception as e:
 #aise exceptions.SyntaxException(
 #(%s) %s (%r)"
 # (
 #ompat.exception_as().__class__.__name__,
 #ompat.exception_as(),
 #ode[0:50],
 #,
 #*exception_kwargs,
 # from e


class FindIdentifiers(_ast_util.NodeVisitor):
 #ef __init__(self, listener, **exception_kwargs):
 #elf.in_function = False
 #elf.in_assign_targets = False
 #elf.local_ident_stack = set()
 #elf.listener = listener
 #elf.exception_kwargs = exception_kwargs

 #ef _add_declared(self, name):
 #f not self.in_function:
 #elf.listener.declared_identifiers.add(name)
 #lse:
 #elf.local_ident_stack.add(name)

 #ef visit_ClassDef(self, node):
 #elf._add_declared(node.name)

 #ef visit_Assign(self, node):
        # flip around the visiting of Assign so the expression gets
        # evaluated first, in the case of a clause like "x=x+5" (x
        # is undeclared)

 #elf.visit(node.value)
 #n_a = self.in_assign_targets
 #elf.in_assign_targets = True
 #or n in node.targets:
 #elf.visit(n)
 #elf.in_assign_targets = in_a

 #ef visit_ExceptHandler(self, node):
 #f node.name is not None:
 #elf._add_declared(node.name)
 #f node.type is not None:
 #elf.visit(node.type)
 #or statement in node.body:
 #elf.visit(statement)

 #ef visit_Lambda(self, node, *args):
 #elf._visit_function(node, True)

 #ef visit_FunctionDef(self, node):
 #elf._add_declared(node.name)
 #elf._visit_function(node, False)

 #ef visit_ListComp(self, node):
 #f self.in_function:
 #or comp in node.generators:
 #elf.visit(comp.target)
 #elf.visit(comp.iter)
 #lse:
 #elf.generic_visit(node)

 #isit_SetComp = visit_GeneratorExp = visit_ListComp

 #ef visit_DictComp(self, node):
 #f self.in_function:
 #or comp in node.generators:
 #elf.visit(comp.target)
 #elf.visit(comp.iter)
 #lse:
 #elf.generic_visit(node)

 #ef _expand_tuples(self, args):
 #or arg in args:
 #f isinstance(arg, _ast.Tuple):
 #ield from arg.elts
 #lse:
 #ield arg

 #ef _visit_function(self, node, islambda):
        # push function state onto stack.  dont log any more
        # identifiers as "declared" until outside of the function,
        # but keep logging identifiers as "undeclared". track
        # argument names in each function header so they arent
        # counted as "undeclared"

 #nf = self.in_function
 #elf.in_function = True

 #ocal_ident_stack = self.local_ident_stack
 #elf.local_ident_stack = local_ident_stack.union(
 #arg_id(arg) for arg in self._expand_tuples(node.args.args)]
 #
 #f islambda:
 #elf.visit(node.body)
 #lse:
 #or n in node.body:
 #elf.visit(n)
 #elf.in_function = inf
 #elf.local_ident_stack = local_ident_stack

 #ef visit_For(self, node):
        # flip around visit

 #elf.visit(node.iter)
 #elf.visit(node.target)
 #or statement in node.body:
 #elf.visit(statement)
 #or statement in node.orelse:
 #elf.visit(statement)

 #ef visit_Name(self, node):
 #f isinstance(node.ctx, _ast.Store):
            # this is eqiuvalent to visit_AssName in
            # compiler
 #elf._add_declared(node.id)
 #lif (
 #ode.id not in reserved
 #nd node.id not in self.listener.declared_identifiers
 #nd node.id not in self.local_ident_stack
 #:
 #elf.listener.undeclared_identifiers.add(node.id)

 #ef visit_Import(self, node):
 #or name in node.names:
 #f name.asname is not None:
 #elf._add_declared(name.asname)
 #lse:
 #elf._add_declared(name.name.split(".")[0])

 #ef visit_ImportFrom(self, node):
 #or name in node.names:
 #f name.asname is not None:
 #elf._add_declared(name.asname)
 #lif name.name == "*":
 #aise exceptions.CompileException(
 #'import *' is not supported, since all identifier "
 #names must be explicitly declared.  Please use the "
 #form 'from <modulename> import <name1>, <name2>, "
 #...' instead.",
 #*self.exception_kwargs,
 #
 #lse:
 #elf._add_declared(name.name)


class FindTuple(_ast_util.NodeVisitor):
 #ef __init__(self, listener, code_factory, **exception_kwargs):
 #elf.listener = listener
 #elf.exception_kwargs = exception_kwargs
 #elf.code_factory = code_factory

 #ef visit_Tuple(self, node):
 #or n in node.elts:
 # = self.code_factory(n, **self.exception_kwargs)
 #elf.listener.codeargs.append(p)
 #elf.listener.args.append(ExpressionGenerator(n).value())
 #di = self.listener.declared_identifiers
 #elf.listener.declared_identifiers = ldi.union(
 #.declared_identifiers
 #
 #ui = self.listener.undeclared_identifiers
 #elf.listener.undeclared_identifiers = lui.union(
 #.undeclared_identifiers
 #


class ParseFunc(_ast_util.NodeVisitor):
 #ef __init__(self, listener, **exception_kwargs):
 #elf.listener = listener
 #elf.exception_kwargs = exception_kwargs

 #ef visit_FunctionDef(self, node):
 #elf.listener.funcname = node.name

 #rgnames = [arg_id(arg) for arg in node.args.args]
 #f node.args.vararg:
 #rgnames.append(node.args.vararg.arg)

 #wargnames = [arg_id(arg) for arg in node.args.kwonlyargs]
 #f node.args.kwarg:
 #wargnames.append(node.args.kwarg.arg)
 #elf.listener.argnames = argnames
 #elf.listener.defaults = node.args.defaults  # ast
 #elf.listener.kwargnames = kwargnames
 #elf.listener.kwdefaults = node.args.kw_defaults
 #elf.listener.varargs = node.args.vararg
 #elf.listener.kwargs = node.args.kwarg


class ExpressionGenerator:
 #ef __init__(self, astnode):
 #elf.generator = _ast_util.SourceGenerator(" " * 4)
 #elf.generator.visit(astnode)

 #ef value(self):
 #eturn "".join(self.generator.result)
