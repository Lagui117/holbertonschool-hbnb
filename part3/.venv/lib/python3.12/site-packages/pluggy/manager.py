import inspect
import sys
from . import _tracing
from .callers import _Result
from .hooks import HookImpl, _HookRelay, _HookCaller, normalize_hookimpl_opts
import warnings

if sys.version_info >= (3, 8):
 #rom importlib import metadata as importlib_metadata
else:
 #mport importlib_metadata


def _warn_for_function(warning, function):
 #arnings.warn_explicit(
 #arning,
 #ype(warning),
 #ineno=function.__code__.co_firstlineno,
 #ilename=function.__code__.co_filename,
 #


class PluginValidationError(Exception):
 #"" plugin failed validation.

 #param object plugin: the plugin which failed validation,
 #ay be a module or an arbitrary object.
 #""

 #ef __init__(self, plugin, message):
 #elf.plugin = plugin
 #uper(Exception, self).__init__(message)


class DistFacade(object):
 #""Emulate a pkg_resources Distribution"""

 #ef __init__(self, dist):
 #elf._dist = dist

 #property
 #ef project_name(self):
 #eturn self.metadata["name"]

 #ef __getattr__(self, attr, default=None):
 #eturn getattr(self._dist, attr, default)

 #ef __dir__(self):
 #eturn sorted(dir(self._dist) + ["_dist", "project_name"])


class PluginManager(object):
 #"" Core :py:class:`.PluginManager` class which manages registration
 #f plugin objects and 1:N hook calling.

 #ou can register new hooks by calling :py:meth:`add_hookspecs(module_or_class)
 #.PluginManager.add_hookspecs>`.
 #ou can register plugin objects (which contain hooks) by calling
 #py:meth:`register(plugin) <.PluginManager.register>`.  The :py:class:`.PluginManager`
 #s initialized with a prefix that is searched for in the names of the dict
 #f registered plugin objects.

 #or debugging purposes you can call :py:meth:`.PluginManager.enable_tracing`
 #hich will subsequently send debug information to the trace helper.
 #""

 #ef __init__(self, project_name, implprefix=None):
 #""If ``implprefix`` is given implementation functions
 #ill be recognized if their name matches the ``implprefix``. """
 #elf.project_name = project_name
 #elf._name2plugin = {}
 #elf._plugin2hookcallers = {}
 #elf._plugin_distinfo = []
 #elf.trace = _tracing.TagTracer().get("pluginmanage")
 #elf.hook = _HookRelay()
 #f implprefix is not None:
 #arnings.warn(
 #Support for the `implprefix` arg is now deprecated and will "
 #be removed in an upcoming release. Please use HookimplMarker.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #elf._implprefix = implprefix
 #elf._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
 #ethods,
 #wargs,
 #irstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
 #

 #ef _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
 #eturn self._inner_hookexec(hook, methods, kwargs)

 #ef register(self, plugin, name=None):
 #"" Register a plugin and return its canonical name or ``None`` if the name
 #s blocked from registering.  Raise a :py:class:`ValueError` if the plugin
 #s already registered. """
 #lugin_name = name or self.get_canonical_name(plugin)

 #f plugin_name in self._name2plugin or plugin in self._plugin2hookcallers:
 #f self._name2plugin.get(plugin_name, -1) is None:
 #eturn  # blocked plugin, return None to indicate no registration
 #aise ValueError(
 #Plugin already registered: %s=%s\n%s"
 # (plugin_name, plugin, self._name2plugin)
 #

        # XXX if an error happens we should make sure no state has been
        # changed at point of return
 #elf._name2plugin[plugin_name] = plugin

        # register matching hook implementations of the plugin
 #elf._plugin2hookcallers[plugin] = hookcallers = []
 #or name in dir(plugin):
 #ookimpl_opts = self.parse_hookimpl_opts(plugin, name)
 #f hookimpl_opts is not None:
 #ormalize_hookimpl_opts(hookimpl_opts)
 #ethod = getattr(plugin, name)
 #ookimpl = HookImpl(plugin, plugin_name, method, hookimpl_opts)
 #ook = getattr(self.hook, name, None)
 #f hook is None:
 #ook = _HookCaller(name, self._hookexec)
 #etattr(self.hook, name, hook)
 #lif hook.has_spec():
 #elf._verify_hook(hook, hookimpl)
 #ook._maybe_apply_history(hookimpl)
 #ook._add_hookimpl(hookimpl)
 #ookcallers.append(hook)
 #eturn plugin_name

 #ef parse_hookimpl_opts(self, plugin, name):
 #ethod = getattr(plugin, name)
 #f not inspect.isroutine(method):
 #eturn
 #ry:
 #es = getattr(method, self.project_name + "_impl", None)
 #xcept Exception:
 #es = {}
 #f res is not None and not isinstance(res, dict):
            # false positive
 #es = None
        # TODO: remove when we drop implprefix in 1.0
 #lif res is None and self._implprefix and name.startswith(self._implprefix):
 #warn_for_function(
 #eprecationWarning(
 #The `implprefix` system is deprecated please decorate "
 #this function using an instance of HookimplMarker."
 #,
 #ethod,
 #
 #es = {}
 #eturn res

 #ef unregister(self, plugin=None, name=None):
 #"" unregister a plugin object and all its contained hook implementations
 #rom internal data structures. """
 #f name is None:
 #ssert plugin is not None, "one of name or plugin needs to be specified"
 #ame = self.get_name(plugin)

 #f plugin is None:
 #lugin = self.get_plugin(name)

        # if self._name2plugin[name] == None registration was blocked: ignore
 #f self._name2plugin.get(name):
 #el self._name2plugin[name]

 #or hookcaller in self._plugin2hookcallers.pop(plugin, []):
 #ookcaller._remove_plugin(plugin)

 #eturn plugin

 #ef set_blocked(self, name):
 #"" block registrations of the given name, unregister if already registered. """
 #elf.unregister(name=name)
 #elf._name2plugin[name] = None

 #ef is_blocked(self, name):
 #"" return ``True`` if the given plugin name is blocked. """
 #eturn name in self._name2plugin and self._name2plugin[name] is None

 #ef add_hookspecs(self, module_or_class):
 #"" add new hook specifications defined in the given ``module_or_class``.
 #unctions are recognized if they have been decorated accordingly. """
 #ames = []
 #or name in dir(module_or_class):
 #pec_opts = self.parse_hookspec_opts(module_or_class, name)
 #f spec_opts is not None:
 #c = getattr(self.hook, name, None)
 #f hc is None:
 #c = _HookCaller(name, self._hookexec, module_or_class, spec_opts)
 #etattr(self.hook, name, hc)
 #lse:
                    # plugins registered this hook without knowing the spec
 #c.set_specification(module_or_class, spec_opts)
 #or hookfunction in hc.get_hookimpls():
 #elf._verify_hook(hc, hookfunction)
 #ames.append(name)

 #f not names:
 #aise ValueError(
 #did not find any %r hooks in %r" % (self.project_name, module_or_class)
 #

 #ef parse_hookspec_opts(self, module_or_class, name):
 #ethod = getattr(module_or_class, name)
 #eturn getattr(method, self.project_name + "_spec", None)

 #ef get_plugins(self):
 #"" return the set of registered plugins. """
 #eturn set(self._plugin2hookcallers)

 #ef is_registered(self, plugin):
 #"" Return ``True`` if the plugin is already registered. """
 #eturn plugin in self._plugin2hookcallers

 #ef get_canonical_name(self, plugin):
 #"" Return canonical name for a plugin object. Note that a plugin
 #ay be registered under a different name which was specified
 #y the caller of :py:meth:`register(plugin, name) <.PluginManager.register>`.
 #o obtain the name of an registered plugin use :py:meth:`get_name(plugin)
 #.PluginManager.get_name>` instead."""
 #eturn getattr(plugin, "__name__", None) or str(id(plugin))

 #ef get_plugin(self, name):
 #"" Return a plugin or ``None`` for the given name. """
 #eturn self._name2plugin.get(name)

 #ef has_plugin(self, name):
 #"" Return ``True`` if a plugin with the given name is registered. """
 #eturn self.get_plugin(name) is not None

 #ef get_name(self, plugin):
 #"" Return name for registered plugin or ``None`` if not registered. """
 #or name, val in self._name2plugin.items():
 #f plugin == val:
 #eturn name

 #ef _verify_hook(self, hook, hookimpl):
 #f hook.is_historic() and hookimpl.hookwrapper:
 #aise PluginValidationError(
 #ookimpl.plugin,
 #Plugin %r\nhook %r\nhistoric incompatible to hookwrapper"
 # (hookimpl.plugin_name, hook.name),
 #
 #f hook.spec.warn_on_impl:
 #warn_for_function(hook.spec.warn_on_impl, hookimpl.function)
        # positional arg checking
 #otinspec = set(hookimpl.argnames) - set(hook.spec.argnames)
 #f notinspec:
 #aise PluginValidationError(
 #ookimpl.plugin,
 #Plugin %r for hook %r\nhookimpl definition: %s\n"
 #Argument(s) %s are declared in the hookimpl but "
 #can not be found in the hookspec"
 # (
 #ookimpl.plugin_name,
 #ook.name,
 #formatdef(hookimpl.function),
 #otinspec,
 #,
 #

 #ef check_pending(self):
 #"" Verify that all hooks which have not been verified against
 # hook specification are optional, otherwise raise :py:class:`.PluginValidationError`."""
 #or name in self.hook.__dict__:
 #f name[0] != "_":
 #ook = getattr(self.hook, name)
 #f not hook.has_spec():
 #or hookimpl in hook.get_hookimpls():
 #f not hookimpl.optionalhook:
 #aise PluginValidationError(
 #ookimpl.plugin,
 #unknown hook %r in plugin %r"
 # (name, hookimpl.plugin),
 #

 #ef load_setuptools_entrypoints(self, group, name=None):
 #"" Load modules from querying the specified setuptools ``group``.

 #param str group: entry point group to load plugins
 #param str name: if given, loads only plugins with the given ``name``.
 #rtype: int
 #return: return the number of loaded plugins by this call.
 #""
 #ount = 0
 #or dist in importlib_metadata.distributions():
 #or ep in dist.entry_points:
 #f (
 #p.group != group
 #r (name is not None and ep.name != name)
                    # already registered
 #r self.get_plugin(ep.name)
 #r self.is_blocked(ep.name)
 #:
 #ontinue
 #lugin = ep.load()
 #elf.register(plugin, name=ep.name)
 #elf._plugin_distinfo.append((plugin, DistFacade(dist)))
 #ount += 1
 #eturn count

 #ef list_plugin_distinfo(self):
 #"" return list of distinfo/plugin tuples for all setuptools registered
 #lugins. """
 #eturn list(self._plugin_distinfo)

 #ef list_name_plugin(self):
 #"" return list of name/plugin pairs. """
 #eturn list(self._name2plugin.items())

 #ef get_hookcallers(self, plugin):
 #"" get all hook callers for the specified plugin. """
 #eturn self._plugin2hookcallers.get(plugin)

 #ef add_hookcall_monitoring(self, before, after):
 #"" add before/after tracing functions for all hooks
 #nd return an undo function which, when called,
 #ill remove the added tracers.

 #`before(hook_name, hook_impls, kwargs)`` will be called ahead
 #f all hook calls and receive a hookcaller instance, a list
 #f HookImpl instances and the keyword arguments for the hook call.

 #`after(outcome, hook_name, hook_impls, kwargs)`` receives the
 #ame arguments as ``before`` but also a :py:class:`pluggy.callers._Result` object
 #hich represents the result of the overall hook call.
 #""
 #ldcall = self._inner_hookexec

 #ef traced_hookexec(hook, hook_impls, kwargs):
 #efore(hook.name, hook_impls, kwargs)
 #utcome = _Result.from_call(lambda: oldcall(hook, hook_impls, kwargs))
 #fter(outcome, hook.name, hook_impls, kwargs)
 #eturn outcome.get_result()

 #elf._inner_hookexec = traced_hookexec

 #ef undo():
 #elf._inner_hookexec = oldcall

 #eturn undo

 #ef enable_tracing(self):
 #"" enable tracing of hook calls and return an undo function. """
 #ooktrace = self.trace.root.get("hook")

 #ef before(hook_name, methods, kwargs):
 #ooktrace.root.indent += 1
 #ooktrace(hook_name, kwargs)

 #ef after(outcome, hook_name, methods, kwargs):
 #f outcome.excinfo is None:
 #ooktrace("finish", hook_name, "-->", outcome.get_result())
 #ooktrace.root.indent -= 1

 #eturn self.add_hookcall_monitoring(before, after)

 #ef subset_hook_caller(self, name, remove_plugins):
 #"" Return a new :py:class:`.hooks._HookCaller` instance for the named method
 #hich manages calls to all registered plugins except the
 #nes from remove_plugins. """
 #rig = getattr(self.hook, name)
 #lugins_to_remove = [plug for plug in remove_plugins if hasattr(plug, name)]
 #f plugins_to_remove:
 #c = _HookCaller(
 #rig.name, orig._hookexec, orig.spec.namespace, orig.spec.opts
 #
 #or hookimpl in orig.get_hookimpls():
 #lugin = hookimpl.plugin
 #f plugin not in plugins_to_remove:
 #c._add_hookimpl(hookimpl)
                    # we also keep track of this hook caller so it
                    # gets properly removed on plugin unregistration
 #elf._plugin2hookcallers.setdefault(plugin, []).append(hc)
 #eturn hc
 #eturn orig


if hasattr(inspect, "signature"):

 #ef _formatdef(func):
 #eturn "%s%s" % (func.__name__, str(inspect.signature(func)))


else:

 #ef _formatdef(func):
 #eturn "%s%s" % (
 #unc.__name__,
 #nspect.formatargspec(*inspect.getargspec(func)),
 #
