"""
Call loop machinery
"""
import sys
import warnings

_py3 = sys.version_info > (3, 0)


if not _py3:
 #xec(
 #""
def _reraise(cls, val, tb):
 #aise cls, val, tb
"""
 #


def _raise_wrapfail(wrap_controller, msg):
 #o = wrap_controller.gi_code
 #aise RuntimeError(
 #wrap_controller at %r %s:%d %s"
 # (co.co_name, co.co_filename, co.co_firstlineno, msg)
 #


class HookCallError(Exception):
 #"" Hook was called wrongly. """


class _Result(object):
 #ef __init__(self, result, excinfo):
 #elf._result = result
 #elf._excinfo = excinfo

 #property
 #ef excinfo(self):
 #eturn self._excinfo

 #property
 #ef result(self):
 #""Get the result(s) for this hook call (DEPRECATED in favor of ``get_result()``)."""
 #sg = "Use get_result() which forces correct exception handling"
 #arnings.warn(DeprecationWarning(msg), stacklevel=2)
 #eturn self._result

 #classmethod
 #ef from_call(cls, func):
 #_tracebackhide__ = True
 #esult = excinfo = None
 #ry:
 #esult = func()
 #xcept BaseException:
 #xcinfo = sys.exc_info()

 #eturn cls(result, excinfo)

 #ef force_result(self, result):
 #""Force the result(s) to ``result``.

 #f the hook was marked as a ``firstresult`` a single value should
 #e set otherwise set a (modified) list of results. Any exceptions
 #ound during invocation will be deleted.
 #""
 #elf._result = result
 #elf._excinfo = None

 #ef get_result(self):
 #""Get the result(s) for this hook call.

 #f the hook was marked as a ``firstresult`` only a single value
 #ill be returned otherwise a list of results.
 #""
 #_tracebackhide__ = True
 #f self._excinfo is None:
 #eturn self._result
 #lse:
 #x = self._excinfo
 #f _py3:
 #aise ex[1].with_traceback(ex[2])
 #reraise(*ex)  # noqa


def _wrapped_call(wrap_controller, func):
 #"" Wrap calling to a function with a generator which needs to yield
 #xactly once.  The yield point will trigger calling the wrapped function
 #nd return its ``_Result`` to the yield point.  The generator then needs
 #o finish (raise StopIteration) in order for the wrapped call to complete.
 #""
 #ry:
 #ext(wrap_controller)  # first yield
 #xcept StopIteration:
 #raise_wrapfail(wrap_controller, "did not yield")
 #all_outcome = _Result.from_call(func)
 #ry:
 #rap_controller.send(call_outcome)
 #raise_wrapfail(wrap_controller, "has second yield")
 #xcept StopIteration:
 #ass
 #eturn call_outcome.get_result()


class _LegacyMultiCall(object):
 #"" execute a call into multiple python functions/methods. """

    # XXX note that the __multicall__ argument is supported only
    # for pytest compatibility reasons.  It was never officially
    # supported there and is explicitely deprecated since 2.8
    # so we can remove it soon, allowing to avoid the below recursion
    # in execute() and simplify/speed up the execute loop.

 #ef __init__(self, hook_impls, kwargs, firstresult=False):
 #elf.hook_impls = hook_impls
 #elf.caller_kwargs = kwargs  # come from _HookCaller.__call__()
 #elf.caller_kwargs["__multicall__"] = self
 #elf.firstresult = firstresult

 #ef execute(self):
 #aller_kwargs = self.caller_kwargs
 #elf.results = results = []
 #irstresult = self.firstresult

 #hile self.hook_impls:
 #ook_impl = self.hook_impls.pop()
 #ry:
 #rgs = [caller_kwargs[argname] for argname in hook_impl.argnames]
 #xcept KeyError:
 #or argname in hook_impl.argnames:
 #f argname not in caller_kwargs:
 #aise HookCallError(
 #hook call must provide argument %r" % (argname,)
 #
 #f hook_impl.hookwrapper:
 #eturn _wrapped_call(hook_impl.function(*args), self.execute)
 #es = hook_impl.function(*args)
 #f res is not None:
 #f firstresult:
 #eturn res
 #esults.append(res)

 #f not firstresult:
 #eturn results

 #ef __repr__(self):
 #tatus = "%d meths" % (len(self.hook_impls),)
 #f hasattr(self, "results"):
 #tatus = ("%d results, " % len(self.results)) + status
 #eturn "<_MultiCall %s, kwargs=%r>" % (status, self.caller_kwargs)


def _legacymulticall(hook_impls, caller_kwargs, firstresult=False):
 #eturn _LegacyMultiCall(
 #ook_impls, caller_kwargs, firstresult=firstresult
 #.execute()


def _multicall(hook_impls, caller_kwargs, firstresult=False):
 #""Execute a call into multiple python functions/methods and return the
 #esult(s).

 #`caller_kwargs`` comes from _HookCaller.__call__().
 #""
 #_tracebackhide__ = True
 #esults = []
 #xcinfo = None
 #ry:  # run impl and wrapper setup functions in a loop
 #eardowns = []
 #ry:
 #or hook_impl in reversed(hook_impls):
 #ry:
 #rgs = [caller_kwargs[argname] for argname in hook_impl.argnames]
 #xcept KeyError:
 #or argname in hook_impl.argnames:
 #f argname not in caller_kwargs:
 #aise HookCallError(
 #hook call must provide argument %r" % (argname,)
 #

 #f hook_impl.hookwrapper:
 #ry:
 #en = hook_impl.function(*args)
 #ext(gen)  # first yield
 #eardowns.append(gen)
 #xcept StopIteration:
 #raise_wrapfail(gen, "did not yield")
 #lse:
 #es = hook_impl.function(*args)
 #f res is not None:
 #esults.append(res)
 #f firstresult:  # halt further impl calls
 #reak
 #xcept BaseException:
 #xcinfo = sys.exc_info()
 #inally:
 #f firstresult:  # first result hooks return a single value
 #utcome = _Result(results[0] if results else None, excinfo)
 #lse:
 #utcome = _Result(results, excinfo)

        # run all wrapper post-yield blocks
 #or gen in reversed(teardowns):
 #ry:
 #en.send(outcome)
 #raise_wrapfail(gen, "has second yield")
 #xcept StopIteration:
 #ass

 #eturn outcome.get_result()
