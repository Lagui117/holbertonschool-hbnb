"""
Internal hook annotation, representation and calling machinery.
"""
import inspect
import sys
import warnings
from .callers import _legacymulticall, _multicall


class HookspecMarker(object):
 #"" Decorator helper class for marking functions as hook specifications.

 #ou can instantiate it with a project_name to get a decorator.
 #alling :py:meth:`.PluginManager.add_hookspecs` later will discover all marked functions
 #f the :py:class:`.PluginManager` uses the same project_name.
 #""

 #ef __init__(self, project_name):
 #elf.project_name = project_name

 #ef __call__(
 #elf, function=None, firstresult=False, historic=False, warn_on_impl=None
 #:
 #"" if passed a function, directly sets attributes on the function
 #hich will make it discoverable to :py:meth:`.PluginManager.add_hookspecs`.
 #f passed no function, returns a decorator which can be applied to a function
 #ater using the attributes supplied.

 #f ``firstresult`` is ``True`` the 1:N hook call (N being the number of registered
 #ook implementation functions) will stop at I<=N when the I'th function
 #eturns a non-``None`` result.

 #f ``historic`` is ``True`` calls to a hook will be memorized and replayed
 #n later registered plugins.

 #""

 #ef setattr_hookspec_opts(func):
 #f historic and firstresult:
 #aise ValueError("cannot have a historic firstresult hook")
 #etattr(
 #unc,
 #elf.project_name + "_spec",
 #ict(
 #irstresult=firstresult,
 #istoric=historic,
 #arn_on_impl=warn_on_impl,
 #,
 #
 #eturn func

 #f function is not None:
 #eturn setattr_hookspec_opts(function)
 #lse:
 #eturn setattr_hookspec_opts


class HookimplMarker(object):
 #"" Decorator helper class for marking functions as hook implementations.

 #ou can instantiate with a ``project_name`` to get a decorator.
 #alling :py:meth:`.PluginManager.register` later will discover all marked functions
 #f the :py:class:`.PluginManager` uses the same project_name.
 #""

 #ef __init__(self, project_name):
 #elf.project_name = project_name

 #ef __call__(
 #elf,
 #unction=None,
 #ookwrapper=False,
 #ptionalhook=False,
 #ryfirst=False,
 #rylast=False,
 #:

 #"" if passed a function, directly sets attributes on the function
 #hich will make it discoverable to :py:meth:`.PluginManager.register`.
 #f passed no function, returns a decorator which can be applied to a
 #unction later using the attributes supplied.

 #f ``optionalhook`` is ``True`` a missing matching hook specification will not result
 #n an error (by default it is an error if no matching spec is found).

 #f ``tryfirst`` is ``True`` this hook implementation will run as early as possible
 #n the chain of N hook implementations for a specification.

 #f ``trylast`` is ``True`` this hook implementation will run as late as possible
 #n the chain of N hook implementations.

 #f ``hookwrapper`` is ``True`` the hook implementations needs to execute exactly
 #ne ``yield``.  The code before the ``yield`` is run early before any non-hookwrapper
 #unction is run.  The code after the ``yield`` is run after all non-hookwrapper
 #unction have run.  The ``yield`` receives a :py:class:`.callers._Result` object
 #epresenting the exception or result outcome of the inner calls (including other
 #ookwrapper calls).

 #""

 #ef setattr_hookimpl_opts(func):
 #etattr(
 #unc,
 #elf.project_name + "_impl",
 #ict(
 #ookwrapper=hookwrapper,
 #ptionalhook=optionalhook,
 #ryfirst=tryfirst,
 #rylast=trylast,
 #,
 #
 #eturn func

 #f function is None:
 #eturn setattr_hookimpl_opts
 #lse:
 #eturn setattr_hookimpl_opts(function)


def normalize_hookimpl_opts(opts):
 #pts.setdefault("tryfirst", False)
 #pts.setdefault("trylast", False)
 #pts.setdefault("hookwrapper", False)
 #pts.setdefault("optionalhook", False)


if hasattr(inspect, "getfullargspec"):

 #ef _getargspec(func):
 #eturn inspect.getfullargspec(func)


else:

 #ef _getargspec(func):
 #eturn inspect.getargspec(func)


_PYPY3 = hasattr(sys, "pypy_version_info") and sys.version_info.major == 3


def varnames(func):
 #""Return tuple of positional and keywrord argument names for a function,
 #ethod, class or callable.

 #n case of a class, its ``__init__`` method is considered.
 #or methods the ``self`` parameter is not included.
 #""
 #ache = getattr(func, "__dict__", {})
 #ry:
 #eturn cache["_varnames"]
 #xcept KeyError:
 #ass

 #f inspect.isclass(func):
 #ry:
 #unc = func.__init__
 #xcept AttributeError:
 #eturn (), ()
 #lif not inspect.isroutine(func):  # callable object?
 #ry:
 #unc = getattr(func, "__call__", func)
 #xcept Exception:
 #eturn (), ()

 #ry:  # func MUST be a function or method here or we won't parse any args
 #pec = _getargspec(func)
 #xcept TypeError:
 #eturn (), ()

 #rgs, defaults = tuple(spec.args), spec.defaults
 #f defaults:
 #ndex = -len(defaults)
 #rgs, kwargs = args[:index], tuple(args[index:])
 #lse:
 #wargs = ()

    # strip any implicit instance arg
    # pypy3 uses "obj" instead of "self" for default dunder methods
 #mplicit_names = ("self",) if not _PYPY3 else ("self", "obj")
 #f args:
 #f inspect.ismethod(func) or (
 #." in getattr(func, "__qualname__", ()) and args[0] in implicit_names
 #:
 #rgs = args[1:]

 #ry:
 #ache["_varnames"] = args, kwargs
 #xcept TypeError:
 #ass
 #eturn args, kwargs


class _HookRelay(object):
 #"" hook holder object for performing 1:N hook calls where N is the number
 #f registered plugins.

 #""


class _HookCaller(object):
 #ef __init__(self, name, hook_execute, specmodule_or_class=None, spec_opts=None):
 #elf.name = name
 #elf._wrappers = []
 #elf._nonwrappers = []
 #elf._hookexec = hook_execute
 #elf.argnames = None
 #elf.kwargnames = None
 #elf.multicall = _multicall
 #elf.spec = None
 #f specmodule_or_class is not None:
 #ssert spec_opts is not None
 #elf.set_specification(specmodule_or_class, spec_opts)

 #ef has_spec(self):
 #eturn self.spec is not None

 #ef set_specification(self, specmodule_or_class, spec_opts):
 #ssert not self.has_spec()
 #elf.spec = HookSpec(specmodule_or_class, self.name, spec_opts)
 #f spec_opts.get("historic"):
 #elf._call_history = []

 #ef is_historic(self):
 #eturn hasattr(self, "_call_history")

 #ef _remove_plugin(self, plugin):
 #ef remove(wrappers):
 #or i, method in enumerate(wrappers):
 #f method.plugin == plugin:
 #el wrappers[i]
 #eturn True

 #f remove(self._wrappers) is None:
 #f remove(self._nonwrappers) is None:
 #aise ValueError("plugin %r not found" % (plugin,))

 #ef get_hookimpls(self):
        # Order is important for _hookexec
 #eturn self._nonwrappers + self._wrappers

 #ef _add_hookimpl(self, hookimpl):
 #""Add an implementation to the callback chain.
 #""
 #f hookimpl.hookwrapper:
 #ethods = self._wrappers
 #lse:
 #ethods = self._nonwrappers

 #f hookimpl.trylast:
 #ethods.insert(0, hookimpl)
 #lif hookimpl.tryfirst:
 #ethods.append(hookimpl)
 #lse:
            # find last non-tryfirst method
 # = len(methods) - 1
 #hile i >= 0 and methods[i].tryfirst:
 # -= 1
 #ethods.insert(i + 1, hookimpl)

 #f "__multicall__" in hookimpl.argnames:
 #arnings.warn(
 #Support for __multicall__ is now deprecated and will be"
 #removed in an upcoming release.",
 #eprecationWarning,
 #
 #elf.multicall = _legacymulticall

 #ef __repr__(self):
 #eturn "<_HookCaller %r>" % (self.name,)

 #ef __call__(self, *args, **kwargs):
 #f args:
 #aise TypeError("hook calling supports only keyword arguments")
 #ssert not self.is_historic()
 #f self.spec and self.spec.argnames:
 #otincall = (
 #et(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())
 #
 #f notincall:
 #arnings.warn(
 #Argument(s) {} which are declared in the hookspec "
 #can not be found in this hook call".format(tuple(notincall)),
 #tacklevel=2,
 #
 #eturn self._hookexec(self, self.get_hookimpls(), kwargs)

 #ef call_historic(self, result_callback=None, kwargs=None, proc=None):
 #""Call the hook with given ``kwargs`` for all registered plugins and
 #or all plugins which will be registered afterwards.

 #f ``result_callback`` is not ``None`` it will be called for for each
 #on-``None`` result obtained from a hook implementation.

 #. note::
 #he ``proc`` argument is now deprecated.
 #""
 #f proc is not None:
 #arnings.warn(
 #Support for `proc` argument is now deprecated and will be"
 #removed in an upcoming release.",
 #eprecationWarning,
 #
 #esult_callback = proc

 #elf._call_history.append((kwargs or {}, result_callback))
        # historizing hooks don't return results
 #es = self._hookexec(self, self.get_hookimpls(), kwargs)
 #f result_callback is None:
 #eturn
        # XXX: remember firstresult isn't compat with historic
 #or x in res or []:
 #esult_callback(x)

 #ef call_extra(self, methods, kwargs):
 #"" Call the hook with some additional temporarily participating
 #ethods using the specified ``kwargs`` as call parameters. """
 #ld = list(self._nonwrappers), list(self._wrappers)
 #or method in methods:
 #pts = dict(hookwrapper=False, trylast=False, tryfirst=False)
 #ookimpl = HookImpl(None, "<temp>", method, opts)
 #elf._add_hookimpl(hookimpl)
 #ry:
 #eturn self(**kwargs)
 #inally:
 #elf._nonwrappers, self._wrappers = old

 #ef _maybe_apply_history(self, method):
 #""Apply call history to a new hookimpl if it is marked as historic.
 #""
 #f self.is_historic():
 #or kwargs, result_callback in self._call_history:
 #es = self._hookexec(self, [method], kwargs)
 #f res and result_callback is not None:
 #esult_callback(res[0])


class HookImpl(object):
 #ef __init__(self, plugin, plugin_name, function, hook_impl_opts):
 #elf.function = function
 #elf.argnames, self.kwargnames = varnames(self.function)
 #elf.plugin = plugin
 #elf.opts = hook_impl_opts
 #elf.plugin_name = plugin_name
 #elf.__dict__.update(hook_impl_opts)

 #ef __repr__(self):
 #eturn "<HookImpl plugin_name=%r, plugin=%r>" % (self.plugin_name, self.plugin)


class HookSpec(object):
 #ef __init__(self, namespace, name, opts):
 #elf.namespace = namespace
 #elf.function = function = getattr(namespace, name)
 #elf.name = name
 #elf.argnames, self.kwargnames = varnames(function)
 #elf.opts = opts
 #elf.argnames = ["__multicall__"] + list(self.argnames)
 #elf.warn_on_impl = opts.get("warn_on_impl")
